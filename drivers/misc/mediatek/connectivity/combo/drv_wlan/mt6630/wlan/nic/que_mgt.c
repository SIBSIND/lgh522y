/*
                                                                               
*/

/*                     
                                   

                                                                            
                                                                     
                                                                             
*/



/*
                    
  
                      
                                                         
                                               
                                                                  
  
                          
                                        
                                             
  
                      
                                                         
                                   
  
                          
                                        
                                         
  
                      
                                                         
                                          
  
                          
                                        
                                                                                
  
                        
                                                                          
                                                 
  
                      
                                                         
                                                                   
                                                    
  
                      
                                                         
                                       
                                   
  
                          
                                        
    
  
                          
                                        
                                                
  
                      
                                                         
                                        
  
                      
                                                         
                                           
  
                      
                                                         
                              
  
                   
                                                                             
                        
  
                          
                                        
                       
  
                          
                                        
                             
  
                      
                                                         
                                           
                         
                                      
  
                      
                                                         
                                       
                                    
  
                          
                                        
                             
                                     
  
                      
                                                         
                                                    
                                                
  
                      
                                                         
                               
  
                      
                                                         
                             
  
                          
                                        
    
  
                          
                                        
                           
                                           
  
                          
                                        
                          
  
                          
                                        
                                        
  
                      
                                                         
                                                  
  
                   
                                                                                     
                                                               
                                              
  
                      
                                                             
                  
  
                   
                                                                                              
                                        
  
                      
                                                         
                                                        
  
                      
                                                         
                                             
  
                      
                                                         
                                     
                
                   
                                
  
                      
                                                         
                               
  
                      
                                                         
                                  
  
                      
                                                             
                                                  
                                                                      
  
                      
       
                                              
  
                        
                                                                                           
                                          
  
                        
       
                                      
  
                        
                                                                            
                  
  
                        
       
                                                     
  
                        
                                                                            
                                
  
                          
                                                                                            
                                                             
  
                          
                                                                                                
                          
  
                          
                                                                                                
                                            
  
                        
                                                                            
                           
  
                        
                                                                            
                                                
  
                           
       
                                                                                               
  
                           
       
                                               
  
                        
                                                                            
                     
  
                          
                                                                                                
                                                                   
  
                           
       
                                                                        
                                                                                                                              
  
                   
                                                                                                                                
                                               
  
                          
                                                              
                                 
  
                          
                                                              
                                           
  
                        
       
                                    
  
                          
                                                              
                                 
  
                        
                                                                                                                             
                                  
  
                        
                                                                                    
                                                       
  
                        
                                                                              
                                           
  
                        
                                                                              
                                  
  
                        
                                                           
                              
  
                        
                                                                                           
                                        
  
                        
                                                                                                                      
                                                                
  
                        
                                                                                           
                                                     
  
                        
                                                           
                                                   
  
                        
                                                       
                                                 
                                                                               
                     
  
                        
                                                                                                         
                                                                 
  
                        
                                                       
                
  
                        
                                                           
                         
  
                        
                                                                           
                                        
  
                        
                                                                   
                               
  
                        
                                                                                                
                                                           
  
                        
                                                                                               
                                                        
                                                           
  
                        
                                                                                              
                              
  
                          
                                                             
                  
                                                                        
                                                                   
                                                                             
                                                       
  
                        
                                                                                              
                                                                                                                       
  
                        
                                                                                      
                   
  
                        
                                                                                      
                                       
  
                   
                                                                                                                                                                                                               
                                                                                     
  
                        
                                        
                                              
                              
  
                        
                                        
                                              
                                      
  
                        
                                        
                                              
                                                  
                                                                        
  
                          
                                                                                          
                                          
  
                        
                                        
                                              

                                                  
  
                          
                                                               
                                            
  
                        
                                        
                                              

                                   
  
                        
                                        
                                              

                           
  
                                              
  
                          
                                                               
                                                    
                                                       
  
                   
                                                                                                  
                                                       
  
                   
                                                                                                  
                                           
  
                   
                                                                                                  
                                          
  
                   
                                                                                                                                 
                                         
  
                         
                                                                         
                                  
  
                        
       
                                
  
                        
       
                                                                    
                        
  
                        
       
              
  
                        
       
                                                                                                
  
                   
  
                                                                                   
                                                                                    
  
                        
  
                                                                             
  
                        
  
                                        
                                      
                                         
  
                        
  
                              
                                      
  
                        
  
                
                                                                                        
  
                        
  
                                                      
  
                   
  
                                                                               
  
                        
                                        
    
  
                        
                                        
                                                          
  
                        
                                        
                                                      
  
                        
                                        
                                         
  
                        
                                        
                                  
  
                   
                                                    
                                                                    
  
                        
                                        
                                              
  
                        
                                        
                                 
  
                   
                                                    
                      
                                                                      
                                                           
                                         
                                          
  
                         
                                                
                                   
  
                         
                                                          
                        
  
                   
                                                          
                                                                  
  
                         
                                                          
                                       
  
                           
                                             
                                
  
                        
                                                          
                                                                                        
  
                         
                                                          
                                               
  
                         
                                                          
                                                                       
  
                         
                                                          
                                                                     
  
                         
                                                          
                                                               
  
                         
                                                          
                                          
  
                         
                                                          
                                                           
  
                         
                                                          
                                                               
  
                         
                                                          
                          
  
                         
                                                          
                                             
                                                                            
                                      
                                                                            
                         
                                                                            
                                        
                                                                            
                                                                
                                                                           
                                       
                                                                           
                                               
                                                                           
                                                                 
                                                                           
                                        
                                                                           
                                     
                                                                           
                   
  
*/

/*                                                                              
                                                     
                                                                                
*/

/*                                                                              
                                                          
                                                                                
*/
#include "precomp.h"
#include "queue.h"

extern UINT_8 g_arTdlsLink[MAXNUM_TDLS_PEER];

/*                                                                              
                                                
                                                                                
*/

/*                                                                              
                                                 
                                                                                
*/

/*                                                                              
                                                  
                                                                                
*/
OS_SYSTIME g_arMissTimeout[CFG_STA_REC_NUM][CFG_RX_MAX_BA_TID_NUM];

const UINT_8 aucTid2ACI[TX_DESC_TID_NUM] = {
	WMM_AC_BE_INDEX,	/*      */
	WMM_AC_BK_INDEX,	/*      */
	WMM_AC_BK_INDEX,	/*      */
	WMM_AC_BE_INDEX,	/*      */
	WMM_AC_VI_INDEX,	/*      */
	WMM_AC_VI_INDEX,	/*      */
	WMM_AC_VO_INDEX,	/*      */
	WMM_AC_VO_INDEX		/*      */
};

const UINT_8 aucACI2TxQIdx[WMM_AC_INDEX_NUM] = {
	TX_QUEUE_INDEX_AC1,	/*                 */
	TX_QUEUE_INDEX_AC0,	/*                 */
	TX_QUEUE_INDEX_AC2,	/*                 */
	TX_QUEUE_INDEX_AC3	/*                 */
};

const UINT_8 arNetwork2TcResource[HW_BSSID_NUM + 1][NET_TC_NUM] = {
    /*                */
    /*                                                                                                     */
	{TC1_INDEX, TC0_INDEX, TC2_INDEX, TC3_INDEX, TC4_INDEX, TC5_INDEX},	/*     */
	{TC1_INDEX, TC0_INDEX, TC2_INDEX, TC3_INDEX, TC4_INDEX, TC5_INDEX},	/*         */
	{TC1_INDEX, TC0_INDEX, TC2_INDEX, TC3_INDEX, TC4_INDEX, TC5_INDEX},	/*         */
	{TC1_INDEX, TC0_INDEX, TC2_INDEX, TC3_INDEX, TC4_INDEX, TC5_INDEX},	/*         */
	{TC1_INDEX, TC0_INDEX, TC2_INDEX, TC3_INDEX, TC4_INDEX, TC5_INDEX},	/*         */

    /*                */
	/*                                                                      */
};

const UINT_8 aucWmmAC2TcResourceSet1[WMM_AC_INDEX_NUM] = {
    TC1_INDEX,
    TC0_INDEX,
    TC2_INDEX,
    TC3_INDEX
};

#if NIC_TX_ENABLE_SECOND_HW_QUEUE
const UINT_8 aucWmmAC2TcResourceSet2[WMM_AC_INDEX_NUM] = {
    TC7_INDEX,
    TC6_INDEX,
    TC8_INDEX,
    TC9_INDEX
};
#endif
/*                                                                              
                                                   
                                                                                
*/


/*                                                                              
                                             
                                                                                
*/

#define qmHandleRxPackets_AOSP_0 \
	if (IS_BMCAST_MAC_ADDR(pucEthDestAddr)) { \
		prCurrSwRfb->eDst = RX_PKT_DESTINATION_HOST_WITH_FORWARD; \
	} else if (UNEQUAL_MAC_ADDR(prBssInfo->aucOwnMacAddr, pucEthDestAddr)) { \
		prCurrSwRfb->eDst = RX_PKT_DESTINATION_FORWARD; \
		/*                                           */ \
		/*                                                       */ \
	}
#if CFG_RX_REORDERING_ENABLED
#define qmHandleRxPackets_AOSP_1 \
	/*                               */ \
	if (!fgIsBMC && nicRxIsDuplicateFrame(prCurrSwRfb) == TRUE) { \
		DBGLOG(QM, TRACE, ("Duplicated packet is detected\n")); \
		prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL; \
	} \
	/*                             */ \
	if (prCurrSwRfb->fgFragFrame) { \
		prCurrSwRfb = incRxDefragMPDU(prAdapter, prCurrSwRfb, prReturnedQue); \
		if (prCurrSwRfb) { \
			prRxStatus = prCurrSwRfb->prRxStatus; \
			DBGLOG(QM, TRACE, ("defragmentation RxStatus=%x\n", prRxStatus)); \
		} \
	} \
	if (prCurrSwRfb) { \
		fgMicErr = FALSE; \
		if (HAL_RX_STATUS_GET_SEC_MODE(prRxStatus) == CIPHER_SUITE_TKIP_WO_MIC) { \
			if (prCurrSwRfb->prStaRec) { \
				UINT_8 ucBssIndex; \
				P_BSS_INFO_T prBssInfo = NULL; \
				PUINT_8      pucMicKey = NULL; \
				ucBssIndex = prCurrSwRfb->prStaRec->ucBssIndex; \
				ASSERT(ucBssIndex < BSS_INFO_NUM); \
				prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, ucBssIndex); \
				ASSERT(prBssInfo); \
				if (prBssInfo->eCurrentOPMode == OP_MODE_INFRASTRUCTURE) { \
					pucMicKey = &(prAdapter->rWifiVar.rAisSpecificBssInfo.aucRxMicKey[0]); \
				} \
				else { \
					ASSERT(FALSE); \
					/*                                                     */ \
				} \
				/*                    */ \
				/*                                                   */ \
				if (pucMicKey == NULL) { \
					DBGLOG(RX, ERROR, ("Mark NULL the Packet for TKIP Key Error\n")); \
					fgMicErr = TRUE; \
				} \
				else if (tkipMicDecapsulate(prCurrSwRfb, pucMicKey) == FALSE) { \
					fgMicErr = TRUE; \
				} \
			} \
			if (fgMicErr) { \
			    DBGLOG(RX, ERROR, ("Mark NULL the Packet for TKIP Mic Error\n")); \
			    prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL; \
			} \
		} \
		QUEUE_INSERT_TAIL(prReturnedQue, (P_QUE_ENTRY_T)prCurrSwRfb); \
	}
#endif


/*                                                                              
                                                             
                                                                                
*/

/*                                                                              
                                                
                                                                                
*/

/*                                                                            */
/* 
                                    
 
                   
 
                
*/
/*                                                                            */
VOID qmInit(IN P_ADAPTER_T prAdapter)
{
    UINT_32 u4Idx;
#if QM_ADAPTIVE_TC_RESOURCE_CTRL    
    UINT_32 u4TotalMinReservedTcResource = 0;
    UINT_32 u4TotalTcResource = 0;
    UINT_32 u4TotalGurantedTcResource = 0;
#endif

    P_QUE_MGT_T prQM = &prAdapter->rQM;

	/*                                   */

	/*                                                           */
	for (u4Idx = 0; u4Idx < NUM_OF_PER_TYPE_TX_QUEUES; u4Idx++) {
        QUEUE_INITIALIZE(&(prQM->arTxQueue[u4Idx]));
    }

	/*                                                */
    /*                                                    */
	for (u4Idx = 0; u4Idx < CFG_NUM_OF_RX_BA_AGREEMENTS; u4Idx++) {
        prQM->arRxBaTable[u4Idx].fgIsValid = FALSE;
        QUEUE_INITIALIZE(&(prQM->arRxBaTable[u4Idx].rReOrderQue));
        prQM->arRxBaTable[u4Idx].u2WinStart = 0xFFFF;
        prQM->arRxBaTable[u4Idx].u2WinEnd = 0xFFFF;

        prQM->arRxBaTable[u4Idx].fgIsWaitingForPktWithSsn = FALSE;
        prQM->arRxBaTable[u4Idx].fgHasBubble = FALSE;

        cnmTimerInitTimer(prAdapter,
                    &(prQM->arRxBaTable[u4Idx].rReorderBubbleTimer),
				  (PFN_MGMT_TIMEOUT_FUNC) qmHandleReorderBubbleTimeout,
				  (ULONG) (&prQM->arRxBaTable[u4Idx]));

    }
    prQM->ucRxBaCount = 0;

    kalMemSet(&g_arMissTimeout, 0, sizeof(g_arMissTimeout));

#if QM_ADAPTIVE_TC_RESOURCE_CTRL
	/*                                                */
	for (u4Idx = 0; u4Idx < TC_NUM; u4Idx++) {
        prQM->au4AverageQueLen[u4Idx] = 0;
    }

    ASSERT(prQM->u4TimeToAdjustTcResource && prQM->u4TimeToUpdateQueLen);

    for(u4Idx = 0; u4Idx < TC_NUM; u4Idx++) {
        prQM->au4CurrentTcResource[u4Idx] = prAdapter->rTxCtrl.rTc.au2MaxNumOfBuffer[u4Idx];

        if(u4Idx != TC4_INDEX) {
            u4TotalTcResource += prQM->au4CurrentTcResource[u4Idx];
            u4TotalGurantedTcResource += prQM->au4GuaranteedTcResource[u4Idx];
            u4TotalMinReservedTcResource += prQM->au4MinReservedTcResource[u4Idx];
        }
    }

    /*              */
    if(u4TotalMinReservedTcResource > u4TotalTcResource) {
        kalMemZero(prQM->au4MinReservedTcResource, sizeof(prQM->au4MinReservedTcResource));
    }

    if(u4TotalGurantedTcResource > u4TotalTcResource) {
        kalMemZero(prQM->au4GuaranteedTcResource, sizeof(prQM->au4GuaranteedTcResource));
    }

    u4TotalGurantedTcResource = 0;

    /*                                 */    
    for(u4Idx = 0; u4Idx < TC_NUM; u4Idx++) {
        if(prQM->au4GuaranteedTcResource[u4Idx] < prQM->au4MinReservedTcResource[u4Idx]) {
            prQM->au4GuaranteedTcResource[u4Idx] = prQM->au4MinReservedTcResource[u4Idx];
        }

        if(u4Idx != TC4_INDEX) {
            u4TotalGurantedTcResource += prQM->au4GuaranteedTcResource[u4Idx];
        }
    }

    prQM->u4ResidualTcResource = u4TotalTcResource - u4TotalGurantedTcResource;

    prQM->fgTcResourcePostAnnealing = FALSE;

#if QM_FAST_TC_RESOURCE_CTRL
    prQM->fgTcResourceFastReaction = FALSE;
#endif

#endif

#if QM_TEST_MODE
    prQM->u4PktCount = 0;

#if QM_TEST_FAIR_FORWARDING

    prQM->u4CurrentStaRecIndexToEnqueue = 0;
    {
        UINT_8 aucMacAddr[MAC_ADDR_LEN];
        P_STA_RECORD_T prStaRec;

        /*                                                                         */
        aucMacAddr[0] = 0x11;
        aucMacAddr[1] = 0x22;
        aucMacAddr[2] = 0xAA;
        aucMacAddr[3] = 0xBB;
        aucMacAddr[4] = 0xCC;
        aucMacAddr[5] = 0xDD;

        prStaRec = &prAdapter->arStaRec[1];
        ASSERT(prStaRec);

        prStaRec->fgIsValid      = TRUE;
        prStaRec->fgIsQoS        = TRUE;
        prStaRec->fgIsInPS        = FALSE;
        prStaRec->ucNetTypeIndex = NETWORK_TYPE_AIS_INDEX;
		COPY_MAC_ADDR((prStaRec)->aucMacAddr, aucMacAddr);

    }

#endif

#endif

#if QM_FORWARDING_FAIRNESS
	for (u4Idx = 0; u4Idx < NUM_OF_PER_STA_TX_QUEUES; u4Idx++) {
        prQM->au4ResourceUsedCount[u4Idx] = 0;
        prQM->au4HeadStaRecIndex[u4Idx] = 0;
    }

    prQM->u4GlobalResourceUsedCount = 0;
#endif

    prQM->u4TxAllowedStaCount = 0;

}

#if QM_TEST_MODE
VOID qmTestCases(IN P_ADAPTER_T prAdapter)
{
    P_QUE_MGT_T prQM = &prAdapter->rQM;

    DbgPrint("QM: ** TEST MODE **\n");

	if (QM_TEST_STA_REC_DETERMINATION) {
		if (prAdapter->arStaRec[0].fgIsValid) {
            prAdapter->arStaRec[0].fgIsValid = FALSE;
            DbgPrint("QM: (Test) Deactivate STA_REC[0]\n");
		} else {
            prAdapter->arStaRec[0].fgIsValid = TRUE;
            DbgPrint("QM: (Test) Activate STA_REC[0]\n");
        }
    }

	if (QM_TEST_STA_REC_DEACTIVATION) {
        /*                                                                  */

		if (prAdapter->arStaRec[0].fgIsValid) {

            DbgPrint("QM: (Test) Deactivate STA_REC[0]\n");
            qmDeactivateStaRec(prAdapter, &prAdapter->arStaRec[0]);
		} else {

            UINT_8 aucMacAddr[MAC_ADDR_LEN];

            /*                                                                         */
            aucMacAddr[0] = 0x11;
            aucMacAddr[1] = 0x22;
            aucMacAddr[2] = 0xAA;
            aucMacAddr[3] = 0xBB;
            aucMacAddr[4] = 0xCC;
            aucMacAddr[5] = 0xDD;

            DbgPrint("QM: (Test) Activate STA_REC[0]\n");
			qmActivateStaRec(prAdapter,	/*                 */
                0,                      /*                       */
                TRUE,                   /*         */
                NETWORK_TYPE_AIS_INDEX, /*              */
                TRUE,                   /*        */
                aucMacAddr              /*             */
            );
        }
    }

	if (QM_TEST_FAIR_FORWARDING) {
		if (prAdapter->arStaRec[1].fgIsValid) {
			prQM->u4CurrentStaRecIndexToEnqueue++;
            prQM->u4CurrentStaRecIndexToEnqueue %= 2;
			DbgPrint("QM: (Test) Switch to STA_REC[%ld]\n",
				 prQM->u4CurrentStaRecIndexToEnqueue);
        }
    }

}
#endif

/*                                                                            */
/* 
                         
 
                                                       
                                                
 
                
*/
/*                                                                            */
VOID qmUpdateStaRec(IN P_ADAPTER_T prAdapter, IN P_STA_RECORD_T prStaRec)
{
    P_BSS_INFO_T prBssInfo;
    BOOLEAN fgIsTxAllowed = FALSE;

	if (!prStaRec) {
        return;
    }

    prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prStaRec->ucBssIndex);

	/*                           */
	if (prStaRec->fgIsValid) {
		/*                              */
		if (secIsProtectedBss(prAdapter, prBssInfo)) {
			if (prStaRec->fgIsTxKeyReady) {
                fgIsTxAllowed = TRUE;
            }
        }
		/*                       */
        else {
            fgIsTxAllowed = TRUE;
        }
    }        
	/*                     */
	if (prStaRec->fgIsTxAllowed != fgIsTxAllowed) {
		if (fgIsTxAllowed) {
            prAdapter->rQM.u4TxAllowedStaCount++;
		} else {
            prAdapter->rQM.u4TxAllowedStaCount--;
        }
    }
    
    prStaRec->fgIsTxAllowed = fgIsTxAllowed;

}


/*                                                                            */
/* 
                           
 
                                                       
                                                
 
                
*/
/*                                                                            */
VOID qmActivateStaRec(IN P_ADAPTER_T prAdapter, IN P_STA_RECORD_T prStaRec)
{
	/*                        */
	if (!prStaRec) {
        return;
    }

	if (prStaRec->fgIsValid) {	/*                                */
		DBGLOG(QM, WARN,
		       ("QM: (WARNING) Activating a STA_REC which has been activated\n"));
		DBGLOG(QM, WARN, ("QM: (WARNING) Deactivating a STA_REC before re-activating\n"));
		qmDeactivateStaRec(prAdapter, prStaRec);	/*                                                */
    }
	/*                            */
    /*                     */
    prStaRec->ucFreeQuota = 0;
    prStaRec->ucFreeQuotaForDelivery = 0;
    prStaRec->ucFreeQuotaForNonDelivery = 0;
    
    /*                  */
    prStaRec->fgIsValid      = TRUE;
    prStaRec->fgIsInPS       = FALSE;

    /*                                */            
    prStaRec->fgTxAmpduEn = IS_FEATURE_ENABLED(prAdapter->rWifiVar.ucAmpduTx);
    prStaRec->fgRxAmpduEn = IS_FEATURE_ENABLED(prAdapter->rWifiVar.ucAmpduRx);

    nicTxGenerateDescTemplate(prAdapter, prStaRec);

    qmUpdateStaRec(prAdapter, prStaRec);

    /*                                          */
#if 0
    /*                                                             */
	for (i = 0; i < CFG_RX_MAX_BA_TID_NUM; i++) {
        (prStaRec->aprRxReorderParamRefTbl)[i] = NULL;
    }
#endif

	DBGLOG(QM, INFO, ("QM: +STA[%ld]\n", (UINT_32) prStaRec->ucIndex));
}

/*                                                                            */
/* 
                             
 
                                                       
                                                 
 
                
*/
/*                                                                            */
VOID qmDeactivateStaRec(IN P_ADAPTER_T prAdapter, IN P_STA_RECORD_T prStaRec)
{
    UINT_32 i;
    P_MSDU_INFO_T prFlushedTxPacketList = NULL;

	if (!prStaRec) {
        return;
    }
	/*                       */
    prFlushedTxPacketList = qmFlushStaTxQueues(prAdapter, prStaRec->ucIndex);

	if (prFlushedTxPacketList) {
        wlanProcessQueuedMsduInfo(prAdapter, prFlushedTxPacketList);
    }
	/*                                                   */
	for (i = 0; i < CFG_RX_MAX_BA_TID_NUM; i++) {
        /*                                     */
		qmDelRxBaEntry(prAdapter, prStaRec->ucIndex, (UINT_8) i, FALSE);
    }

	/*                              */
    prStaRec->fgIsValid = FALSE;
    prStaRec->fgIsInPS = FALSE;
    prStaRec->fgIsTxKeyReady = FALSE;

    /*                     */
    prStaRec->ucFreeQuota = 0;
    prStaRec->ucFreeQuotaForDelivery = 0;
    prStaRec->ucFreeQuotaForNonDelivery = 0;

    nicTxFreeDescTemplate(prAdapter, prStaRec);

    qmUpdateStaRec(prAdapter, prStaRec);

    DBGLOG(QM, INFO, ("QM: -STA[%u]\n", prStaRec->ucIndex));
}


/*                                                                            */
/* 
                             
 
                                                       
                                            
 
                
*/
/*                                                                            */
VOID qmFreeAllByBssIdx(IN P_ADAPTER_T prAdapter, IN UINT_8 ucBssIndex)
{

    P_QUE_MGT_T prQM;
    P_QUE_T     prQue;
    QUE_T       rNeedToFreeQue;
    QUE_T       rTempQue;
    P_QUE_T     prNeedToFreeQue;
    P_QUE_T     prTempQue;
    P_MSDU_INFO_T prMsduInfo;


    prQM = &prAdapter->rQM;
    prQue = &prQM->arTxQueue[TX_QUEUE_INDEX_BMCAST];

    QUEUE_INITIALIZE(&rNeedToFreeQue);
    QUEUE_INITIALIZE(&rTempQue);

    prNeedToFreeQue = &rNeedToFreeQue;
    prTempQue = &rTempQue;

    QUEUE_MOVE_ALL(prTempQue, prQue);

    QUEUE_REMOVE_HEAD(prTempQue, prMsduInfo, P_MSDU_INFO_T);
    while (prMsduInfo) {

		if (prMsduInfo->ucBssIndex == ucBssIndex) {
			QUEUE_INSERT_TAIL(prNeedToFreeQue, (P_QUE_ENTRY_T) prMsduInfo);
		} else {
			QUEUE_INSERT_TAIL(prQue, (P_QUE_ENTRY_T) prMsduInfo);
        }

        QUEUE_REMOVE_HEAD(prTempQue, prMsduInfo, P_MSDU_INFO_T);
    }
	if (QUEUE_IS_NOT_EMPTY(prNeedToFreeQue)) {
		wlanProcessQueuedMsduInfo(prAdapter,
					  (P_MSDU_INFO_T) QUEUE_GET_HEAD(prNeedToFreeQue));
    }

}

/*                                                                            */
/* 
                            
 
                   
 
                                                       
*/
/*                                                                            */
P_MSDU_INFO_T qmFlushTxQueues(IN P_ADAPTER_T prAdapter)
{
    UINT_8 ucStaArrayIdx;
    UINT_8 ucQueArrayIdx;

    P_MSDU_INFO_T prMsduInfoListHead;
    P_MSDU_INFO_T prMsduInfoListTail;

    P_QUE_MGT_T prQM = &prAdapter->rQM;

    DBGLOG(QM, TRACE, ("QM: Enter qmFlushTxQueues()\n"));

    prMsduInfoListHead = NULL;
    prMsduInfoListTail = NULL;

    /*                                              */
	for (ucStaArrayIdx = 0; ucStaArrayIdx < CFG_NUM_OF_STA_RECORD; ucStaArrayIdx++) {

        /*                                                                                    */
#if 0
		if (!prAdapter->arStaRec[ucStaArrayIdx].fgIsValid) {
            continue; /*                                    */
        }
#endif

		for (ucQueArrayIdx = 0; ucQueArrayIdx < NUM_OF_PER_STA_TX_QUEUES; ucQueArrayIdx++) {
			if (QUEUE_IS_EMPTY
			    (&(prAdapter->arStaRec[ucStaArrayIdx].arTxQueue[ucQueArrayIdx]))) {
               continue; /*                                                     */
            }

			if (!prMsduInfoListHead) {

                /*                              */
				prMsduInfoListHead = (P_MSDU_INFO_T)
				    QUEUE_GET_HEAD(&prAdapter->arStaRec[ucStaArrayIdx].
						   arTxQueue[ucQueArrayIdx]);
				prMsduInfoListTail = (P_MSDU_INFO_T)
				    QUEUE_GET_TAIL(&prAdapter->arStaRec[ucStaArrayIdx].
						   arTxQueue[ucQueArrayIdx]);
			} else {
                /*                                                       */
                QM_TX_SET_NEXT_MSDU_INFO(prMsduInfoListTail,
							 QUEUE_GET_HEAD(&prAdapter->
									arStaRec[ucStaArrayIdx].
									arTxQueue[ucQueArrayIdx]));

                prMsduInfoListTail = (P_MSDU_INFO_T)
				    QUEUE_GET_TAIL(&prAdapter->arStaRec[ucStaArrayIdx].
						   arTxQueue[ucQueArrayIdx]);
            }

			QUEUE_INITIALIZE(&prAdapter->arStaRec[ucStaArrayIdx].
					 arTxQueue[ucQueArrayIdx]);
        }
    }

    /*                       */
	for (ucQueArrayIdx = 0; ucQueArrayIdx < NUM_OF_PER_TYPE_TX_QUEUES; ucQueArrayIdx++) {

		if (QUEUE_IS_EMPTY(&(prQM->arTxQueue[ucQueArrayIdx]))) {
           continue; /*                                                     */
        }

		if (!prMsduInfoListHead) {

            /*                              */
			prMsduInfoListHead = (P_MSDU_INFO_T)
                QUEUE_GET_HEAD(&prQM->arTxQueue[ucQueArrayIdx]);
			prMsduInfoListTail = (P_MSDU_INFO_T)
                QUEUE_GET_TAIL(&prQM->arTxQueue[ucQueArrayIdx]);
		} else {
            /*                                                       */
            QM_TX_SET_NEXT_MSDU_INFO(prMsduInfoListTail,
                QUEUE_GET_HEAD(&prQM->arTxQueue[ucQueArrayIdx]));

            prMsduInfoListTail = (P_MSDU_INFO_T)
                QUEUE_GET_TAIL(&prQM->arTxQueue[ucQueArrayIdx]);
        }

        QUEUE_INITIALIZE(&prQM->arTxQueue[ucQueArrayIdx]);

    }

	if (prMsduInfoListTail) {
        /*                                                  */
        QM_TX_SET_NEXT_MSDU_INFO(prMsduInfoListTail, NULL);
    }

    return prMsduInfoListHead;
}


/*                                                                            */
/* 
                                              
 
                                      
 
                                                       
*/
/*                                                                            */
P_MSDU_INFO_T qmFlushStaTxQueues(IN P_ADAPTER_T prAdapter, IN UINT_32 u4StaRecIdx)
{
    UINT_8 ucQueArrayIdx;
    P_MSDU_INFO_T prMsduInfoListHead;
    P_MSDU_INFO_T prMsduInfoListTail;
    P_STA_RECORD_T prStaRec;

    DBGLOG(QM, TRACE, ("QM: Enter qmFlushStaTxQueues(%ld)\n", u4StaRecIdx));

    ASSERT(u4StaRecIdx < CFG_NUM_OF_STA_RECORD);

    prMsduInfoListHead = NULL;
    prMsduInfoListTail = NULL;

    prStaRec = &prAdapter->arStaRec[u4StaRecIdx];
    ASSERT(prStaRec);

    /*                                                          */
#if 0
	if (!prStaRec->fgIsValid) {
        return NULL;
    }
#endif

    /*                                                         */
	for (ucQueArrayIdx = 0; ucQueArrayIdx < NUM_OF_PER_STA_TX_QUEUES; ucQueArrayIdx++) {
		if (QUEUE_IS_EMPTY(&(prStaRec->arTxQueue[ucQueArrayIdx]))) {
            continue;
        }

		if (!prMsduInfoListHead) {
            /*                              */
			prMsduInfoListHead = (P_MSDU_INFO_T)
                QUEUE_GET_HEAD(&prStaRec->arTxQueue[ucQueArrayIdx]);
			prMsduInfoListTail = (P_MSDU_INFO_T)
			    QUEUE_GET_TAIL(&prStaRec->arTxQueue[ucQueArrayIdx]);
		} else {
            /*                                                       */
            QM_TX_SET_NEXT_MSDU_INFO(prMsduInfoListTail,
						 QUEUE_GET_HEAD(&prStaRec->
								arTxQueue[ucQueArrayIdx]));

            prMsduInfoListTail =
			    (P_MSDU_INFO_T) QUEUE_GET_TAIL(&prStaRec->arTxQueue[ucQueArrayIdx]);
        }

        QUEUE_INITIALIZE(&prStaRec->arTxQueue[ucQueArrayIdx]);

    }

#if 0
	if (prMsduInfoListTail) {
        /*                                                  */
		QM_TX_SET_NEXT_MSDU_INFO(prMsduInfoListTail,
					 nicGetPendingStaMMPDU(prAdapter, (UINT_8) u4StaRecIdx));
	} else {
		prMsduInfoListHead = nicGetPendingStaMMPDU(prAdapter, (UINT_8) u4StaRecIdx);
    }
#endif

    return prMsduInfoListHead;

}

/*                                                                            */
/* 
                         
 
                   
 
                                                    
*/
/*                                                                            */
P_SW_RFB_T qmFlushRxQueues(IN P_ADAPTER_T prAdapter)
{
    UINT_32 i;
    P_SW_RFB_T prSwRfbListHead;
    P_SW_RFB_T prSwRfbListTail;
    P_QUE_MGT_T prQM = &prAdapter->rQM;

    prSwRfbListHead = prSwRfbListTail = NULL;

    DBGLOG(QM, TRACE, ("QM: Enter qmFlushRxQueues()\n"));

	for (i = 0; i < CFG_NUM_OF_RX_BA_AGREEMENTS; i++) {
		if (QUEUE_IS_NOT_EMPTY(&(prQM->arRxBaTable[i].rReOrderQue))) {
			if (!prSwRfbListHead) {

                /*                              */
				prSwRfbListHead = (P_SW_RFB_T)
                    QUEUE_GET_HEAD(&(prQM->arRxBaTable[i].rReOrderQue));
				prSwRfbListTail = (P_SW_RFB_T)
                    QUEUE_GET_TAIL(&(prQM->arRxBaTable[i].rReOrderQue));
			} else {
                /*                                                       */
                QM_TX_SET_NEXT_MSDU_INFO(prSwRfbListTail,
							 QUEUE_GET_HEAD(&
									(prQM->arRxBaTable[i].
									 rReOrderQue)));

                prSwRfbListTail = (P_SW_RFB_T)
                    QUEUE_GET_TAIL(&(prQM->arRxBaTable[i].rReOrderQue));
            }

            QUEUE_INITIALIZE(&(prQM->arRxBaTable[i].rReOrderQue));

		} else {
            continue;
        }
    }

	if (prSwRfbListTail) {
        /*                                                  */
        QM_TX_SET_NEXT_SW_RFB(prSwRfbListTail, NULL);
    }
    return prSwRfbListHead;

}


/*                                                                            */
/* 
                                                          
 
                                      
                      
 
                                                    
*/
/*                                                                            */
P_SW_RFB_T qmFlushStaRxQueue(IN P_ADAPTER_T prAdapter, IN UINT_32 u4StaRecIdx, IN UINT_32 u4Tid)
{
	/*            */
    P_SW_RFB_T prSwRfbListHead;
    P_SW_RFB_T prSwRfbListTail;
    P_RX_BA_ENTRY_T prReorderQueParm;
    P_STA_RECORD_T prStaRec;

    DBGLOG(QM, TRACE, ("QM: Enter qmFlushStaRxQueues(%ld)\n", u4StaRecIdx));

    prSwRfbListHead = prSwRfbListTail = NULL;

    prStaRec = &prAdapter->arStaRec[u4StaRecIdx];
    ASSERT(prStaRec);

    /*                                                          */
#if 0
	if (!prStaRec->fgIsValid) {
        return NULL;
    }
#endif

    /*                                */
    prReorderQueParm = ((prStaRec->aprRxReorderParamRefTbl)[u4Tid]);

    /*                                                                                */
	if (prReorderQueParm) {

		if (QUEUE_IS_NOT_EMPTY(&(prReorderQueParm->rReOrderQue))) {

			prSwRfbListHead = (P_SW_RFB_T)
                QUEUE_GET_HEAD(&(prReorderQueParm->rReOrderQue));
			prSwRfbListTail = (P_SW_RFB_T)
                QUEUE_GET_TAIL(&(prReorderQueParm->rReOrderQue));


            QUEUE_INITIALIZE(&(prReorderQueParm->rReOrderQue));

        }
    }

	if (prSwRfbListTail) {
        /*                                                  */
        QM_TX_SET_NEXT_SW_RFB(prSwRfbListTail, NULL);
    }
    return prSwRfbListHead;


}

P_QUE_T qmDetermineStaTxQueue(IN P_ADAPTER_T prAdapter, IN P_MSDU_INFO_T prMsduInfo, 
    OUT PUINT_8 pucTC)
{
	P_QUE_T prTxQue = NULL;
	P_STA_RECORD_T prStaRec;
	ENUM_WMM_ACI_T eAci = WMM_AC_BE_INDEX;
  	BOOLEAN fgCheckACMAgain;
	UINT_8 ucTC;
    P_BSS_INFO_T prBssInfo;
    UINT_8 aucNextUP[WMM_AC_INDEX_NUM] = 
        {1 /*        */, 
         1 /*    */, 
         0 /*        */, 
         4 /*        */};    

    prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prMsduInfo->ucBssIndex);
    prStaRec = QM_GET_STA_REC_PTR_FROM_INDEX(prAdapter, prMsduInfo->ucStaRecIndex);

    if (prMsduInfo->ucUserPriority < 8) {
    	QM_DBG_CNT_INC(&prAdapter->rQM, prMsduInfo->ucUserPriority + 15);
    	/*               *//*               *//*               *//*               */
    	/*               *//*               *//*               *//*               */
    }

    eAci = WMM_AC_BE_INDEX;
    do {
    	fgCheckACMAgain = FALSE;
    	if (prStaRec->fgIsQoS) {
    		if (prMsduInfo->ucUserPriority < TX_DESC_TID_NUM) {
    			eAci = aucTid2ACI[prMsduInfo->ucUserPriority];
    			prTxQue = &prStaRec->arTxQueue[aucACI2TxQIdx[eAci]];
    			ucTC = arNetwork2TcResource[prMsduInfo->ucBssIndex][eAci];
    		} else {
    			prTxQue = &prStaRec->arTxQueue[TX_QUEUE_INDEX_AC1];
    			ucTC = TC1_INDEX;
    			eAci = WMM_AC_BE_INDEX;
    			DBGLOG(QM, WARN, ("Packet TID is not in [0~7]\n"));
    			ASSERT(0);
    		}
    		if ((prBssInfo->arACQueParms[eAci].ucIsACMSet) && (eAci != WMM_AC_BK_INDEX)) {
    			prMsduInfo->ucUserPriority = aucNextUP[eAci];
    			fgCheckACMAgain = TRUE;
    		}
    	} else {
    		prTxQue = &prStaRec->arTxQueue[TX_QUEUE_INDEX_NON_QOS];
    		ucTC = arNetwork2TcResource[prMsduInfo->ucBssIndex][NET_TC_NON_STAREC_NON_QOS_INDEX];
    	}

    	if (prAdapter->rWifiVar.ucTcRestrict < TC_NUM) {
    		ucTC = prAdapter->rWifiVar.ucTcRestrict;
    		prTxQue = &prStaRec->arTxQueue[ucTC];
    	}

    } while (fgCheckACMAgain);

    *pucTC = ucTC;

    return prTxQue;
}

VOID
qmSetTxPacketDescTemplate(IN P_ADAPTER_T prAdapter, 
    IN P_MSDU_INFO_T prMsduInfo)
{
    P_STA_RECORD_T prStaRec = 
        QM_GET_STA_REC_PTR_FROM_INDEX(prAdapter, prMsduInfo->ucStaRecIndex);

	/*                                           */
	if (prStaRec && prStaRec->aprTxDescTemplate[prMsduInfo->ucUserPriority]) {
		prMsduInfo->fgIsTXDTemplateValid = TRUE;
	} else {
		if (prStaRec) {
			DBGLOG(QM, TRACE,
			       ("Cannot get TXD template for STA[%u] QoS[%u] MSDU UP[%u]\n",
				prStaRec->ucIndex, prStaRec->fgIsQoS,
				prMsduInfo->ucUserPriority));
		}
		prMsduInfo->fgIsTXDTemplateValid = FALSE;
	}
}


/*                                                                            */
/* 
                           
 
                                                                 
 
                                                   
*/
/*                                                                            */
P_MSDU_INFO_T qmEnqueueTxPackets(IN P_ADAPTER_T prAdapter, IN P_MSDU_INFO_T prMsduInfoListHead)
{
    P_MSDU_INFO_T   prMsduInfoReleaseList;
    P_MSDU_INFO_T   prCurrentMsduInfo;
    P_MSDU_INFO_T   prNextMsduInfo;

    P_QUE_T         prTxQue;
    QUE_T           rNotEnqueuedQue;

    UINT_8          ucTC;
    P_QUE_MGT_T     prQM = &prAdapter->rQM;
    P_BSS_INFO_T    prBssInfo;
	BOOLEAN fgDropPacket;
        
    DBGLOG(QM, LOUD, ("Enter qmEnqueueTxPackets\n"));

    ASSERT(prMsduInfoListHead);

    prMsduInfoReleaseList = NULL;
    prCurrentMsduInfo = NULL;
    QUEUE_INITIALIZE(&rNotEnqueuedQue);
    prNextMsduInfo = prMsduInfoListHead;

	do {
        prCurrentMsduInfo = prNextMsduInfo;
        prNextMsduInfo = QM_TX_GET_NEXT_MSDU_INFO(prCurrentMsduInfo);
        ucTC = TC1_INDEX;

		/*                                */
        prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prCurrentMsduInfo->ucBssIndex);
      
		if (!prBssInfo) {
            /*             */
            fgDropPacket = TRUE;
		} else if (IS_BSS_ACTIVE(prBssInfo)) {
            /*            */
            fgDropPacket = FALSE;
		} else {
            /*              */
            fgDropPacket = TRUE;
        }

		if (!fgDropPacket) {
			/*                                */
            /*                                                */
            qmDetermineStaRecIndex(prAdapter, prCurrentMsduInfo);

			DBGLOG(QM, LOUD,
			       ("Enqueue MSDU by StaRec[%u]!\n", prCurrentMsduInfo->ucStaRecIndex));

			switch (prCurrentMsduInfo->ucStaRecIndex) {
            case STA_REC_INDEX_BMCAST:
                prTxQue = &prQM->arTxQueue[TX_QUEUE_INDEX_BMCAST];
			    ucTC = arNetwork2TcResource[prCurrentMsduInfo->ucBssIndex]
			        [NET_TC_NON_STAREC_NON_QOS_INDEX];

                /*                                                */
    			if (!(prCurrentMsduInfo->u4Option & MSDU_OPT_MANUAL_RETRY_LIMIT)) {
                        nicTxSetPktRetryLimit(prCurrentMsduInfo, TX_DESC_TX_COUNT_NO_LIMIT);
                }      

                QM_DBG_CNT_INC(prQM, QM_DBG_CNT_23);
                break;

            case STA_REC_INDEX_NOT_FOUND:
                /*                                    */
                DBGLOG(QM, TRACE, ("Drop the Packet for no STA_REC\n"));

                prTxQue = &rNotEnqueuedQue;
                
                TX_INC_CNT(&prAdapter->rTxCtrl, TX_INACTIVE_STA_DROP);
                QM_DBG_CNT_INC(prQM, QM_DBG_CNT_24);
                break;

            default:
                prTxQue = qmDetermineStaTxQueue(prAdapter, prCurrentMsduInfo, &ucTC);
                break; /*        */
            } /*                                           */

			if ((prCurrentMsduInfo->eSrc == TX_PACKET_FORWARDING)) {
                DBGLOG(QM, TRACE, ("Forward Pkt to STA[%u] BSS[%u]\n", 
                    prCurrentMsduInfo->ucStaRecIndex, 
                    prCurrentMsduInfo->ucBssIndex));

				if (prTxQue->u4NumElem >= prQM->u4MaxForwardBufferCount) {
					DBGLOG(QM, INFO,
					       ("Drop the Packet for full Tx queue (forwarding) Bss %u\n",
						prCurrentMsduInfo->ucBssIndex));
                    prTxQue = &rNotEnqueuedQue;
                    TX_INC_CNT(&prAdapter->rTxCtrl, TX_FORWARD_OVERFLOW_DROP);
                 }
             }

		} else {
			DBGLOG(QM, TRACE,
			       ("Drop the Packet for inactive Bss %u\n",
				prCurrentMsduInfo->ucBssIndex));
            QM_DBG_CNT_INC(prQM, QM_DBG_CNT_31);
            prTxQue = &rNotEnqueuedQue;
            TX_INC_CNT(&prAdapter->rTxCtrl, TX_INACTIVE_BSS_DROP);
        }

		/*                                                         */
        /*                                                            
                                                     
        */
        prCurrentMsduInfo->ucTC = ucTC;
        
        /*                                           */
        qmSetTxPacketDescTemplate(prAdapter, prCurrentMsduInfo);

		/*                          */
		QUEUE_INSERT_TAIL(prTxQue, (P_QUE_ENTRY_T) prCurrentMsduInfo);

#if QM_FAST_TC_RESOURCE_CTRL && QM_ADAPTIVE_TC_RESOURCE_CTRL
		if (prTxQue != &rNotEnqueuedQue) {
            /*                                                                  */ 
            qmCheckForFastTcResourceCtrl(prAdapter, ucTC);
        }
#endif        

#if QM_TEST_MODE
		if (++prQM->u4PktCount == QM_TEST_TRIGGER_TX_COUNT) {
            prQM->u4PktCount = 0;
            qmTestCases(prAdapter);
        }
#endif

        DBGLOG(QM, LOUD, ("Current queue length = %u\n", prTxQue->u4NumElem));
	} while (prNextMsduInfo);

	if (QUEUE_IS_NOT_EMPTY(&rNotEnqueuedQue)) {
		QM_TX_SET_NEXT_MSDU_INFO((P_MSDU_INFO_T) QUEUE_GET_TAIL(&rNotEnqueuedQue), NULL);
		prMsduInfoReleaseList = (P_MSDU_INFO_T) QUEUE_GET_HEAD(&rNotEnqueuedQue);
    }
#if QM_ADAPTIVE_TC_RESOURCE_CTRL
	/*                                                    */
    /*                                */
    qmDoAdaptiveTcResourceCtrl(prAdapter);
#endif    

    return prMsduInfoReleaseList;
}

/*                                                                            */
/* 
                                                 
 
                                             
 
                
*/
/*                                                                            */
VOID qmDetermineStaRecIndex(IN P_ADAPTER_T prAdapter, IN P_MSDU_INFO_T prMsduInfo)
{
    UINT_32 i;  

    P_STA_RECORD_T prTempStaRec;
    P_BSS_INFO_T prBssInfo;

    prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prMsduInfo->ucBssIndex);
    prTempStaRec = NULL;

    ASSERT(prMsduInfo);

    DBGLOG(QM, LOUD, ("Msdu BSS Idx[%u] OpMode[%u] StaRecOfApExist[%u]\n", 
        prMsduInfo->ucBssIndex, 
			  prBssInfo->eCurrentOPMode, prBssInfo->prStaRecOfAP ? TRUE : FALSE));

	switch (prBssInfo->eCurrentOPMode) {
        case OP_MODE_IBSS:
        case OP_MODE_ACCESS_POINT:
		/*                   */
		if (IS_BMCAST_MAC_ADDR(prMsduInfo->aucEthDestAddr)) {
                prMsduInfo->ucStaRecIndex = STA_REC_INDEX_BMCAST;
                DBGLOG(QM, LOUD, ("TX with DA = BMCAST\n"));
                return;
            }
            break;
            
        /*                 */
        case OP_MODE_INFRASTRUCTURE:            
        case OP_MODE_BOW:
		if (prBssInfo->prStaRecOfAP) {
#if CFG_SUPPORT_TDLS

			prTempStaRec =
			    cnmGetTdlsPeerByAddress(prAdapter, prBssInfo->ucBssIndex,
						    prMsduInfo->aucEthDestAddr);
			if (IS_DLS_STA(prTempStaRec) && prTempStaRec->ucStaState == STA_STATE_3) {
				if (g_arTdlsLink[prTempStaRec->ucTdlsIndex]) {
						prMsduInfo->ucStaRecIndex = prTempStaRec->ucIndex;
						return;
					}
				}
#endif
			/*                                     */
                prTempStaRec = prBssInfo->prStaRecOfAP;
                
			DBGLOG(QM, LOUD,
			       ("StaOfAp Idx[%u] WIDX[%u] Valid[%u] TxAllowed[%u] InUse[%u] Type[%u]\n",
				prTempStaRec->ucIndex, prTempStaRec->ucWlanIndex,
				prTempStaRec->fgIsValid, prTempStaRec->fgIsTxAllowed,
				prTempStaRec->fgIsInUse, prTempStaRec->eStaType));
                
			if (prTempStaRec->fgIsInUse) {
                    prMsduInfo->ucStaRecIndex = prTempStaRec->ucIndex;
                    DBGLOG(QM, LOUD, ("TX with AP_STA[%u]\n", prTempStaRec->ucIndex));
                    return;
                }
            }
            break;

        case OP_MODE_P2P_DEVICE:
            break;

        default:
            break;
    }


	/*                                                                                                   */
	for (i = 0; i < CFG_NUM_OF_STA_RECORD; i++) {
        prTempStaRec = &(prAdapter->arStaRec[i]);
		if (prTempStaRec->fgIsInUse) {
			if (EQUAL_MAC_ADDR(prTempStaRec->aucMacAddr, prMsduInfo->aucEthDestAddr)) {
                prMsduInfo->ucStaRecIndex = prTempStaRec->ucIndex;
                DBGLOG(QM, LOUD, ("TX with STA[%u]\n", prTempStaRec->ucIndex));
                return;
            }
        }
    }           

	/*                                                             */
    prMsduInfo->ucStaRecIndex = STA_REC_INDEX_NOT_FOUND;
    DBGLOG(QM, LOUD, ("QM: TX with STA_REC_INDEX_NOT_FOUND\n"));

#if (QM_TEST_MODE && QM_TEST_FAIR_FORWARDING)
	prMsduInfo->ucStaRecIndex = (UINT_8) prQM->u4CurrentStaRecIndexToEnqueue;
#endif
}

P_STA_RECORD_T qmDetermineStaToBeDequeued(IN P_ADAPTER_T prAdapter, IN UINT_32 u4StartStaRecIndex)
{

    return NULL;
}

P_QUE_T qmDequeueStaTxPackets(IN P_ADAPTER_T prAdapter)
{

    return NULL;
}

/*                                                                            */
/* 
                                                              
 
                                                         
                                                       
                                                            
 
                
*/
/*                                                                            */
UINT_32
qmDequeueTxPacketsFromPerStaQueues(IN P_ADAPTER_T prAdapter,
    OUT P_QUE_T         prQue,
    IN UINT_8           ucTC,
				   IN UINT_32 u4CurrentQuota, IN UINT_32 u4TotalQuota)
{
    UINT_32         ucLoop;  /*          */

    UINT_32         u4CurStaIndex = 0;
    UINT_32         u4CurStaUsedResource = 0;

    P_STA_RECORD_T  prStaRec;           /*                         */
    P_BSS_INFO_T    prBssInfo;          /*                                 */
    P_QUE_T         prCurrQueue;        /*                                 */
    P_MSDU_INFO_T   prDequeuedPkt;      /*                     */

    UINT_32         u4CurStaForwardFrameCount;     /*                                                   */
    UINT_32         u4MaxForwardFrameCountLimit;   /*                                                 */
    UINT_32         u4AvaliableResource;      /*                        */
    UINT_32         u4MaxResourceLimit;
    
    BOOLEAN         fgEndThisRound;
    P_QUE_MGT_T     prQM = &prAdapter->rQM;

    PUINT_8         pucPsStaFreeQuota;

    /*              */
	if (!u4CurrentQuota) {
        DBGLOG(TX, LOUD, ("(Fairness) Skip TC = %u u4CurrentQuota = %u\n",
				  ucTC, u4CurrentQuota));
        return u4CurrentQuota;
    }    
	/*                         */
    u4AvaliableResource = u4CurrentQuota;
    u4MaxResourceLimit = u4TotalQuota;

#if QM_FORWARDING_FAIRNESS
    u4CurStaIndex = prQM->au4HeadStaRecIndex[ucTC];
    u4CurStaUsedResource = prQM->au4ResourceUsedCount[ucTC];
#endif

    fgEndThisRound = FALSE;
    ucLoop = 0;
	u4CurStaForwardFrameCount = 0;

    DBGLOG(QM, LOUD, ("(Fairness) TC[%u] Init Head STA[%u] Resource[%u]\n",
			  ucTC, u4CurStaIndex, u4AvaliableResource));

	/*                                        */
    /*                                                      */
	while (ucLoop < CFG_NUM_OF_STA_RECORD) {
        prStaRec = &prAdapter->arStaRec[u4CurStaIndex];

		/*                               */
        /*                                                         */
		if (prStaRec->fgIsTxAllowed) {
            prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prStaRec->ucBssIndex);

            prCurrQueue = &prStaRec->arTxQueue[ucTC];
            prDequeuedPkt = NULL;
            pucPsStaFreeQuota = NULL;
            /*                                              */
            u4MaxForwardFrameCountLimit = QM_STA_FORWARD_COUNT_UNLIMITED;            

			/*                                                            */
            /*                                    */
			if (prStaRec->fgIsInPS) {
				if (prStaRec->fgIsQoS &&
                   prStaRec->fgIsUapsdSupported && 
                   (prStaRec->ucBmpTriggerAC & BIT(ucTC))) {
					u4MaxForwardFrameCountLimit =
					    prStaRec->ucFreeQuotaForDelivery;
                    pucPsStaFreeQuota = &prStaRec->ucFreeQuotaForDelivery;
				} else {
					/*                                                */
					u4MaxForwardFrameCountLimit =
					    prStaRec->ucFreeQuotaForNonDelivery;
                    pucPsStaFreeQuota = &prStaRec->ucFreeQuotaForNonDelivery;
                }

			}

			/*          */
            /*                     */
			if (prBssInfo->fgIsNetAbsent) {
				if (u4MaxForwardFrameCountLimit > prBssInfo->ucBssFreeQuota) {
                    u4MaxForwardFrameCountLimit = prBssInfo->ucBssFreeQuota;
                }
            }
			/*                        */
            /*                                                                   */
			while (!QUEUE_IS_EMPTY(prCurrQueue)) {
				prDequeuedPkt = (P_MSDU_INFO_T) QUEUE_GET_HEAD(prCurrQueue);

				if ((u4CurStaForwardFrameCount >= u4MaxForwardFrameCountLimit) ||
                        (u4CurStaUsedResource >= u4MaxResourceLimit)) {
                    /*               */
                    
                    break;
				} else if (prDequeuedPkt->ucPageCount > u4AvaliableResource) {
                    /*                                  */
					if (!(prAdapter->rWifiVar.ucAlwaysResetUsedRes & BIT(0))) {
                        fgEndThisRound = TRUE;
                    }
                    break;
				} else {
                    /*                    */
                    
					QUEUE_REMOVE_HEAD(prCurrQueue, prDequeuedPkt,
							  P_MSDU_INFO_T);
                    
					if (!QUEUE_IS_EMPTY(prCurrQueue)) {
                        /*                               */
						prDequeuedPkt->ucPsForwardingType =
						    PS_FORWARDING_MORE_DATA_ENABLED;
                    }         
                    
					QUEUE_INSERT_TAIL(prQue, (P_QUE_ENTRY_T) prDequeuedPkt);
                    
                    u4AvaliableResource -= prDequeuedPkt->ucPageCount;
                    u4CurStaUsedResource += prDequeuedPkt->ucPageCount;   
                    u4CurStaForwardFrameCount++;
                }

            }

            /*                                      */
			if (prStaRec->fgIsInPS && pucPsStaFreeQuota) {
				if ((*pucPsStaFreeQuota) >= u4CurStaForwardFrameCount) {
                (*pucPsStaFreeQuota) -= u4CurStaForwardFrameCount;
				} else {
                    (*pucPsStaFreeQuota) = 0;
                }
            }

			if (prBssInfo->fgIsNetAbsent) {
				if (prBssInfo->ucBssFreeQuota >= u4CurStaForwardFrameCount) {
                prBssInfo->ucBssFreeQuota -= u4CurStaForwardFrameCount;
				} else {
					prBssInfo->ucBssFreeQuota = 0;
                }
                }
        }

		if (fgEndThisRound) {
            /*                */
            break;
        }
        
        /*                      */
        ucLoop++;
        u4CurStaIndex++;
        u4CurStaIndex %= CFG_NUM_OF_STA_RECORD;
		u4CurStaUsedResource = 0;
		u4CurStaForwardFrameCount = 0;
    }

    
	/*                                        */
    /*                                                         */
	if ((prQM->u4TxAllowedStaCount == 1) || (prAdapter->rWifiVar.ucAlwaysResetUsedRes & BIT(1))) {
        u4CurStaUsedResource = 0;
    }
#if QM_FORWARDING_FAIRNESS    
    prQM->au4HeadStaRecIndex[ucTC] = u4CurStaIndex;
    prQM->au4ResourceUsedCount[ucTC] = u4CurStaUsedResource;   
#endif

    DBGLOG(QM, LOUD, ("(Fairness) TC[%u] Scheduled Head STA[%u] Left Resource[%u]\n",
			  ucTC, u4CurStaIndex, u4AvaliableResource));

    return u4AvaliableResource;
}

/*                                                                            */
/* 
                                                                           
 
                                                         
                                                          
                                                               
 
                
*/
/*                                                                            */
VOID
qmDequeueTxPacketsFromPerTypeQueues(IN P_ADAPTER_T prAdapter,
    OUT P_QUE_T         prQue,
    IN  UINT_8          ucTC,
				    IN UINT_32 u4CurrentQuota, IN UINT_32 u4TotalQuota)
{
    UINT_32         u4AvaliableResource, u4LeftResource;
    UINT_32         u4MaxResourceLimit;
    UINT_32         u4TotalUsedResource = 0;
    P_QUE_MGT_T     prQM;
    PFN_DEQUEUE_FUNCTION pfnDeQFunc[2];
    BOOLEAN         fgChangeDeQFunc = TRUE;
    BOOLEAN         fgGlobalQueFirst = TRUE;

	DBGLOG(QM, LOUD, ("Enter %s (TC = %d, quota = %u)\n", __func__, ucTC, u4CurrentQuota));

    /*                                       */
	if ((u4CurrentQuota == 0) || (ucTC != TC5_INDEX)) {
        return;
    }

    prQM = &prAdapter->rQM;

    u4AvaliableResource = u4CurrentQuota;
    u4MaxResourceLimit = u4TotalQuota;
#if QM_FORWARDING_FAIRNESS    
    u4TotalUsedResource = prQM->u4GlobalResourceUsedCount;
    fgGlobalQueFirst = prQM->fgGlobalQFirst;
#endif    

    /*                            */
	if (fgGlobalQueFirst) {
        pfnDeQFunc[0] = qmDequeueTxPacketsFromGlobalQueue;
        pfnDeQFunc[1] = qmDequeueTxPacketsFromPerStaQueues;
    } else {
        pfnDeQFunc[0] = qmDequeueTxPacketsFromPerStaQueues;
        pfnDeQFunc[1] = qmDequeueTxPacketsFromGlobalQueue;
    }

    /*                      */
	u4LeftResource = pfnDeQFunc[0] (prAdapter,
                        prQue,
                        ucTC,
                        u4AvaliableResource,
                        (u4MaxResourceLimit - u4TotalUsedResource));

    /*                                               */
	if ((u4LeftResource >= u4AvaliableResource) &&
        (u4AvaliableResource >= NIC_TX_MAX_PAGE_PER_FRAME)) {
        
        fgChangeDeQFunc = TRUE;
    } else {
        u4TotalUsedResource += (u4AvaliableResource - u4LeftResource);
        /*                                     */
		if (u4TotalUsedResource >= u4MaxResourceLimit) {
            fgChangeDeQFunc = TRUE;
        }            
    }

	if (fgChangeDeQFunc) {
        fgGlobalQueFirst = !fgGlobalQueFirst;
        u4TotalUsedResource = 0;
    }

    /*                      */
	u4LeftResource = pfnDeQFunc[1] (prAdapter, prQue, ucTC, u4LeftResource, u4MaxResourceLimit);

#if QM_FORWARDING_FAIRNESS
    prQM->fgGlobalQFirst = fgGlobalQueFirst;
    prQM->u4GlobalResourceUsedCount = u4TotalUsedResource;
#endif    

} /*                                     */

/*                                                                            */
/* 
                                                                      
 
                                                         
                                                          
                                                               
 
                
*/
/*                                                                            */
UINT_32
qmDequeueTxPacketsFromGlobalQueue(IN P_ADAPTER_T prAdapter,
    OUT P_QUE_T         prQue,
    IN  UINT_8          ucTC,
				  IN UINT_32 u4CurrentQuota, IN UINT_32 u4TotalQuota)
{
    P_BSS_INFO_T    prBssInfo;
    P_QUE_T         prCurrQueue;
    UINT_32         u4AvaliableResource;
    P_MSDU_INFO_T   prDequeuedPkt;
    P_MSDU_INFO_T   prBurstEndPkt;
    QUE_T           rMergeQue;
    P_QUE_T         prMergeQue;
    P_QUE_MGT_T     prQM;

	DBGLOG(QM, LOUD, ("Enter %s (TC = %d, quota = %u)\n", __func__, ucTC, u4CurrentQuota));

    /*                                       */
	if (u4CurrentQuota == 0) {
        return u4CurrentQuota;
    }

    prQM = &prAdapter->rQM;
    
	/*                           */
    prCurrQueue = &prQM->arTxQueue[TX_QUEUE_INDEX_BMCAST];
    u4AvaliableResource = u4CurrentQuota;
    prDequeuedPkt = NULL;
    prBurstEndPkt = NULL;

    QUEUE_INITIALIZE(&rMergeQue);
    prMergeQue = &rMergeQue;

	/*                       */
	while (!QUEUE_IS_EMPTY(prCurrQueue)) {
		prDequeuedPkt = (P_MSDU_INFO_T) QUEUE_GET_HEAD(prCurrQueue);
		if (prDequeuedPkt->ucPageCount > u4AvaliableResource) {
            break;
		} else {
            QUEUE_REMOVE_HEAD(prCurrQueue, prDequeuedPkt, P_MSDU_INFO_T);
            ASSERT(prDequeuedPkt->ucTC == ucTC);
            ASSERT(prDequeuedPkt->ucBssIndex <= MAX_BSS_INDEX);

            prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prDequeuedPkt->ucBssIndex);

			if (IS_BSS_ACTIVE(prBssInfo)) {
				if (!prBssInfo->fgIsNetAbsent) {
					QUEUE_INSERT_TAIL(prQue, (P_QUE_ENTRY_T) prDequeuedPkt);
                    prBurstEndPkt = prDequeuedPkt;
                    u4AvaliableResource -= prDequeuedPkt->ucPageCount;
                    QM_DBG_CNT_INC(prQM, QM_DBG_CNT_26);
				} else {
					QUEUE_INSERT_TAIL(prMergeQue,
							  (P_QUE_ENTRY_T) prDequeuedPkt);
                }
			} else {
                QM_TX_SET_NEXT_MSDU_INFO(prDequeuedPkt, NULL);
				wlanProcessQueuedMsduInfo(prAdapter, prDequeuedPkt);
            }
        }
    }

	if (QUEUE_IS_NOT_EMPTY(prMergeQue)) {
        QUEUE_CONCATENATE_QUEUES(prMergeQue, prCurrQueue);
        QUEUE_MOVE_ALL(prCurrQueue, prMergeQue);
		QM_TX_SET_NEXT_MSDU_INFO((P_MSDU_INFO_T) QUEUE_GET_TAIL(prCurrQueue), NULL);
    }

    return u4AvaliableResource;
}

/*                                                                            */
/* 
                                             
 
                                                                          
 
                                         
*/
/*                                                                            */
P_MSDU_INFO_T qmDequeueTxPackets(IN P_ADAPTER_T prAdapter, IN P_TX_TCQ_STATUS_T prTcqStatus)
{
    INT_32 i;
    P_MSDU_INFO_T prReturnedPacketListHead;
    QUE_T rReturnedQue;
    UINT_32 u4MaxQuotaLimit;

    DBGLOG(QM, LOUD, ("Enter qmDequeueTxPackets\n"));

    QUEUE_INITIALIZE(&rReturnedQue);

    prReturnedPacketListHead = NULL;

    /*                                                              */
	for (i = TC3_INDEX; i >= TC0_INDEX; i--) {
        DBGLOG(QM, LOUD, ("Dequeue packets from Per-STA queue[%u]\n", i));

        /*                                                              */
		if (prAdapter->rWifiVar.u4MaxTxDeQLimit) {
            u4MaxQuotaLimit = prAdapter->rWifiVar.u4MaxTxDeQLimit;
		} else if (prAdapter->rQM.u4TxAllowedStaCount == 1) {
            u4MaxQuotaLimit = QM_STA_FORWARD_COUNT_UNLIMITED;
		} else {
			u4MaxQuotaLimit = (UINT_32) prTcqStatus->au2MaxNumOfPage[i];
        }

		qmDequeueTxPacketsFromPerStaQueues(prAdapter,
            &rReturnedQue,
						   (UINT_8) i,
						   (UINT_32) prTcqStatus->au2FreePageCount[i],
            u4MaxQuotaLimit);

        /*                                          */
        DBGLOG(QM, LOUD, ("DQA)[%u](%lu)\n", i, rReturnedQue.u4NumElem));
    }

    /*                                 */
	qmDequeueTxPacketsFromPerTypeQueues(prAdapter,
        &rReturnedQue,
        TC5_INDEX,
        prTcqStatus->au2FreePageCount[TC5_INDEX],
        prTcqStatus->au2MaxNumOfPage[TC5_INDEX]);

	DBGLOG(QM, LOUD,
	       ("Current total number of dequeued packets = %u\n", rReturnedQue.u4NumElem));

	if (QUEUE_IS_NOT_EMPTY(&rReturnedQue)) {
		prReturnedPacketListHead = (P_MSDU_INFO_T) QUEUE_GET_HEAD(&rReturnedQue);
		QM_TX_SET_NEXT_MSDU_INFO((P_MSDU_INFO_T) QUEUE_GET_TAIL(&rReturnedQue), NULL);
    }

    return prReturnedPacketListHead;
}

#if CFG_SUPPORT_MULTITHREAD
/*                                                                            */
/* 
                                             
 
                                                                          
 
                                         
*/
/*                                                                            */
P_MSDU_INFO_T qmDequeueTxPacketsMthread(IN P_ADAPTER_T prAdapter, IN P_TX_TCQ_STATUS_T prTcqStatus)
{

	/*           */
    P_MSDU_INFO_T prReturnedPacketListHead;
	/*                     */
	/*                          */
    P_MSDU_INFO_T prMsduInfo, prNextMsduInfo;

    KAL_SPIN_LOCK_DECLARATION();

    KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_RESOURCE);

    prReturnedPacketListHead = qmDequeueTxPackets(prAdapter, prTcqStatus);

	/*                                                   */
    prMsduInfo = prReturnedPacketListHead;
	while (prMsduInfo) {
		prNextMsduInfo = (P_MSDU_INFO_T) QUEUE_GET_NEXT_ENTRY((P_QUE_ENTRY_T) prMsduInfo);
		prTcqStatus->au2FreePageCount[prMsduInfo->ucTC] -=
		    nicTxGetPageCount(prMsduInfo->u2FrameLength, FALSE);
		prTcqStatus->au2FreeBufferCount[prMsduInfo->ucTC] =
		    (prTcqStatus->au2FreePageCount[prMsduInfo->ucTC] / NIC_TX_MAX_PAGE_PER_FRAME);
        prMsduInfo = prNextMsduInfo;
    }

    KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_RESOURCE);

    return prReturnedPacketListHead;
}

/*                                                                            */
/* 
                                                          
 
                                                  
                                                                      
 
                
*/
/*                                                                            */
BOOLEAN
qmAdjustTcQuotasMthread(IN P_ADAPTER_T prAdapter,
			OUT P_TX_TCQ_ADJUST_T prTcqAdjust, IN P_TX_TCQ_STATUS_T prTcqStatus)
{
#if QM_ADAPTIVE_TC_RESOURCE_CTRL
    UINT_32 i;
    P_QUE_MGT_T prQM = &prAdapter->rQM;

    KAL_SPIN_LOCK_DECLARATION();
    
    /*                 */
	for (i = 0; i < QM_ACTIVE_TC_NUM; i++) {
		prTcqAdjust->acVariation[i] = 0;
    }

	/*                                                          */
	if (!prQM->fgTcResourcePostAnnealing) {
        return FALSE;
    }
	/*                                                                            */
	else {
        INT_32 i4TotalExtraQuota = 0;
        INT_32 ai4ExtraQuota[QM_ACTIVE_TC_NUM];
        BOOLEAN fgResourceRedistributed = TRUE;

        /*                 */
		for (i = 0; i < TC_NUM; i++) {
			prTcqAdjust->acVariation[i] = 0;
        }
        
        KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_RESOURCE);
        KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_TC_RESOURCE);
        
        /*                                        */
		for (i = 0; i < QM_ACTIVE_TC_NUM; i++) {
			ai4ExtraQuota[i] =
			    (INT_32) prTcqStatus->au2MaxNumOfBuffer[i] -
			    (INT_32) prQM->au4CurrentTcResource[i];

			if (ai4ExtraQuota[i] > 0) {	/*                                                */
				if (ai4ExtraQuota[i] > prTcqStatus->au2FreeBufferCount[i]) {
                    ai4ExtraQuota[i] = prTcqStatus->au2FreeBufferCount[i];
                    fgResourceRedistributed = FALSE;
                }

                i4TotalExtraQuota += ai4ExtraQuota[i];
				prTcqAdjust->acVariation[i] = (INT_8) (-ai4ExtraQuota[i]);
            }
        }

        KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_TC_RESOURCE);
        
        /*                                                                                            */
		for (i = 0; i < QM_ACTIVE_TC_NUM; i++) {
			if (ai4ExtraQuota[i] < 0) {
				if ((-ai4ExtraQuota[i]) > i4TotalExtraQuota) {
                    ai4ExtraQuota[i] = (-i4TotalExtraQuota);
                    fgResourceRedistributed = FALSE;
                }

                i4TotalExtraQuota += ai4ExtraQuota[i];
				prTcqAdjust->acVariation[i] = (INT_8) (-ai4ExtraQuota[i]);
            }
        }

        /*                                                                                   */
        prQM->fgTcResourcePostAnnealing = (!fgResourceRedistributed);

		for (i = 0; i < TC_NUM; i++) {
			prTcqStatus->au2FreePageCount[i] +=
			    (prTcqAdjust->acVariation[i] * NIC_TX_MAX_PAGE_PER_FRAME);
			prTcqStatus->au2MaxNumOfPage[i] +=
			    (prTcqAdjust->acVariation[i] * NIC_TX_MAX_PAGE_PER_FRAME);

            prTcqStatus->au2FreeBufferCount[i] += prTcqAdjust->acVariation[i];
            prTcqStatus->au2MaxNumOfBuffer[i] += prTcqAdjust->acVariation[i];

            ASSERT(prTcqStatus->au2FreeBufferCount[i] >= 0);
            ASSERT(prTcqStatus->au2MaxNumOfBuffer[i] >= 0);
        }
        
#if QM_FAST_TC_RESOURCE_CTRL
        prQM->fgTcResourceFastReaction = FALSE;
#endif
        KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_RESOURCE);
    }

    return TRUE;
#else
    return FALSE;
#endif
}
#endif


/*                                                                            */
/* 
                                                          
 
                                                  
                                                                      
 
                
*/
/*                                                                            */
BOOLEAN
qmAdjustTcQuotas(IN P_ADAPTER_T prAdapter,
		 OUT P_TX_TCQ_ADJUST_T prTcqAdjust, IN P_TX_TCQ_STATUS_T prTcqStatus)
{
#if QM_ADAPTIVE_TC_RESOURCE_CTRL
    UINT_32 i;
    P_QUE_MGT_T prQM = &prAdapter->rQM;

    /*                 */
	for (i = 0; i < QM_ACTIVE_TC_NUM; i++) {
		prTcqAdjust->acVariation[i] = 0;
    }

	/*                                                          */
	if (!prQM->fgTcResourcePostAnnealing) {
        return FALSE;
    }
	/*                                                                            */
	else {
        INT_32 i4TotalExtraQuota = 0;
        INT_32 ai4ExtraQuota[QM_ACTIVE_TC_NUM];
        BOOLEAN fgResourceRedistributed = TRUE;

        /*                                        */
		for (i = 0; i < QM_ACTIVE_TC_NUM; i++) {
			ai4ExtraQuota[i] =
			    (INT_32) prTcqStatus->au2MaxNumOfBuffer[i] -
			    (INT_32) prQM->au4CurrentTcResource[i];

			if (ai4ExtraQuota[i] > 0) {	/*                                                */
				if (ai4ExtraQuota[i] > prTcqStatus->au2FreeBufferCount[i]) {
                    ai4ExtraQuota[i] = prTcqStatus->au2FreeBufferCount[i];
                    fgResourceRedistributed = FALSE;
                }

                i4TotalExtraQuota += ai4ExtraQuota[i];
				prTcqAdjust->acVariation[i] = (INT_8) (-ai4ExtraQuota[i]);
            }
        }

        /*                                                                                            */
		for (i = 0; i < QM_ACTIVE_TC_NUM; i++) {
			if (ai4ExtraQuota[i] < 0) {
				if ((-ai4ExtraQuota[i]) > i4TotalExtraQuota) {
                    ai4ExtraQuota[i] = (-i4TotalExtraQuota);
                    fgResourceRedistributed = FALSE;
                }

                i4TotalExtraQuota += ai4ExtraQuota[i];
				prTcqAdjust->acVariation[i] = (INT_8) (-ai4ExtraQuota[i]);
            }
        }

        /*                                                                                   */
        prQM->fgTcResourcePostAnnealing = (!fgResourceRedistributed);
        
#if QM_FAST_TC_RESOURCE_CTRL
        prQM->fgTcResourceFastReaction = FALSE;
#endif

#if QM_PRINT_TC_RESOURCE_CTRL
        DBGLOG(QM, LOUD, ("QM: Curr Quota [0]=%u [1]=%u [2]=%u [3]=%u [4]=%u [5]=%u\n",
            prTcqStatus->au2FreeBufferCount[0],
            prTcqStatus->au2FreeBufferCount[1],
            prTcqStatus->au2FreeBufferCount[2],
            prTcqStatus->au2FreeBufferCount[3],
            prTcqStatus->au2FreeBufferCount[4],
            prTcqStatus->au2FreeBufferCount[5]));
#endif
    }

    return TRUE;
#else
    return FALSE;
#endif
}

#if QM_ADAPTIVE_TC_RESOURCE_CTRL
/*                                                                            */
/* 
                                                                                 
 
               
 
                
*/
/*                                                                            */
VOID qmUpdateAverageTxQueLen(IN P_ADAPTER_T prAdapter)
{
    INT_32 u4CurrQueLen, u4Tc, u4StaRecIdx;
    P_STA_RECORD_T prStaRec;
    P_QUE_MGT_T prQM = &prAdapter->rQM;
    P_BSS_INFO_T prBssInfo;

	/*                                                                  */
	for (u4Tc = 0; u4Tc < QM_ACTIVE_TC_NUM; u4Tc++) {
        u4CurrQueLen = 0;

        /*                                */
		for (u4StaRecIdx = 0; u4StaRecIdx < CFG_NUM_OF_STA_RECORD; u4StaRecIdx++) {
            prStaRec = cnmGetStaRecByIndex(prAdapter, u4StaRecIdx);
			if (prStaRec) {
                prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prStaRec->ucBssIndex);

                /*                                               */
				if ((prStaRec->fgIsValid) && (!prBssInfo->fgIsNetAbsent)) {
                    u4CurrQueLen += (prStaRec->arTxQueue[u4Tc].u4NumElem);
                }
            }
        }
        
		if (u4Tc == TC5_INDEX) {
            /*                                          */
            u4CurrQueLen += prQM->arTxQueue[TX_QUEUE_INDEX_BMCAST].u4NumElem;        
        }

        if (prQM->au4AverageQueLen[u4Tc] == 0){
            prQM->au4AverageQueLen[u4Tc] = (u4CurrQueLen << prQM->u4QueLenMovingAverage);
        }
        else{
            prQM->au4AverageQueLen[u4Tc] -= (prQM->au4AverageQueLen[u4Tc] >> prQM->u4QueLenMovingAverage);
            prQM->au4AverageQueLen[u4Tc] += (u4CurrQueLen);
        }
    }
#if 0
    /*                                          */
    u4CurrQueLen = prQM->arTxQueue[TX_QUEUE_INDEX_BMCAST].u4NumElem;

	if (prQM->au4AverageQueLen[TC5_INDEX] == 0) {
        prQM->au4AverageQueLen[TC5_INDEX] = (u4CurrQueLen << QM_QUE_LEN_MOVING_AVE_FACTOR);
	} else {
		prQM->au4AverageQueLen[TC5_INDEX] -=
		    (prQM->au4AverageQueLen[TC5_INDEX] >> QM_QUE_LEN_MOVING_AVE_FACTOR);
        prQM->au4AverageQueLen[TC5_INDEX] += (u4CurrQueLen);
    }
#endif
}

#if 1
VOID
qmAllocateResidualTcResource(
    IN P_ADAPTER_T   prAdapter,
    IN PINT_32   ai4TcResDemand,
    IN PUINT_32 pu4ResidualResource,
    IN PUINT_32 pu4ShareCount
    )
{
    P_QUE_MGT_T prQM = &prAdapter->rQM;
    UINT_32 u4Share = 0 ;
    UINT_32 u4TcIdx;
    UINT_8 ucIdx;
    UINT_32 au4AdjTc[] = {TC3_INDEX, TC2_INDEX, TC5_INDEX, TC1_INDEX, TC0_INDEX};
    UINT_32 u4AdjTcSize = (sizeof(au4AdjTc) / sizeof(UINT_32));    
    UINT_32 u4ResidualResource = *pu4ResidualResource;
    UINT_32 u4ShareCount = *pu4ShareCount;
            
    /*                                             */
    if (u4ResidualResource == 0){
        return;
    }

    /*                       */
    if (u4ShareCount == 0){
        prQM->au4CurrentTcResource[TC1_INDEX] += u4ResidualResource;
        DBGLOG(QM, ERROR, ("QM: (Error) u4ShareCount = 0\n"));
        return;
    }

    /*                                    */
    u4Share = (u4ResidualResource / u4ShareCount);
    if(u4Share){
        for (u4TcIdx = 0; u4TcIdx < QM_ACTIVE_TC_NUM; u4TcIdx++){
            /*                           */
            if (u4TcIdx == TC4_INDEX) {
                continue;
            }

            if (ai4TcResDemand[u4TcIdx] > 0){
                if (ai4TcResDemand[u4TcIdx] > u4Share){
                    prQM->au4CurrentTcResource[u4TcIdx] += u4Share;
                    u4ResidualResource -= u4Share;
                    ai4TcResDemand[u4TcIdx] -= u4Share;
                }
                else{
                    prQM->au4CurrentTcResource[u4TcIdx] += ai4TcResDemand[u4TcIdx];
                    u4ResidualResource -= ai4TcResDemand[u4TcIdx];
                    ai4TcResDemand[u4TcIdx] = 0;
                }
            }
        }
    }

    /*                                                                          */
    ucIdx = 0;
    while(u4ResidualResource) {
        u4TcIdx = au4AdjTc[ucIdx];
        
        if (ai4TcResDemand[u4TcIdx]){
            prQM->au4CurrentTcResource[u4TcIdx]++;
            u4ResidualResource--;
            ai4TcResDemand[u4TcIdx]--;

            if(ai4TcResDemand[u4TcIdx] == 0) {
                u4ShareCount--;
            }
        }

        if(u4ShareCount <= 0) {
            break;
        }
        
        ucIdx++;
        ucIdx %= u4AdjTcSize;
    }
    
    /*                            */
    prQM->au4CurrentTcResource[TC3_INDEX] += u4ResidualResource;

    *pu4ResidualResource = u4ResidualResource;
    *pu4ShareCount = u4ShareCount;

}


/*                                                                            */
/* 
                                                                                           
 
               
 
                
*/
/*                                                                            */
VOID qmReassignTcResource(IN P_ADAPTER_T prAdapter)
{
    INT_32 i4TotalResourceDemand = 0;
    UINT_32 u4ResidualResource = 0;
    UINT_32 u4TcIdx;
    INT_32 ai4TcResDemand[QM_ACTIVE_TC_NUM];
    UINT_32 u4ShareCount = 0;
	UINT_32 u4Share = 0;
    P_QUE_MGT_T prQM = &prAdapter->rQM;

    /*                                                                                           
                                                                                        
     */

	/*                             */
    /*                                                                      */
	for (u4TcIdx = 0; u4TcIdx < QM_ACTIVE_TC_NUM; u4TcIdx++) {
        /*                                   */
        if (u4TcIdx == TC4_INDEX) {
            continue;
        }

        /*                                                                        */
        ai4TcResDemand[u4TcIdx] = (QM_GET_TX_QUEUE_LEN(prAdapter, u4TcIdx) + 
		    prQM->au4MinReservedTcResource[u4TcIdx] - prQM->au4CurrentTcResource[u4TcIdx]);

        /*                                                                                         */
		if (QM_GET_TX_QUEUE_LEN(prAdapter, u4TcIdx)) {
            ai4TcResDemand[u4TcIdx] += prQM->u4ExtraReservedTcResource;
        }

        i4TotalResourceDemand += ai4TcResDemand[u4TcIdx];
    }

    //                                      
    if(i4TotalResourceDemand <= 0) {

		/*                                                */
        u4ShareCount = (QM_ACTIVE_TC_NUM - 1); /*               */
		u4ResidualResource = (UINT_32) (-i4TotalResourceDemand);
        u4Share = (u4ResidualResource / u4ShareCount);

		/*                                                                 */
		for (u4TcIdx = 0; u4TcIdx < QM_ACTIVE_TC_NUM; u4TcIdx++) {
            /*                           */
            if (u4TcIdx == TC4_INDEX) {
                continue;
            }

            prQM->au4CurrentTcResource[u4TcIdx] += (ai4TcResDemand[u4TcIdx] + u4Share);

            /*                             */
            ai4TcResDemand[u4TcIdx] = 0;

            /*                                            */
            u4ResidualResource -= u4Share;
        }

		/*                                                */
        prQM->au4CurrentTcResource[TC3_INDEX] += (u4ResidualResource);

    }
	/*                                                                                              */
	else {

        u4ResidualResource = prQM->u4ResidualTcResource;

		/*                                                                           */
		for (u4TcIdx = 0; u4TcIdx < QM_ACTIVE_TC_NUM; u4TcIdx++) {
            /*                           */
            if (u4TcIdx == TC4_INDEX) {
                continue;
            }

            /*                                                                 */
            if ((prQM->au4CurrentTcResource[u4TcIdx] + ai4TcResDemand[u4TcIdx]) <= 
                    prQM->au4GuaranteedTcResource[u4TcIdx]){
                    
                prQM->au4CurrentTcResource[u4TcIdx] += ai4TcResDemand[u4TcIdx];
                u4ResidualResource += 
                    (prQM->au4GuaranteedTcResource[u4TcIdx] - prQM->au4CurrentTcResource[u4TcIdx]);
                ai4TcResDemand[u4TcIdx] = 0;
            }

            /*                                                                     */
            else{
                ai4TcResDemand[u4TcIdx] -= 
                    (prQM->au4GuaranteedTcResource[u4TcIdx] - prQM->au4CurrentTcResource[u4TcIdx]);

                prQM->au4CurrentTcResource[u4TcIdx] = prQM->au4GuaranteedTcResource[u4TcIdx];
                u4ShareCount++;
            }
        }

        //                                      
        qmAllocateResidualTcResource(prAdapter, ai4TcResDemand, &u4ResidualResource, &u4ShareCount);
    }

    prQM->fgTcResourcePostAnnealing = TRUE;

#if QM_PRINT_TC_RESOURCE_CTRL
    /*             */
    DBGLOG(QM, INFO, ("QM: TC Rsc adjust to [%03u:%03u:%03u:%03u:%03u:%03u]\n",
        prQM->au4CurrentTcResource[0], prQM->au4CurrentTcResource[1],
        prQM->au4CurrentTcResource[2], prQM->au4CurrentTcResource[3],
   	  prQM->au4CurrentTcResource[4], prQM->au4CurrentTcResource[5]));
#endif

}
#else
VOID
qmReassignTcResource(
    IN P_ADAPTER_T   prAdapter
    )
{
    INT_32 i4TotalResourceDemand = 0;
    UINT_32 u4ResidualResource = 0;
    UINT_32 u4TcIdx;
    INT_32 ai4PerTcResourceDemand[QM_ACTIVE_TC_NUM];
    UINT_32 u4ShareCount = 0;
    UINT_32 u4Share = 0 ;
    P_QUE_MGT_T prQM = &prAdapter->rQM;

    /*                                                                                           
                                                                                        
     */

    //                           
    /*                                                                      */
    for (u4TcIdx = 0; u4TcIdx < QM_ACTIVE_TC_NUM; u4TcIdx++){
        /*                                   */
        if (u4TcIdx == TC4_INDEX) {
            continue;
        }

        /*                                                                        */
        ai4PerTcResourceDemand[u4TcIdx] = (QM_GET_TX_QUEUE_LEN(prAdapter, u4TcIdx) + 
            prQM->au4MinReservedTcResource[u4TcIdx] - prQM->au4CurrentTcResource[u4TcIdx]);

        /*                                                                                         */
        if (QM_GET_TX_QUEUE_LEN(prAdapter, u4TcIdx)){
            ai4PerTcResourceDemand[u4TcIdx] += QM_EXTRA_RESERVED_RESOURCE_WHEN_BUSY;
        }

        i4TotalResourceDemand += ai4PerTcResourceDemand[u4TcIdx];
    }

    //                                      
    if(i4TotalResourceDemand <= 0) {
#if 0
        //                        
        for (u4TcIdx = 0; u4TcIdx < QM_ACTIVE_TC_NUM; u4TcIdx++){
            /*                           */
            if (u4TcIdx == TC4_INDEX) {
                continue;
            }

            prQM->au4CurrentTcResource[u4TcIdx] += ai4PerTcResourceDemand[u4TcIdx];
        }

        //                                          
        u4ShareCount = (QM_ACTIVE_TC_NUM - 1); /*               */
        u4ResidualResource = (UINT_32)(-i4TotalResourceDemand);
        u4Share = (u4ResidualResource / u4ShareCount);

        for (u4TcIdx = 0; u4TcIdx < QM_ACTIVE_TC_NUM; u4TcIdx++){
            /*                           */
            if (u4TcIdx == TC4_INDEX) {
                continue;
            }

            prQM->au4CurrentTcResource[u4TcIdx] += u4Share;

            /*                             */
            ai4PerTcResourceDemand[u4TcIdx] = 0;

            /*                                            */
            u4ResidualResource -= u4Share;
        }
#else
        /*              */
        //                                              
        u4ShareCount = (QM_ACTIVE_TC_NUM - 1); /*               */
        u4ResidualResource = (UINT_32)(-i4TotalResourceDemand);
        u4Share = (u4ResidualResource / u4ShareCount);

        //                                                               
        for (u4TcIdx = 0; u4TcIdx < QM_ACTIVE_TC_NUM; u4TcIdx++){
            /*                           */
            if (u4TcIdx == TC4_INDEX) {
                continue;
            }

            prQM->au4CurrentTcResource[u4TcIdx] += (ai4PerTcResourceDemand[u4TcIdx] + u4Share);

            /*                             */
            ai4PerTcResourceDemand[u4TcIdx] = 0;

            /*                                            */
            u4ResidualResource -= u4Share;
        }
#endif

        //                                              
        prQM->au4CurrentTcResource[TC3_INDEX] += (u4ResidualResource);

    }

    //                                                                                            
    else{
        u4ResidualResource = prQM->u4ResidualTcResource;

        //                                                                         
        for (u4TcIdx = 0; u4TcIdx < QM_ACTIVE_TC_NUM; u4TcIdx++){
            /*                           */
            if (u4TcIdx == TC4_INDEX) {
                continue;
            }

            /*                                                                 */
            if((prQM->au4CurrentTcResource[u4TcIdx] + ai4PerTcResourceDemand[u4TcIdx]) < prQM->au4GuaranteedTcResource[u4TcIdx]){
                prQM->au4CurrentTcResource[u4TcIdx] += ai4PerTcResourceDemand[u4TcIdx];
                u4ResidualResource += (prQM->au4GuaranteedTcResource[u4TcIdx] - prQM->au4CurrentTcResource[u4TcIdx]);
                ai4PerTcResourceDemand[u4TcIdx] = 0;
            }

            /*                                                                     */
            else{
                ai4PerTcResourceDemand[u4TcIdx] -= (prQM->au4GuaranteedTcResource[u4TcIdx] - prQM->au4CurrentTcResource[u4TcIdx]);
                prQM->au4CurrentTcResource[u4TcIdx] = prQM->au4GuaranteedTcResource[u4TcIdx];
                u4ShareCount++;
            }
        }

        //                                      
        do{
            /*                                             */
            if (u4ResidualResource == 0){
                break;
            }

            /*                       */
            if (u4ShareCount == 0){
                prQM->au4CurrentTcResource[TC1_INDEX] += u4ResidualResource;
                DBGLOG(QM, ERROR, ("QM: (Error) u4ShareCount = 0\n"));
                break;
            }

            /*                                    */
            u4Share = (u4ResidualResource / u4ShareCount);
            if(u4Share){
                for (u4TcIdx = 0; u4TcIdx < QM_ACTIVE_TC_NUM; u4TcIdx++){
                    /*                           */
                    if (u4TcIdx == TC4_INDEX) {
                        continue;
                    }

                    if (ai4PerTcResourceDemand[u4TcIdx]){
                        if (ai4PerTcResourceDemand[u4TcIdx] - u4Share){
                            prQM->au4CurrentTcResource[u4TcIdx] += u4Share;
                            u4ResidualResource -= u4Share;
                            ai4PerTcResourceDemand[u4TcIdx] -= u4Share;
                        }
                        else{
                            prQM->au4CurrentTcResource[u4TcIdx] += ai4PerTcResourceDemand[u4TcIdx];
                            u4ResidualResource -= ai4PerTcResourceDemand[u4TcIdx];
                            ai4PerTcResourceDemand[u4TcIdx] = 0;
                        }
                    }
                }
            }

            /*                                                                          */
            if (u4ResidualResource == 0){
                break;
            }

            if (ai4PerTcResourceDemand[TC3_INDEX]){      /*    */
                prQM->au4CurrentTcResource[TC3_INDEX]++;
                if (--u4ResidualResource == 0) {
                    break;
                }
            }

            if (ai4PerTcResourceDemand[TC2_INDEX]){      /*    */
                prQM->au4CurrentTcResource[TC2_INDEX]++;
                if (--u4ResidualResource == 0) {
                    break;
                }
            }

            if (ai4PerTcResourceDemand[TC5_INDEX]){      /*        */
                prQM->au4CurrentTcResource[TC5_INDEX]++;
                if (--u4ResidualResource == 0) {
                    break;
                }
            }

            if (ai4PerTcResourceDemand[TC1_INDEX]){      /*    */
                prQM->au4CurrentTcResource[TC1_INDEX]++;
                if (--u4ResidualResource == 0) {
                    break;
                }
            }

            if (ai4PerTcResourceDemand[TC0_INDEX]){      /*    */
                prQM->au4CurrentTcResource[TC0_INDEX]++;
                if (--u4ResidualResource == 0) {
                    break;
                }
            }

            /*                            */
            prQM->au4CurrentTcResource[TC3_INDEX] += u4ResidualResource;

        }while(FALSE);
    }

    prQM->fgTcResourcePostAnnealing = TRUE;

#if QM_PRINT_TC_RESOURCE_CTRL
    /*             */
    DBGLOG(QM, INFO, ("QM: TC Rsc adjust to [%03u:%03u:%03u:%03u:%03u:%03u]\n",
        prQM->au4CurrentTcResource[0],
        prQM->au4CurrentTcResource[1],
        prQM->au4CurrentTcResource[2],
        prQM->au4CurrentTcResource[3],
        prQM->au4CurrentTcResource[4],
        prQM->au4CurrentTcResource[5]));
#endif

}
#endif

/*                                                                            */
/* 
                                                                                           
 
               
 
                
*/
/*                                                                            */
VOID qmDoAdaptiveTcResourceCtrl(IN P_ADAPTER_T prAdapter)
{ 
    P_QUE_MGT_T prQM = &prAdapter->rQM;

	/*                                           */
	if (--prQM->u4TimeToUpdateQueLen) {
        return;
    }
	/*                              */
    prQM->u4TimeToUpdateQueLen = QM_INIT_TIME_TO_UPDATE_QUE_LEN;    
    qmUpdateAverageTxQueLen(prAdapter);

	/*                                     */
    /*                                                               */
	if (--prQM->u4TimeToAdjustTcResource == 0) {
       /*                                                     */
		if (prQM->fgTcResourcePostAnnealing) {
            /*                                                                          */
            prQM->u4TimeToAdjustTcResource = 1;
       }

       /*                                      */
		else {
            prQM->u4TimeToAdjustTcResource = QM_INIT_TIME_TO_ADJUST_TC_RSC;
            qmReassignTcResource(prAdapter);
#if QM_FAST_TC_RESOURCE_CTRL
			if (prQM->fgTcResourceFastReaction) {
                prQM->fgTcResourceFastReaction = FALSE;
                nicTxAdjustTcq(prAdapter);
            }
#endif            
       }
    }

    /*       */
#if QM_PRINT_TC_RESOURCE_CTRL
    do {
        UINT_32 u4Tc;
        
		for (u4Tc = 0; u4Tc < QM_ACTIVE_TC_NUM; u4Tc++) {
			if (QM_GET_TX_QUEUE_LEN(prAdapter, u4Tc) >= 100) {
                DBGLOG(QM, LOUD, ("QM: QueLen [%ld %ld %ld %ld %ld %ld]\n",
                    QM_GET_TX_QUEUE_LEN(prAdapter, 0),
                    QM_GET_TX_QUEUE_LEN(prAdapter, 1),
                    QM_GET_TX_QUEUE_LEN(prAdapter, 2),
                    QM_GET_TX_QUEUE_LEN(prAdapter, 3),
                    QM_GET_TX_QUEUE_LEN(prAdapter, 4),
                    QM_GET_TX_QUEUE_LEN(prAdapter, 5)
                    ));
                break;
            }
        }
	} while (FALSE);
#endif

}

#if QM_FAST_TC_RESOURCE_CTRL
VOID qmCheckForFastTcResourceCtrl(IN P_ADAPTER_T prAdapter, IN UINT_8 ucTc)
{
    P_QUE_MGT_T prQM = &prAdapter->rQM;

    /*                                                                                */
	if (!prQM->au4CurrentTcResource[ucTc]) {
        prQM->u4TimeToUpdateQueLen = 1;
        prQM->u4TimeToAdjustTcResource = 1;
        prQM->fgTcResourceFastReaction = TRUE;

        DBGLOG(QM, LOUD, ("Trigger TC Resource adjustment for TC[%u]\n", ucTc));
    }
}
#endif

#endif


/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* 
                                    
 
                   
 
                
*/
/*                                                                            */
VOID qmInitRxQueues(IN P_ADAPTER_T prAdapter)
{
	/*                                           */
    /*      */
}


/*                                                                            */
/* 
                                              
 
                                                   
 
                                                                   
*/
/*                                                                            */
P_SW_RFB_T qmHandleRxPackets(IN P_ADAPTER_T prAdapter, IN P_SW_RFB_T prSwRfbListHead)
{

#if CFG_RX_REORDERING_ENABLED
	/*            */
    P_SW_RFB_T          prCurrSwRfb;
    P_SW_RFB_T          prNextSwRfb;
    P_HW_MAC_RX_DESC_T  prRxStatus;
    QUE_T               rReturnedQue;
    P_QUE_T             prReturnedQue;
    PUINT_8             pucEthDestAddr;
    BOOLEAN             fgIsBMC, fgIsHTran;
    BOOLEAN             fgMicErr;

	/*                                              */

    DEBUGFUNC("qmHandleRxPackets");

    ASSERT(prSwRfbListHead);

    prReturnedQue = &rReturnedQue;

    QUEUE_INITIALIZE(prReturnedQue);
    prNextSwRfb = prSwRfbListHead;

	do {
        prCurrSwRfb = prNextSwRfb;
        prNextSwRfb = QM_RX_GET_NEXT_SW_RFB(prCurrSwRfb);

		/*                                                                                          */
        prRxStatus = prCurrSwRfb->prRxStatus;

        /*                                   */
        prCurrSwRfb->eDst = RX_PKT_DESTINATION_HOST;

        /*                        */
#if CFG_RX_PKTS_DUMP
        if (prAdapter->rRxCtrl.u4RxPktsDumpTypeMask & BIT(HIF_RX_PKT_TYPE_DATA)) {
			DBGLOG(SW4, INFO,
			       ("QM RX DATA: net _u sta idx %u wlan idx %u ssn _u tid %u ptype %u 11 %u\n",
				/*                                         */
				prCurrSwRfb->ucStaRecIdx, prRxStatus->ucWlanIdx,
				/*                                *//*                         */
                    HAL_RX_STATUS_GET_TID(prRxStatus),
				prCurrSwRfb->ucPacketType, prCurrSwRfb->fgReorderBuffer));

			DBGLOG_MEM8(SW4, TRACE, (PUINT_8) prCurrSwRfb->pvHeader,
				    prCurrSwRfb->u2PacketLen);
        }
#endif

        fgIsBMC = HAL_RX_STATUS_IS_BC(prRxStatus) | HAL_RX_STATUS_IS_MC(prRxStatus);
        fgIsHTran = FALSE;
		if (HAL_RX_STATUS_GET_HEADER_TRAN(prRxStatus) == TRUE) {	/*                                           */

            UINT_8 ucBssIndex;
            P_BSS_INFO_T prBssInfo;
            UINT_8 aucTaAddr[MAC_ADDR_LEN];

            fgIsHTran = TRUE;
            pucEthDestAddr = prCurrSwRfb->pvHeader;

            if (prCurrSwRfb->prStaRec == NULL) {
				/*                       */
				if (prCurrSwRfb->prRxStatusGroup4 == NULL) {
					DBGLOG_MEM8(SW4, TRACE, (PUINT_8) prCurrSwRfb->prRxStatus,
						    prCurrSwRfb->prRxStatus->u2RxByteCount);
                    ASSERT(0);
                }
                HAL_RX_STATUS_GET_TA(prCurrSwRfb->prRxStatusGroup4, aucTaAddr);
				prCurrSwRfb->ucStaRecIdx =
				    secLookupStaRecIndexFromTA(prAdapter, aucTaAddr);
				if (prCurrSwRfb->ucStaRecIdx < CFG_NUM_OF_STA_RECORD) {
					prCurrSwRfb->prStaRec =
					    cnmGetStaRecByIndex(prAdapter,
								prCurrSwRfb->ucStaRecIdx);
					DBGLOG(QM, TRACE,
					       ("Re-search the staRec = %d, mac = " MACSTR
						", byteCnt= %d\n", prCurrSwRfb->ucStaRecIdx,
						MAC2STR(aucTaAddr), prRxStatus->u2RxByteCount));
                }

                if (prCurrSwRfb->prStaRec == NULL) {
					DBGLOG(QM, TRACE,
					       ("Mark NULL the Packet for StaRec == NULL, wlanIdx %d, but via Header Translation\n",
						prRxStatus->ucWlanIdx));
					/*                                                                          */
                    prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL;
					QUEUE_INSERT_TAIL(prReturnedQue,
							  (P_QUE_ENTRY_T) prCurrSwRfb);
                    continue;
                }

                prCurrSwRfb->ucWlanIdx = prCurrSwRfb->prStaRec->ucWlanIndex;
				GLUE_SET_PKT_BSS_IDX(prCurrSwRfb->pvPacket,
						     secGetBssIdxByWlanIdx(prAdapter,
									   prCurrSwRfb->ucWlanIdx));
            }
			/*                                                                    */
			if (prAdapter->rRxCtrl.rFreeSwRfbList.u4NumElem
                    > (CFG_RX_MAX_PKT_NUM - CFG_NUM_OF_QM_RX_PKT_NUM)) {

                ucBssIndex = prCurrSwRfb->prStaRec->ucBssIndex;
                prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, ucBssIndex);
				/*                                                   */
				/*  */

                
				/*                                                            */
				/*                                                                              */
				/*   */

				if (IS_BSS_ACTIVE(prBssInfo)) {
					if (OP_MODE_ACCESS_POINT == prBssInfo->eCurrentOPMode) {
						qmHandleRxPackets_AOSP_0;
                    } /*                      */
#if CFG_SUPPORT_PASSPOINT
					else if (hs20IsFrameFilterEnabled(prAdapter, prBssInfo) &&
						 hs20IsUnsecuredFrame(prAdapter, prBssInfo,
								      prCurrSwRfb)) {
						DBGLOG(QM, WARN,
						       ("Mark NULL the Packet for Dropped Packet %u\n",
							ucBssIndex));
                        prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL;
						QUEUE_INSERT_TAIL(prReturnedQue,
								  (P_QUE_ENTRY_T) prCurrSwRfb);
                        continue;
                    }
#endif /*                       */              
				} else {
					DBGLOG(QM, TRACE,
					       ("Mark NULL the Packet for inactive Bss %u\n",
						ucBssIndex));
                    prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL;
					QUEUE_INSERT_TAIL(prReturnedQue,
							  (P_QUE_ENTRY_T) prCurrSwRfb);
                    continue;
                }

			} else {
                    /*                              */
                    DBGLOG(QM, TRACE, ("Mark NULL the Packet for less Free Sw Rfb\n"));
                    prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL;
				QUEUE_INSERT_TAIL(prReturnedQue, (P_QUE_ENTRY_T) prCurrSwRfb);
                    continue;
            }

        }
		/*                                             */

        if (prCurrSwRfb->fgReorderBuffer && !fgIsBMC && fgIsHTran) {
            /*                                                                    
                                                                                  
                                                                                   
                                                                            
                            
            */
            qmProcessPktWithReordering(prAdapter, prCurrSwRfb, prReturnedQue);
            
		} else if (prCurrSwRfb->fgDataFrame) {
			/*                   */
            {
				if (secCheckClassError
				    (prAdapter, prCurrSwRfb, prCurrSwRfb->prStaRec) == TRUE) {
                    P_RX_BA_ENTRY_T prReorderQueParm = NULL;
                        
					/*                      */
					if (fgIsHTran) {
						UINT_16 u2FrameCtrl = 0;
						
						u2FrameCtrl = HAL_RX_STATUS_GET_FRAME_CTL_FIELD(prCurrSwRfb->prRxStatusGroup4);
						//                                           
						if((u2FrameCtrl & MASK_FRAME_TYPE) == MAC_FRAME_DATA){
							DBGLOG(QM, TRACE, ("FC [0x%04X], no-reordering...\n", u2FrameCtrl));
						} 
						else {
							prReorderQueParm = ((prCurrSwRfb->prStaRec->aprRxReorderParamRefTbl)[prCurrSwRfb->ucTid]);
						}					
					}

					if (prReorderQueParm && prReorderQueParm->fgIsValid
					    && !fgIsBMC) {
						qmProcessPktWithReordering(prAdapter, prCurrSwRfb,
									   prReturnedQue);
					} else {
						qmHandleRxPackets_AOSP_1;
                    }                    
				} else {
                   DBGLOG(QM, TRACE, ("Mark NULL the Packet for class error\n"));
                   prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL;
					QUEUE_INSERT_TAIL(prReturnedQue, (P_QUE_ENTRY_T) prCurrSwRfb);
               }
            }
		} else {
            P_WLAN_MAC_HEADER_T prWlanMacHeader;
            
            ASSERT(prCurrSwRfb->pvHeader);
            
            prWlanMacHeader = (P_WLAN_MAC_HEADER_T) prCurrSwRfb->pvHeader;
            prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL;

			switch (prWlanMacHeader->u2FrameCtrl & MASK_FRAME_TYPE) {
                /*           */
                case MAC_FRAME_BLOCK_ACK_REQ:
                    qmProcessBarFrame(prAdapter, prCurrSwRfb, prReturnedQue);
                    break;
                default:
				DBGLOG(QM, TRACE,
				       ("Mark NULL the Packet for non-interesting type\n"));
				QUEUE_INSERT_TAIL(prReturnedQue, (P_QUE_ENTRY_T) prCurrSwRfb);
                    break;
            }
        }

	} while (prNextSwRfb);


    /*                                                           */
	if (QUEUE_IS_NOT_EMPTY(prReturnedQue)) {
		QM_TX_SET_NEXT_MSDU_INFO((P_SW_RFB_T) QUEUE_GET_TAIL(prReturnedQue), NULL);
    }

	return (P_SW_RFB_T) QUEUE_GET_HEAD(prReturnedQue);

#else

	/*                                              */
    return prSwRfbListHead;

#endif

}

/*                                                                            */
/* 
                                    
 
                                             
                                                            
 
                
*/
/*                                                                            */
VOID
qmProcessPktWithReordering(IN P_ADAPTER_T prAdapter,
			   IN P_SW_RFB_T prSwRfb, OUT P_QUE_T prReturnedQue)
{


    P_STA_RECORD_T prStaRec;
    P_HW_MAC_RX_DESC_T  prRxStatus;
    P_HW_MAC_RX_STS_GROUP_4_T  prRxStatusGroup4 = NULL;
    P_RX_BA_ENTRY_T prReorderQueParm;

    UINT_32 u4SeqNo;
    UINT_32 u4WinStart;
    UINT_32 u4WinEnd;
    P_QUE_T prReorderQue;
	/*                              */

    DEBUGFUNC("qmProcessPktWithReordering");

    ASSERT(prSwRfb);
    ASSERT(prReturnedQue);
    ASSERT(prSwRfb->prRxStatus);

    /*                         */
	if (prSwRfb->ucStaRecIdx >= CFG_NUM_OF_STA_RECORD) {
        prSwRfb->eDst = RX_PKT_DESTINATION_NULL;
		QUEUE_INSERT_TAIL(prReturnedQue, (P_QUE_ENTRY_T) prSwRfb);
		DBGLOG(QM, WARN, ("Reordering for a NULL STA_REC, ucStaRecIdx = %d\n",
            prSwRfb->ucStaRecIdx));
        authSendDeauthFrame(prAdapter,
                             NULL,
                             NULL,
				    prSwRfb, REASON_CODE_CLASS_3_ERR, (PFN_TX_DONE_HANDLER) NULL);
		/*            */
        return;
    }

    /*                                        */
    prStaRec = prSwRfb->prStaRec;
    ASSERT(prStaRec);

    prRxStatus = prSwRfb->prRxStatus;
	prSwRfb->ucTid = (UINT_8) (HAL_RX_STATUS_GET_TID(prRxStatus));
	/*                                          */

#if 0
	if (!(prStaRec->fgIsValid)) {
        /*                                                */
        prSwRfb->eDst = RX_PKT_DESTINATION_NULL;
		QUEUE_INSERT_TAIL(prReturnedQue, (P_QUE_ENTRY_T) prSwRfb);
		DBGLOG(QM, WARN, ("Reordering for an invalid STA_REC\n"));
		/*            */
        return;
    }
#endif

    /*                                       */
    prReorderQueParm = ((prStaRec->aprRxReorderParamRefTbl)[prSwRfb->ucTid]);
	if (!prReorderQueParm || !(prReorderQueParm->fgIsValid)) {
		/*                                                */
        prSwRfb->eDst = RX_PKT_DESTINATION_HOST;
		QUEUE_INSERT_TAIL(prReturnedQue, (P_QUE_ENTRY_T) prSwRfb);
		DBGLOG(QM, TRACE, ("Reordering for a NULL ReorderQueParm\n"));
        return;
    }

    prRxStatusGroup4 = prSwRfb->prRxStatusGroup4;
	if (prRxStatusGroup4 == NULL) {
		DBGLOG(QM, ERROR, ("prRxStatusGroup4 is NULL !!!\n"));
		DBGLOG(QM, ERROR,
		       ("prSwRfb->pvHeader is 0x%p !!!\n", (PUINT_32) prSwRfb->pvHeader));
		DBGLOG(QM, ERROR, ("prSwRfb->u2PacketLen is %d !!!\n", prSwRfb->u2PacketLen));
		DBGLOG(QM, ERROR, ("========= START TO DUMP prSwRfb =========\n"));
        DBGLOG_MEM8(QM, ERROR, prSwRfb->pvHeader, prSwRfb->u2PacketLen);
		DBGLOG(QM, ERROR, ("========= END OF DUMP prSwRfb =========\n"));
        ASSERT(prRxStatusGroup4);
    }
    
    
	prSwRfb->u2SSN =
	    HAL_RX_STATUS_GET_SEQFrag_NUM(prRxStatusGroup4) >> RX_STATUS_SEQ_NUM_OFFSET;

    /*                          */
	u4SeqNo = (UINT_32) (prSwRfb->u2SSN);
    prReorderQue = &(prReorderQueParm->rReOrderQue);
	u4WinStart = (UINT_32) (prReorderQueParm->u2WinStart);
	u4WinEnd = (UINT_32) (prReorderQueParm->u2WinEnd);

    /*       */
	/*                                                                                        */

    /*                     */
    if  /*                             */
        (((u4WinStart <= u4SeqNo) && (u4SeqNo <= u4WinEnd))
        /*                             */
        || ((u4WinEnd < u4WinStart) && (u4WinStart <= u4SeqNo))
        /*                             */
	     || ((u4SeqNo <= u4WinEnd) && (u4WinEnd < u4WinStart))) {

        qmInsertFallWithinReorderPkt(prSwRfb, prReorderQueParm, prReturnedQue);

#if QM_RX_WIN_SSN_AUTO_ADVANCING
		if (prReorderQueParm->fgIsWaitingForPktWithSsn) {
            /*                                                      */
			DBGLOG(QM, LOUD,
			       ("QM:(A)[%d](%ld){%ld,%ld}\n", prSwRfb->ucTid, u4SeqNo, u4WinStart,
				u4WinEnd));

			prReorderQueParm->u2WinStart = (UINT_16) u4SeqNo;
            prReorderQueParm->u2WinEnd =
			    ((prReorderQueParm->u2WinStart) + (prReorderQueParm->u2WinSize) -
			     1) % MAX_SEQ_NO_COUNT;
            prReorderQueParm->fgIsWaitingForPktWithSsn = FALSE;
       }
#endif


        qmPopOutDueToFallWithin(prAdapter, prReorderQueParm, prReturnedQue);
    }
    /*                    */
    else if
        /*                                            */
        (((u4WinStart < u4WinEnd)
            && (u4WinEnd < u4SeqNo)
            && (u4SeqNo < (u4WinStart + HALF_SEQ_NO_COUNT)))
        /*                                            */
        || ((u4SeqNo < u4WinStart)
            && (u4WinStart < u4WinEnd)
            && ((u4SeqNo + MAX_SEQ_NO_COUNT) < (u4WinStart + HALF_SEQ_NO_COUNT)))
        /*                                            */
        || ((u4WinEnd < u4SeqNo)
            && (u4SeqNo < u4WinStart)
		 && ((u4SeqNo + MAX_SEQ_NO_COUNT) < (u4WinStart + HALF_SEQ_NO_COUNT)))) {


#if QM_RX_WIN_SSN_AUTO_ADVANCING
		if (prReorderQueParm->fgIsWaitingForPktWithSsn) {
            prReorderQueParm->fgIsWaitingForPktWithSsn = FALSE;
        }
#endif

        qmInsertFallAheadReorderPkt(prSwRfb, prReorderQueParm, prReturnedQue);

        /*                                               */
		prReorderQueParm->u2WinEnd = (UINT_16) u4SeqNo;
        prReorderQueParm->u2WinStart =
		    (((prReorderQueParm->u2WinEnd) - (prReorderQueParm->u2WinSize) +
		      MAX_SEQ_NO_COUNT + 1)
            % MAX_SEQ_NO_COUNT);

        qmPopOutDueToFallAhead(prAdapter, prReorderQueParm, prReturnedQue);

    }
    /*                     */
	else {

#if QM_RX_WIN_SSN_AUTO_ADVANCING
#if QM_RX_INIT_FALL_BEHIND_PASS
		if (prReorderQueParm->fgIsWaitingForPktWithSsn) {
			/*                                             */
			QUEUE_INSERT_TAIL(prReturnedQue, (P_QUE_ENTRY_T) prSwRfb);
			/*                                                                                        */
            return;
        }
#endif
#endif

        /*                     */
        prSwRfb->eDst = RX_PKT_DESTINATION_NULL;
		QUEUE_INSERT_TAIL(prReturnedQue, (P_QUE_ENTRY_T) prSwRfb);
		/*                                                                                        */
        return;
    }

    return;

}


VOID qmProcessBarFrame(IN P_ADAPTER_T prAdapter, IN P_SW_RFB_T prSwRfb, OUT P_QUE_T prReturnedQue)
{

    P_STA_RECORD_T prStaRec;
    P_HW_MAC_RX_DESC_T  prRxStatus;
    P_RX_BA_ENTRY_T prReorderQueParm;
    P_CTRL_BAR_FRAME_T prBarCtrlFrame;

    UINT_32 u4SSN;
    UINT_32 u4WinStart;
    UINT_32 u4WinEnd;
    P_QUE_T prReorderQue;
	/*                              */

    ASSERT(prSwRfb);
    ASSERT(prReturnedQue);
    ASSERT(prSwRfb->prRxStatus);
    ASSERT(prSwRfb->pvHeader);

    prRxStatus = prSwRfb->prRxStatus;
    
    prBarCtrlFrame =  (P_CTRL_BAR_FRAME_T) prSwRfb->pvHeader;
    
	prSwRfb->ucTid =
	    (*((PUINT_16) ((PUINT_8) prBarCtrlFrame + CTRL_BAR_BAR_CONTROL_OFFSET))) >>
	    BAR_CONTROL_TID_INFO_OFFSET;
	prSwRfb->u2SSN =
	    (*((PUINT_16) ((PUINT_8) prBarCtrlFrame + CTRL_BAR_BAR_INFORMATION_OFFSET))) >>
	    OFFSET_BAR_SSC_SN;

    prSwRfb->eDst = RX_PKT_DESTINATION_NULL;
	QUEUE_INSERT_TAIL(prReturnedQue, (P_QUE_ENTRY_T) prSwRfb);

    /*                         */
    prSwRfb->ucStaRecIdx = secLookupStaRecIndexFromTA(prAdapter, prBarCtrlFrame->aucSrcAddr);
	if (prSwRfb->ucStaRecIdx >= CFG_NUM_OF_STA_RECORD) {
        DBGLOG(QM, WARN, ("QM: (Warning) BAR for a NULL STA_REC, ucStaRecIdx = %d\n",
            prSwRfb->ucStaRecIdx));
		/*            */
        return;
    }

    /*                                        */
    prSwRfb->prStaRec = cnmGetStaRecByIndex(prAdapter, prSwRfb->ucStaRecIdx);
    prStaRec = prSwRfb->prStaRec;
    if (prStaRec == NULL) {
		/*                   */
        return;
    }
#if 0
	if (!(prStaRec->fgIsValid)) {
        /*                                                */
		DbgPrint("QM: (Warning) BAR for an invalid STA_REC\n");
		/*            */
        return;
    }
#endif

    /*                                       */
    prReorderQueParm = ((prStaRec->aprRxReorderParamRefTbl)[prSwRfb->ucTid]);
	if (!prReorderQueParm) {
		/*                                                */
		DBGLOG(QM, WARN, ("QM: (Warning) BAR for a NULL ReorderQueParm\n"));
		/*            */
        return;
    }


	u4SSN = (UINT_32) (prSwRfb->u2SSN);
    prReorderQue = &(prReorderQueParm->rReOrderQue);
	u4WinStart = (UINT_32) (prReorderQueParm->u2WinStart);
	u4WinEnd = (UINT_32) (prReorderQueParm->u2WinEnd);

	if (qmCompareSnIsLessThan(u4WinStart, u4SSN)) {
		prReorderQueParm->u2WinStart = (UINT_16) u4SSN;
        prReorderQueParm->u2WinEnd =
		    ((prReorderQueParm->u2WinStart) + (prReorderQueParm->u2WinSize) -
		     1) % MAX_SEQ_NO_COUNT;
		DBGLOG(QM, TRACE,
		       ("QM:(BAR)[%d](%ld){%d,%d}\n", prSwRfb->ucTid, u4SSN,
			prReorderQueParm->u2WinStart, prReorderQueParm->u2WinEnd));
        qmPopOutDueToFallAhead(prAdapter, prReorderQueParm, prReturnedQue);
	} else {
		DBGLOG(QM, TRACE,
		       ("QM:(BAR)(%d)(%ld){%ld,%ld}\n", prSwRfb->ucTid, u4SSN, u4WinStart,
			u4WinEnd));
    }
}



VOID
qmInsertFallWithinReorderPkt(IN P_SW_RFB_T prSwRfb,
			     IN P_RX_BA_ENTRY_T prReorderQueParm, OUT P_QUE_T prReturnedQue)
{
    P_SW_RFB_T prExaminedQueuedSwRfb;
    P_QUE_T prReorderQue;
    ASSERT(prSwRfb);
    ASSERT(prReorderQueParm);
    ASSERT(prReturnedQue);

    prReorderQue = &(prReorderQueParm->rReOrderQue);
	prExaminedQueuedSwRfb = (P_SW_RFB_T) QUEUE_GET_HEAD(prReorderQue);

    /*                                                  */
	if (prExaminedQueuedSwRfb == NULL) {
		((P_QUE_ENTRY_T) prSwRfb)->prPrev = NULL;
		((P_QUE_ENTRY_T) prSwRfb)->prNext = NULL;
		prReorderQue->prHead = (P_QUE_ENTRY_T) prSwRfb;
		prReorderQue->prTail = (P_QUE_ENTRY_T) prSwRfb;
		prReorderQue->u4NumElem++;
    }

    /*                               */
	else {
		do {
            /*                                       */
			if (((prExaminedQueuedSwRfb->u2SSN) == (prSwRfb->u2SSN))) {
                prSwRfb->eDst = RX_PKT_DESTINATION_NULL;
				QUEUE_INSERT_TAIL(prReturnedQue, (P_QUE_ENTRY_T) prSwRfb);
                return;
            }

            /*                                              */
			else if (qmCompareSnIsLessThan((prSwRfb->u2SSN),
						       (prExaminedQueuedSwRfb->u2SSN))) {
                break;
            }

            /*                                                                            */
			else {
                prExaminedQueuedSwRfb =
				    (P_SW_RFB_T) (((P_QUE_ENTRY_T) prExaminedQueuedSwRfb)->prNext);
            }
		} while (prExaminedQueuedSwRfb);

        /*                                                                            */
		if (prExaminedQueuedSwRfb == NULL) {
            /*                                                 */
			((P_QUE_ENTRY_T) prSwRfb)->prPrev = prReorderQue->prTail;
			((P_QUE_ENTRY_T) prSwRfb)->prNext = NULL;
			(prReorderQue->prTail)->prNext = (P_QUE_ENTRY_T) (prSwRfb);
			prReorderQue->prTail = (P_QUE_ENTRY_T) (prSwRfb);
		} else {
			((P_QUE_ENTRY_T) prSwRfb)->prPrev =
			    ((P_QUE_ENTRY_T) prExaminedQueuedSwRfb)->prPrev;
			((P_QUE_ENTRY_T) prSwRfb)->prNext = (P_QUE_ENTRY_T) prExaminedQueuedSwRfb;
			if (((P_QUE_ENTRY_T) prExaminedQueuedSwRfb) == (prReorderQue->prHead)) {
                /*                                          */
				prReorderQue->prHead = (P_QUE_ENTRY_T) prSwRfb;
			} else {
				(((P_QUE_ENTRY_T) prExaminedQueuedSwRfb)->prPrev)->prNext =
				    (P_QUE_ENTRY_T) prSwRfb;
            }
			((P_QUE_ENTRY_T) prExaminedQueuedSwRfb)->prPrev = (P_QUE_ENTRY_T) prSwRfb;
        }

		prReorderQue->u4NumElem++;

    }

}


VOID
qmInsertFallAheadReorderPkt(IN P_SW_RFB_T prSwRfb,
			    IN P_RX_BA_ENTRY_T prReorderQueParm, OUT P_QUE_T prReturnedQue)
{
    P_QUE_T prReorderQue;
    ASSERT(prSwRfb);
    ASSERT(prReorderQueParm);
    ASSERT(prReturnedQue);

    prReorderQue = &(prReorderQueParm->rReOrderQue);

    /*                                                  */
	if (QUEUE_IS_EMPTY(prReorderQue)) {
		((P_QUE_ENTRY_T) prSwRfb)->prPrev = NULL;
		((P_QUE_ENTRY_T) prSwRfb)->prNext = NULL;
		prReorderQue->prHead = (P_QUE_ENTRY_T) prSwRfb;
	} else {
		((P_QUE_ENTRY_T) prSwRfb)->prPrev = prReorderQue->prTail;
		((P_QUE_ENTRY_T) prSwRfb)->prNext = NULL;
		(prReorderQue->prTail)->prNext = (P_QUE_ENTRY_T) (prSwRfb);
    }
	prReorderQue->prTail = (P_QUE_ENTRY_T) prSwRfb;
	prReorderQue->u4NumElem++;

}


VOID
qmPopOutDueToFallWithin(IN P_ADAPTER_T prAdapter,
			IN P_RX_BA_ENTRY_T prReorderQueParm, OUT P_QUE_T prReturnedQue)
{
    P_SW_RFB_T prReorderedSwRfb;
    P_QUE_T prReorderQue;
    BOOLEAN fgDequeuHead, fgMissing;
    OS_SYSTIME rCurrentTime, rMissTimeout;

    prReorderQue = &(prReorderQueParm->rReOrderQue);

    fgMissing = FALSE;
    rCurrentTime = 0;
    rMissTimeout = g_arMissTimeout[prReorderQueParm->ucStaRecIdx][prReorderQueParm->ucTid];
	if (rMissTimeout) {
        fgMissing = TRUE;
        GET_CURRENT_SYSTIME(&rCurrentTime);
    }

    /*                                                               */
	while (TRUE) {
		if (QUEUE_IS_EMPTY(prReorderQue)) {
            break;
        }

        /*                                */
		prReorderedSwRfb = (P_SW_RFB_T) QUEUE_GET_HEAD(prReorderQue);
        fgDequeuHead = FALSE;

        /*                                                                            */
		if ((prReorderedSwRfb->u2SSN) == (prReorderQueParm->u2WinStart)) {

            fgDequeuHead = TRUE;
            prReorderQueParm->u2WinStart =
			    (((prReorderedSwRfb->u2SSN) + 1) % MAX_SEQ_NO_COUNT);
        }
        /*                                       */
		else {
            /*                    */
			if (!prReorderQueParm->fgHasBubble) {
				cnmTimerStartTimer(prAdapter,
						   &(prReorderQueParm->rReorderBubbleTimer),
						   QM_RX_BA_ENTRY_MISS_TIMEOUT_MS);
                prReorderQueParm->fgHasBubble = TRUE;
                prReorderQueParm->u2FirstBubbleSn = prReorderQueParm->u2WinStart;

				DBGLOG(QM, TRACE,
				       ("QM:(Bub Timer) STA[%u] TID[%u] BubSN[%u] Win{%d, %d}\n",
					prReorderQueParm->ucStaRecIdx, prReorderedSwRfb->ucTid,
                    prReorderQueParm->u2FirstBubbleSn, 
					prReorderQueParm->u2WinStart, prReorderQueParm->u2WinEnd));
            }
            
            if ((fgMissing == TRUE) &&
                CHECK_FOR_TIMEOUT(rCurrentTime, rMissTimeout,
                                  MSEC_TO_SYSTIME(QM_RX_BA_ENTRY_MISS_TIMEOUT_MS))) {
				DBGLOG(QM, TRACE,
				       ("QM:RX BA Timout Next Tid %d SSN %d\n",
					prReorderQueParm->ucTid, prReorderedSwRfb->u2SSN));
                fgDequeuHead = TRUE;
                prReorderQueParm->u2WinStart =
				    (((prReorderedSwRfb->u2SSN) + 1) % MAX_SEQ_NO_COUNT);

                fgMissing = FALSE;
			} else
				break;
            }


        /*                         */
		if (fgDequeuHead) {

			if (((P_QUE_ENTRY_T) prReorderedSwRfb)->prNext == NULL) {
                prReorderQue->prHead = NULL;
                prReorderQue->prTail = NULL;
			} else {
				prReorderQue->prHead = ((P_QUE_ENTRY_T) prReorderedSwRfb)->prNext;
				(((P_QUE_ENTRY_T) prReorderedSwRfb)->prNext)->prPrev = NULL;
            }
			prReorderQue->u4NumElem--;
			/*                                                                                                                  */
			QUEUE_INSERT_TAIL(prReturnedQue, (P_QUE_ENTRY_T) prReorderedSwRfb);
            }
    }

	if (QUEUE_IS_EMPTY(prReorderQue)) {
        rMissTimeout = 0;
	} else {
        if (fgMissing == FALSE) {
            GET_CURRENT_SYSTIME(&rMissTimeout);
        }
    }

    /*                                                       */
    prReorderQueParm->u2WinEnd =
	    (((prReorderQueParm->u2WinStart) + (prReorderQueParm->u2WinSize) -
	      1) % MAX_SEQ_NO_COUNT);

}

VOID
qmPopOutDueToFallAhead(IN P_ADAPTER_T prAdapter,
		       IN P_RX_BA_ENTRY_T prReorderQueParm, OUT P_QUE_T prReturnedQue)
{
    P_SW_RFB_T prReorderedSwRfb;
    P_QUE_T prReorderQue;
    BOOLEAN fgDequeuHead;

    prReorderQue = &(prReorderQueParm->rReOrderQue);

    /*                                                               */
	while (TRUE) {
		if (QUEUE_IS_EMPTY(prReorderQue)) {
            break;
        }

        /*                                */
		prReorderedSwRfb = (P_SW_RFB_T) QUEUE_GET_HEAD(prReorderQue);
        fgDequeuHead = FALSE;

        /*                                                                            */
		if ((prReorderedSwRfb->u2SSN) == (prReorderQueParm->u2WinStart)) {

            fgDequeuHead = TRUE;
            prReorderQueParm->u2WinStart =
			    (((prReorderedSwRfb->u2SSN) + 1) % MAX_SEQ_NO_COUNT);
        }

        /*                                                                                  */
		else if (qmCompareSnIsLessThan((UINT_32) (prReorderedSwRfb->u2SSN),
					       (UINT_32) (prReorderQueParm->u2WinStart))) {

            fgDequeuHead = TRUE;

        }

        /*                                       */
		else {
            /*                    */
			if (!prReorderQueParm->fgHasBubble) {
				cnmTimerStartTimer(prAdapter,
						   &(prReorderQueParm->rReorderBubbleTimer),
						   QM_RX_BA_ENTRY_MISS_TIMEOUT_MS);
                prReorderQueParm->fgHasBubble = TRUE;
                prReorderQueParm->u2FirstBubbleSn = prReorderQueParm->u2WinStart;

				DBGLOG(QM, TRACE,
				       ("QM:(Bub Timer) STA[%u] TID[%u] BubSN[%u] Win{%d, %d}\n",
					prReorderQueParm->ucStaRecIdx, prReorderedSwRfb->ucTid,
                    prReorderQueParm->u2FirstBubbleSn, 
					prReorderQueParm->u2WinStart, prReorderQueParm->u2WinEnd));
            }            
            break;
        }


        /*                         */
		if (fgDequeuHead) {

			if (((P_QUE_ENTRY_T) prReorderedSwRfb)->prNext == NULL) {
                prReorderQue->prHead = NULL;
                prReorderQue->prTail = NULL;
			} else {
				prReorderQue->prHead = ((P_QUE_ENTRY_T) prReorderedSwRfb)->prNext;
				(((P_QUE_ENTRY_T) prReorderedSwRfb)->prNext)->prPrev = NULL;
            }
			prReorderQue->u4NumElem--;
			/*                                                                                                                  */
			QUEUE_INSERT_TAIL(prReturnedQue, (P_QUE_ENTRY_T) prReorderedSwRfb);
            }
    }

    /*                                                       */
    prReorderQueParm->u2WinEnd =
	    (((prReorderQueParm->u2WinStart) + (prReorderQueParm->u2WinSize) -
	      1) % MAX_SEQ_NO_COUNT);

}

VOID qmHandleReorderBubbleTimeout(IN P_ADAPTER_T prAdapter, IN ULONG ulParamPtr)
{
	P_RX_BA_ENTRY_T prReorderQueParm = (P_RX_BA_ENTRY_T) ulParamPtr;
	P_SW_RFB_T prSwRfb = (P_SW_RFB_T) NULL;
    P_EVENT_CHECK_REORDER_BUBBLE_T prCheckReorderEvent;

    KAL_SPIN_LOCK_DECLARATION();

	if (!prReorderQueParm->fgIsValid) {
        DBGLOG(QM, TRACE, ("QM:(Bub Check Cancel) STA[%u] TID[%u], No Rx BA entry\n", 
				   prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid));
        return;
    }

	if (!prReorderQueParm->fgHasBubble) {
		DBGLOG(QM, TRACE,
		       ("QM:(Bub Check Cancel) STA[%u] TID[%u], Bubble has been filled\n",
			prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid));
        return;
    }    
        
    DBGLOG(QM, TRACE, ("QM:(Bub Timeout) STA[%u] TID[%u] BubSN[%u]\n", 
        prReorderQueParm->ucStaRecIdx, 
			   prReorderQueParm->ucTid, prReorderQueParm->u2FirstBubbleSn));

    /*                                         */        
    KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_RX_FREE_QUE);
    QUEUE_REMOVE_HEAD(&prAdapter->rRxCtrl.rFreeSwRfbList, prSwRfb, P_SW_RFB_T);
    KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_RX_FREE_QUE);        

	if (prSwRfb) {
		prCheckReorderEvent = (P_EVENT_CHECK_REORDER_BUBBLE_T) prSwRfb->pucRecvBuff;
            
        prSwRfb->ucPacketType = RX_PKT_TYPE_SW_DEFINED;

        prSwRfb->prRxStatus->u2PktTYpe = RXM_RXD_PKT_TYPE_SW_EVENT;

        prCheckReorderEvent->ucEID = EVENT_ID_CHECK_REORDER_BUBBLE;
        prCheckReorderEvent->ucSeqNum = 0;

        prCheckReorderEvent->ucStaRecIdx = prReorderQueParm->ucStaRecIdx;
        prCheckReorderEvent->ucTid = prReorderQueParm->ucTid;
        prCheckReorderEvent->u2Length = sizeof(EVENT_CHECK_REORDER_BUBBLE_T);

        KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_RX_QUE);
        QUEUE_INSERT_TAIL(&prAdapter->rRxCtrl.rReceivedRfbList, &prSwRfb->rQueEntry);
        RX_INC_CNT(&prAdapter->rRxCtrl, RX_MPDU_TOTAL_COUNT);
        KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_RX_QUE);  

        DBGLOG(QM, LOUD, ("QM:(Bub Check Event Sent) STA[%u] TID[%u]\n", 
				  prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid));

        nicRxProcessRFBs(prAdapter);     
        
        DBGLOG(QM, LOUD, ("QM:(Bub Check Event Handled) STA[%u] TID[%u]\n", 
				  prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid));
    } else {
		DBGLOG(QM, TRACE,
		       ("QM:(Bub Check Cancel) STA[%u] TID[%u], Bub check event alloc failed\n",
			prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid));
        
		cnmTimerStartTimer(prAdapter, &(prReorderQueParm->rReorderBubbleTimer),
				   QM_RX_BA_ENTRY_MISS_TIMEOUT_MS);
        
        DBGLOG(QM, TRACE, ("QM:(Bub Timer Restart) STA[%u] TID[%u] BubSN[%u] Win{%d, %d}\n", 
            prReorderQueParm->ucStaRecIdx,
            prReorderQueParm->ucTid, 
            prReorderQueParm->u2FirstBubbleSn, 
				   prReorderQueParm->u2WinStart, prReorderQueParm->u2WinEnd));
    }

    return;
}

VOID qmHandleEventCheckReorderBubble(IN P_ADAPTER_T prAdapter, IN P_WIFI_EVENT_T prEvent)
{
	P_EVENT_CHECK_REORDER_BUBBLE_T prCheckReorderEvent =
	    (P_EVENT_CHECK_REORDER_BUBBLE_T) prEvent;
    P_RX_BA_ENTRY_T prReorderQueParm;
    P_QUE_T prReorderQue;
    QUE_T rReturnedQue;
    P_QUE_T prReturnedQue = &rReturnedQue;  
    P_SW_RFB_T prReorderedSwRfb, prSwRfb;

    QUEUE_INITIALIZE(prReturnedQue);

    /*                        */
	prReorderQueParm = qmLookupRxBaEntry(prAdapter,
                        prCheckReorderEvent->ucStaRecIdx,
                        prCheckReorderEvent->ucTid);

    /*              */
	if (!prReorderQueParm) {
        DBGLOG(QM, TRACE, ("QM:(Bub Check Cancel) STA[%u] TID[%u], No Rx BA entry\n", 
				   prCheckReorderEvent->ucStaRecIdx, prCheckReorderEvent->ucTid));
        return;
    }

	if (!prReorderQueParm->fgIsValid) {
        DBGLOG(QM, TRACE, ("QM:(Bub Check Cancel) STA[%u] TID[%u], No Rx BA entry\n", 
				   prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid));
        return;
    }

	if (!prReorderQueParm->fgHasBubble) {
		DBGLOG(QM, TRACE,
		       ("QM:(Bub Check Cancel) STA[%u] TID[%u], Bubble has been filled\n",
			prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid));
        return;
    }    

    prReorderQue = &(prReorderQueParm->rReOrderQue);

	if (QUEUE_IS_EMPTY(prReorderQue)) {
        prReorderQueParm->fgHasBubble = FALSE;
        
		DBGLOG(QM, TRACE,
		       ("QM:(Bub Check Cancel) STA[%u] TID[%u], Bubble has been filled\n",
			prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid));
        
        return;
    }

    DBGLOG(QM, TRACE, ("QM:(Bub Check Event Got) STA[%u] TID[%u]\n", 
			   prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid));

    /*                                                           */
	if (prReorderQueParm->u2FirstBubbleSn == prReorderQueParm->u2WinStart) {

		prReorderedSwRfb = (P_SW_RFB_T) QUEUE_GET_TAIL(prReorderQue);

        prReorderQueParm->u2WinStart = prReorderedSwRfb->u2SSN + 1;
        prReorderQueParm->u2WinEnd =
		    ((prReorderQueParm->u2WinStart) + (prReorderQueParm->u2WinSize) -
		     1) % MAX_SEQ_NO_COUNT;
        
        qmPopOutDueToFallAhead(prAdapter, prReorderQueParm, prReturnedQue);

        DBGLOG(QM, TRACE, ("QM:(Bub Flush) STA[%u] TID[%u] BubSN[%u] Win{%d, %d}\n", 
            prReorderQueParm->ucStaRecIdx,
            prReorderQueParm->ucTid, 
            prReorderQueParm->u2FirstBubbleSn, 
				   prReorderQueParm->u2WinStart, prReorderQueParm->u2WinEnd));

		if (QUEUE_IS_NOT_EMPTY(prReturnedQue)) {
			QM_TX_SET_NEXT_MSDU_INFO((P_SW_RFB_T) QUEUE_GET_TAIL(prReturnedQue), NULL);
            
			prSwRfb = (P_SW_RFB_T) QUEUE_GET_HEAD(prReturnedQue);
			while (prSwRfb) {
				DBGLOG(QM, TRACE,
				       ("QM:(Bub Flush) STA[%u] TID[%u] Pop Out SN[%u]\n",
					prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid,
                    prSwRfb->u2SSN)); 

				prSwRfb =
				    (P_SW_RFB_T) QUEUE_GET_NEXT_ENTRY((P_QUE_ENTRY_T) prSwRfb);
            }
            
			wlanProcessQueuedSwRfb(prAdapter,
					       (P_SW_RFB_T) QUEUE_GET_HEAD(prReturnedQue));
        } else {
            DBGLOG(QM, TRACE, ("QM:(Bub Flush) STA[%u] TID[%u] Pop Out 0 packet\n", 
					   prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid));
        }
            
        prReorderQueParm->fgHasBubble = FALSE;
    }
    /*                                               */
    else {
        prReorderQueParm->u2FirstBubbleSn = prReorderQueParm->u2WinStart;
		cnmTimerStartTimer(prAdapter, &(prReorderQueParm->rReorderBubbleTimer),
				   QM_RX_BA_ENTRY_MISS_TIMEOUT_MS);
        
        DBGLOG(QM, TRACE, ("QM:(Bub Timer) STA[%u] TID[%u] BubSN[%u] Win{%d, %d}\n", 
            prReorderQueParm->ucStaRecIdx,
            prReorderQueParm->ucTid, 
            prReorderQueParm->u2FirstBubbleSn, 
				   prReorderQueParm->u2WinStart, prReorderQueParm->u2WinEnd));
    }

    return;
}


BOOLEAN qmCompareSnIsLessThan(IN UINT_32 u4SnLess, IN UINT_32 u4SnGreater)
{
    /*                                                                   */
	if ((u4SnLess + HALF_SEQ_NO_COUNT) <= u4SnGreater) {	/*             */
        return FALSE;
    }

    /*                                                                   */
	else if ((u4SnGreater + HALF_SEQ_NO_COUNT) < u4SnLess) {
        return TRUE;
    }

    /*                                                                   */
    /*                                                                   */
	else {
		return u4SnLess < u4SnGreater;
    }
}


/*                                                                            */
/* 
                                   
 
                                                                    
 
                
*/
/*                                                                            */
VOID qmHandleMailboxRxMessage(IN MAILBOX_MSG_T prMailboxRxMsg)
{
	/*                                                     */
    /*      */
}


/*                                                                            */
/* 
                                           
 
                                      
                                                 
 
                
*/
/*                                                                            */
VOID qmHandleEventRxAddBa(IN P_ADAPTER_T prAdapter, IN P_WIFI_EVENT_T prEvent)
{
    P_EVENT_RX_ADDBA_T prEventRxAddBa;
    P_STA_RECORD_T prStaRec;
    UINT_32 u4Tid;
    UINT_32 u4WinSize;

    DBGLOG(QM, INFO, ("QM:Event +RxBa\n"));

	prEventRxAddBa = (P_EVENT_RX_ADDBA_T) prEvent;
    prStaRec = QM_GET_STA_REC_PTR_FROM_INDEX(prAdapter, prEventRxAddBa->ucStaRecIdx);

	if (!prStaRec) {
        /*                                                 */
		/*            */
        DBGLOG(QM, INFO, ("QM: (Warning) RX ADDBA Event for a NULL STA_REC\n"));
        return;
    }
#if 0
	if (!(prStaRec->fgIsValid)) {
        /*                                                          */
        DBGLOG(QM, WARN, ("QM: (Warning) RX ADDBA Event for an invalid STA_REC\n"));
		/*            */
		/*         */
    }
#endif

	u4Tid = (((prEventRxAddBa->u2BAParameterSet) & BA_PARAM_SET_TID_MASK)
            >> BA_PARAM_SET_TID_MASK_OFFSET);

	u4WinSize = (((prEventRxAddBa->u2BAParameterSet) & BA_PARAM_SET_BUFFER_SIZE_MASK)
            >> BA_PARAM_SET_BUFFER_SIZE_MASK_OFFSET);

	if (!qmAddRxBaEntry(prAdapter,
        prStaRec->ucIndex,
			    (UINT_8) u4Tid,
        (prEventRxAddBa->u2BAStartSeqCtrl >> OFFSET_BAR_SSC_SN),
			    (UINT_16) u4WinSize)) {

        /*                                                              */
        DBGLOG(QM, ERROR, ("QM: (Error) qmAddRxBaEntry() failure\n"));
        ASSERT(0);
    }

}

/*                                                                            */
/* 
                                           
 
                                      
                                                 
 
                
*/
/*                                                                            */
VOID qmHandleEventRxDelBa(IN P_ADAPTER_T prAdapter, IN P_WIFI_EVENT_T prEvent)
{
    P_EVENT_RX_DELBA_T prEventRxDelBa;
    P_STA_RECORD_T prStaRec;

	/*                               */

	prEventRxDelBa = (P_EVENT_RX_DELBA_T) prEvent;
    prStaRec = QM_GET_STA_REC_PTR_FROM_INDEX(prAdapter, prEventRxDelBa->ucStaRecIdx);

	if (!prStaRec) {
        /*                                                 */
		/*            */
        return;
    }
#if 0
	if (!(prStaRec->fgIsValid)) {
        /*                                                          */
		/*            */
        return;
    }
#endif

    qmDelRxBaEntry(prAdapter, prStaRec->ucIndex, prEventRxDelBa->ucTid, TRUE);

}

P_RX_BA_ENTRY_T qmLookupRxBaEntry(IN P_ADAPTER_T prAdapter, UINT_8 ucStaRecIdx, UINT_8 ucTid)
{
    int i;
    P_QUE_MGT_T prQM = &prAdapter->rQM;

	/*                                              */

	for (i = 0; i < CFG_NUM_OF_RX_BA_AGREEMENTS; i++) {
		if (prQM->arRxBaTable[i].fgIsValid) {
			if ((prQM->arRxBaTable[i].ucStaRecIdx == ucStaRecIdx) &&
			    (prQM->arRxBaTable[i].ucTid == ucTid)) {
                return &prQM->arRxBaTable[i];
            }
        }
    }
    return NULL;
}

BOOL
qmAddRxBaEntry(IN P_ADAPTER_T prAdapter,
	       IN UINT_8 ucStaRecIdx, IN UINT_8 ucTid, IN UINT_16 u2WinStart, IN UINT_16 u2WinSize)
{
    int i;
    P_RX_BA_ENTRY_T prRxBaEntry = NULL;
    P_STA_RECORD_T prStaRec;
    P_QUE_MGT_T prQM = &prAdapter->rQM;

    ASSERT(ucStaRecIdx < CFG_NUM_OF_STA_RECORD);

	if (ucStaRecIdx >= CFG_NUM_OF_STA_RECORD) {
        /*                                                 */
		DBGLOG(QM, WARN,
		       ("QM: (WARNING) RX ADDBA Event for a invalid ucStaRecIdx = %d\n",
			ucStaRecIdx));
        return FALSE;
    }

    prStaRec = &prAdapter->arStaRec[ucStaRecIdx];
    ASSERT(prStaRec);

	/*                             */
	/*                                                               */
	/*               */
	/*   */

	/*                            */
    /*                                                                */
	if (qmLookupRxBaEntry(prAdapter, ucStaRecIdx, ucTid)) {
        qmDelRxBaEntry(prAdapter, ucStaRecIdx, ucTid, TRUE); /*                     */
    }
	/*                          */
    /*                                                                  */
	if (prQM->ucRxBaCount >= CFG_NUM_OF_RX_BA_AGREEMENTS) {
		DBGLOG(QM, ERROR,
		       ("QM: **failure** (limited resource, ucRxBaCount=%d)\n", prQM->ucRxBaCount));
        return FALSE;
	} else {
       /*                               */
		for (i = 0; i < CFG_NUM_OF_RX_BA_AGREEMENTS; i++) {
			if (!prQM->arRxBaTable[i].fgIsValid) {
                prRxBaEntry = &(prQM->arRxBaTable[i]);
                prQM->ucRxBaCount++;
                DBGLOG(QM, LOUD, ("QM: ucRxBaCount=%d\n", prQM->ucRxBaCount));
                break;
            }
        }

        /*                                                                                 */
        u2WinSize += CFG_RX_BA_INC_SIZE;
		if (prRxBaEntry) {
            prRxBaEntry->ucStaRecIdx = ucStaRecIdx;
            prRxBaEntry->ucTid = ucTid;
            prRxBaEntry->u2WinStart = u2WinStart;
			prRxBaEntry->u2WinSize = u2WinSize;
            prRxBaEntry->u2WinEnd = ((u2WinStart + u2WinSize - 1) % MAX_SEQ_NO_COUNT);
            prRxBaEntry->fgIsValid = TRUE;
            prRxBaEntry->fgIsWaitingForPktWithSsn = TRUE;
            prRxBaEntry->fgHasBubble = FALSE;

            g_arMissTimeout[ucStaRecIdx][ucTid] = 0;

			DBGLOG(QM, INFO,
			       ("QM: +RxBA(STA=%d TID=%d WinStart=%d WinEnd=%d WinSize=%d)\n",
				ucStaRecIdx, ucTid, prRxBaEntry->u2WinStart, prRxBaEntry->u2WinEnd,
				prRxBaEntry->u2WinSize));

            /*                                                           */
            prStaRec->aprRxReorderParamRefTbl[ucTid] = prRxBaEntry;
		} else {
            /*                                                                                  */
			DBGLOG(QM, ERROR,
			       ("QM: **AddBA Error** (ucRxBaCount=%d)\n", prQM->ucRxBaCount));
            return FALSE;
        }
    }

    return TRUE;
}

VOID
qmDelRxBaEntry(IN P_ADAPTER_T prAdapter,
	       IN UINT_8 ucStaRecIdx, IN UINT_8 ucTid, IN BOOLEAN fgFlushToHost)
{
    P_RX_BA_ENTRY_T prRxBaEntry;
    P_STA_RECORD_T prStaRec;
    P_SW_RFB_T prFlushedPacketList = NULL;
    P_QUE_MGT_T prQM = &prAdapter->rQM;

    ASSERT(ucStaRecIdx < CFG_NUM_OF_STA_RECORD);

    prStaRec = &prAdapter->arStaRec[ucStaRecIdx];
    ASSERT(prStaRec);

#if 0
	if (!(prStaRec->fgIsValid)) {
		DbgPrint("QM: (WARNING) Invalid STA when deleting an RX BA\n");
        return;
    }
#endif

    /*                                                                */
    prRxBaEntry = prStaRec->aprRxReorderParamRefTbl[ucTid];

	if (prRxBaEntry) {

        prFlushedPacketList = qmFlushStaRxQueue(prAdapter, ucStaRecIdx, ucTid);

		if (prFlushedPacketList) {

			if (fgFlushToHost) {
                wlanProcessQueuedSwRfb(prAdapter, prFlushedPacketList);
			} else {

                P_SW_RFB_T prSwRfb;
                P_SW_RFB_T prNextSwRfb;
                prSwRfb =  prFlushedPacketList;

                do {
					prNextSwRfb =
					    (P_SW_RFB_T) QUEUE_GET_NEXT_ENTRY((P_QUE_ENTRY_T)
									      prSwRfb);
                    nicRxReturnRFB(prAdapter, prSwRfb);
                    prSwRfb = prNextSwRfb;
				} while (prSwRfb);

            }


        }

		if (prRxBaEntry->fgHasBubble) {
            DBGLOG(QM, TRACE, ("QM:(Bub Check Cancel) STA[%u] TID[%u], DELBA\n", 
					   prRxBaEntry->ucStaRecIdx, prRxBaEntry->ucTid));
            
            cnmTimerStopTimer(prAdapter, &prRxBaEntry->rReorderBubbleTimer);
            prRxBaEntry->fgHasBubble = FALSE;
        }
#if ((QM_TEST_MODE == 0) && (QM_TEST_STA_REC_DEACTIVATION == 0))
        /*                                                                     */
        prRxBaEntry->fgIsValid = FALSE;
        prQM->ucRxBaCount--;

        /*       */
#if 0
        DbgPrint("QM: ucRxBaCount=%d\n", prQM->ucRxBaCount);
#endif

        /*                        */
        prStaRec->aprRxReorderParamRefTbl[ucTid] = NULL;
#endif

        DBGLOG(QM, INFO, ("QM: -RxBA(STA=%d,TID=%d)\n", ucStaRecIdx, ucTid));

    }


    /*       */
#if CFG_HIF_RX_STARVATION_WARNING
    {
        P_RX_CTRL_T prRxCtrl;
        prRxCtrl = &prAdapter->rRxCtrl;
		DBGLOG(QM, TRACE,
		       ("QM: (RX DEBUG) Enqueued: %d / Dequeued: %d\n", prRxCtrl->u4QueuedCnt,
			prRxCtrl->u4DequeuedCnt));
    }
#endif
}

VOID
mqmParseAssocReqWmmIe(IN P_ADAPTER_T prAdapter, 
    IN PUINT_8 pucIE, IN P_STA_RECORD_T prStaRec)
{
	P_IE_WMM_INFO_T prIeWmmInfo;
	UINT_8 ucQosInfo;
	UINT_8 ucQosInfoAC;
	UINT_8 ucBmpAC;
	UINT_8 aucWfaOui[] = VENDOR_OUI_WFA;    

	if ((WMM_IE_OUI_TYPE(pucIE) == VENDOR_OUI_TYPE_WMM) &&
	    (!kalMemCmp(WMM_IE_OUI(pucIE), aucWfaOui, 3))) {

		switch (WMM_IE_OUI_SUBTYPE(pucIE)) {
		case VENDOR_OUI_SUBTYPE_WMM_INFO:
        	if (IE_LEN(pucIE) != 7) {
        		break;	/*                                 */
        	}

        	prStaRec->fgIsQoS = TRUE;
        	prStaRec->fgIsWmmSupported = TRUE;

        	prIeWmmInfo = (P_IE_WMM_INFO_T) pucIE;
        	ucQosInfo = prIeWmmInfo->ucQosInfo;
        	ucQosInfoAC = ucQosInfo & BITS(0, 3);

            if(IS_FEATURE_ENABLED(prAdapter->rWifiVar.ucUapsd))
                prStaRec->fgIsUapsdSupported = (ucQosInfoAC) ? TRUE : FALSE;
            else
                prStaRec->fgIsUapsdSupported = FALSE;

        	ucBmpAC = 0;

        	if (ucQosInfoAC & WMM_QOS_INFO_VO_UAPSD) {
        		ucBmpAC |= BIT(ACI_VO);
        	}
        	if (ucQosInfoAC & WMM_QOS_INFO_VI_UAPSD) {
        		ucBmpAC |= BIT(ACI_VI);
        	}
        	if (ucQosInfoAC & WMM_QOS_INFO_BE_UAPSD) {
        		ucBmpAC |= BIT(ACI_BE);
        	}
        	if (ucQosInfoAC & WMM_QOS_INFO_BK_UAPSD) {
        		ucBmpAC |= BIT(ACI_BK);
        	}
        	prStaRec->ucBmpTriggerAC = prStaRec->ucBmpDeliveryAC = ucBmpAC;
        	prStaRec->ucUapsdSp = (ucQosInfo & WMM_QOS_INFO_MAX_SP_LEN_MASK) >> 5;
			break;

		default:
			/*                               */
			break;
		}
	}   
}

/*                                                                            */
/* 
                                                
 
                                      
                                                  
                                                                        
                                                                    
 
              
*/
/*                                                                            */
VOID
mqmProcessAssocReq(IN P_ADAPTER_T prAdapter,
		   IN P_SW_RFB_T prSwRfb, IN PUINT_8 pucIE, IN UINT_16 u2IELength)
{
    P_STA_RECORD_T      prStaRec;
    UINT_16             u2Offset;
    PUINT_8             pucIEStart;
    UINT_32             u4Flags;

    DEBUGFUNC("mqmProcessAssocReq");

    ASSERT(prSwRfb);
    ASSERT(pucIE);

    prStaRec = cnmGetStaRecByIndex(prAdapter, prSwRfb->ucStaRecIdx);
    ASSERT(prStaRec);

	if (prStaRec == NULL) {
        return;
    }

    prStaRec->fgIsQoS = FALSE;
    prStaRec->fgIsWmmSupported = prStaRec->fgIsUapsdSupported = FALSE;

    pucIEStart = pucIE;

	/*                                                                                  */
    if (IS_FEATURE_DISABLED(prAdapter->rWifiVar.ucQoS)) {
        return;
    }


    /*                                                       */
	else {
        IE_FOR_EACH(pucIE, u2IELength, u2Offset) {
            switch (IE_ID(pucIE)) {
			case ELEM_ID_VENDOR:
				mqmParseAssocReqWmmIe(prAdapter, pucIE, prStaRec);

                prStaRec->u4Flags = 0;
#if CFG_SUPPORT_MTK_SYNERGY                
                if (rlmParseCheckMTKOuiIE(prAdapter, pucIE, &u4Flags)) {
                    prStaRec->u4Flags = u4Flags;
                }
#endif

                break;

            case ELEM_ID_HT_CAP:
                /*                                                       */
                if (IE_LEN(pucIE) == (sizeof(IE_HT_CAP_T) - 2)) {
                    prStaRec->fgIsQoS = TRUE;
                }
                break;
                default:
                break;
            }
        }

        DBGLOG(QM, TRACE, ("MQM: Assoc_Req Parsing (QoS Enabled=%d)\n", prStaRec->fgIsQoS));

    }
}

VOID
mqmParseAssocRspWmmIe(IN PUINT_8 pucIE, IN P_STA_RECORD_T prStaRec)
{
	UINT_8 aucWfaOui[] = VENDOR_OUI_WFA;

	if ((WMM_IE_OUI_TYPE(pucIE) == VENDOR_OUI_TYPE_WMM) &&
	    (!kalMemCmp(WMM_IE_OUI(pucIE), aucWfaOui, 3))) {

    	switch (WMM_IE_OUI_SUBTYPE(pucIE)) {
    	case VENDOR_OUI_SUBTYPE_WMM_PARAM:
    		if (IE_LEN(pucIE) != 24) {
    			break;	/*                                 */
    		}
    		prStaRec->fgIsQoS = TRUE;
    		break;

    	case VENDOR_OUI_SUBTYPE_WMM_INFO:
    		if (IE_LEN(pucIE) != 7) {
    			break;	/*                                 */
    		}
    		prStaRec->fgIsQoS = TRUE;
    		break;

    	default:
    		/*                               */
    		break;
    	}
    }        
}

/*                                                                            */
/* 
                                                
 
                                      
                                                  
                                                                        
                                                                    
 
              
*/
/*                                                                            */
VOID
mqmProcessAssocRsp(IN P_ADAPTER_T prAdapter,
		   IN P_SW_RFB_T prSwRfb, IN PUINT_8 pucIE, IN UINT_16 u2IELength)
{
    P_STA_RECORD_T      prStaRec;
    UINT_16             u2Offset;
    PUINT_8             pucIEStart;
    UINT_32             u4Flags;

    DEBUGFUNC("mqmProcessAssocRsp");

    ASSERT(prSwRfb);
    ASSERT(pucIE);

    prStaRec = cnmGetStaRecByIndex(prAdapter, prSwRfb->ucStaRecIdx);
    ASSERT(prStaRec);

	if (prStaRec == NULL) {
        return;
    }

    prStaRec->fgIsQoS = FALSE;

    pucIEStart = pucIE;

    DBGLOG(QM, TRACE, ("QM: (fgIsWmmSupported=%d, fgSupportQoS=%d)\n",
        prStaRec->fgIsWmmSupported, prAdapter->rWifiVar.ucQoS));

	/*                                                                                  */
	/*                                                                          */
	if (IS_FEATURE_DISABLED(prAdapter->rWifiVar.ucQoS)) {
        return;
    }

    /*                                                       */
	else {
        IE_FOR_EACH(pucIE, u2IELength, u2Offset) {
            switch (IE_ID(pucIE)) {
			case ELEM_ID_VENDOR:
                /*                        */
				mqmParseAssocRspWmmIe(pucIE, prStaRec);

                prStaRec->u4Flags = 0;
#if CFG_SUPPORT_MTK_SYNERGY                
                if (rlmParseCheckMTKOuiIE(prAdapter, pucIE, &u4Flags)) {
                    prStaRec->u4Flags = u4Flags;
                }
#endif

             break;

             case ELEM_ID_HT_CAP:
                /*                                                   */
				if (IE_LEN(pucIE) == (sizeof(IE_HT_CAP_T) - 2)) {
                    prStaRec->fgIsQoS = TRUE;
                }
                break;
            default:
                break;
            }
        }

        /*                                         */
		if ((prStaRec->fgIsQoS) && (prStaRec->eStaType == STA_TYPE_LEGACY_AP)) {
            mqmParseEdcaParameters(prAdapter, prSwRfb, pucIEStart, u2IELength, TRUE);
        }

        DBGLOG(QM, TRACE, ("MQM: Assoc_Rsp Parsing (QoS Enabled=%d)\n", prStaRec->fgIsQoS));
		if (prStaRec->fgIsWmmSupported) {
            nicQmUpdateWmmParms(prAdapter, prStaRec->ucBssIndex);
        }
    }
}

/*                                                                            */
/* 
        
 
            
 
              
*/
/*                                                                            */
VOID
mqmProcessBcn(IN P_ADAPTER_T prAdapter,
	      IN P_SW_RFB_T prSwRfb, IN PUINT_8 pucIE, IN UINT_16 u2IELength)
{
    P_BSS_INFO_T        prBssInfo;
    BOOLEAN             fgNewParameter;
    UINT_8              i;

    ASSERT(prAdapter);
    ASSERT(prSwRfb);
    ASSERT(pucIE);

	DBGLOG(QM, TRACE, ("Enter %s\n", __func__));

    fgNewParameter = FALSE;

    for (i = 0; i < BSS_INFO_NUM; i++) {
        prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, i);

        if (IS_BSS_ACTIVE(prBssInfo)) {
            if (prBssInfo->eCurrentOPMode == OP_MODE_INFRASTRUCTURE &&
                prBssInfo->eConnectionState == PARAM_MEDIA_STATE_CONNECTED) {
                /*                             */
                if (EQUAL_MAC_ADDR(prBssInfo->aucBSSID,
						   ((P_WLAN_MAC_MGMT_HEADER_T)
						    (prSwRfb->pvHeader))->aucBSSID)) {

                    fgNewParameter = mqmParseEdcaParameters(prAdapter,
										prSwRfb, pucIE,
										u2IELength, FALSE);
                }
            }

            /*                                  */
            if (fgNewParameter) {
				/*                                                                                   */
                nicQmUpdateWmmParms(prAdapter, prBssInfo->ucBssIndex);
                fgNewParameter = FALSE;
            }
        } /*                        */
    }
}

BOOLEAN
mqmUpdateEdcaParameters(IN P_BSS_INFO_T prBssInfo, IN PUINT_8 pucIE, 
    IN BOOLEAN fgForceOverride)
{
	P_AC_QUE_PARMS_T prAcQueParams;
	P_IE_WMM_PARAM_T prIeWmmParam;
	ENUM_WMM_ACI_T eAci;
    BOOLEAN fgNewParameter = FALSE;

    do {
    	if (IE_LEN(pucIE) != 24) {
    		break;	/*                                  */
    	}

    	prIeWmmParam = (P_IE_WMM_PARAM_T) pucIE;

    	/*                                                                                      */
    	if(!fgForceOverride) {       
    		if(mqmCompareEdcaParameters(prIeWmmParam, prBssInfo)) {
    			fgNewParameter = FALSE;
    			break;
    		}
    	}
        
    	fgNewParameter = TRUE;
    	/*                            */
    	prBssInfo->ucWmmParamSetCount = (prIeWmmParam->ucQosInfo & WMM_QOS_INFO_PARAM_SET_CNT);
    	/*                        */
    	for(eAci = 0; eAci < WMM_AC_INDEX_NUM; eAci++) {
    		prAcQueParams = &prBssInfo->arACQueParms[eAci];
    		mqmFillAcQueParam(prIeWmmParam, eAci, prAcQueParams);
    		DBGLOG(QM, INFO, ("BSS[%u]: eAci[%d] ACM[%d] Aifsn[%d] CWmin/max[%d/%d]" 
                "TxopLimit[%d] NewParameter[%d]\n", 
                prBssInfo->ucBssIndex, eAci, prAcQueParams->ucIsACMSet, prAcQueParams->u2Aifsn, 
                prAcQueParams->u2CWmin, prAcQueParams->u2CWmax, prAcQueParams->u2TxopLimit, fgNewParameter));
    	}
    }while(FALSE);

    return fgNewParameter;
}

/*                                                                            */
/* 
                                                        
 
                                               
                                                  
                                                                        
                                                                    
                                                                                         
 
              
*/
/*                                                                            */
BOOLEAN
mqmParseEdcaParameters(IN P_ADAPTER_T prAdapter,
    IN P_SW_RFB_T prSwRfb, IN PUINT_8 pucIE, IN UINT_16 u2IELength, 
    IN BOOLEAN fgForceOverride)
{
    P_STA_RECORD_T      prStaRec;
    UINT_16             u2Offset;
    UINT_8 aucWfaOui[] = VENDOR_OUI_WFA;
    P_BSS_INFO_T prBssInfo;
    BOOLEAN fgNewParameter = FALSE;

    DEBUGFUNC("mqmParseEdcaParameters");

	if (!prSwRfb) {
        return FALSE;
    }

	if (!pucIE) {
        return FALSE;
    }

    prStaRec = cnmGetStaRecByIndex(prAdapter, prSwRfb->ucStaRecIdx);
	/*                   */

	if (prStaRec == NULL) {
        return FALSE;
    }

    DBGLOG(QM, TRACE, ("QM: (fgIsWmmSupported=%d, fgIsQoS=%d)\n",
        prStaRec->fgIsWmmSupported, prStaRec->fgIsQoS));

	if (IS_FEATURE_DISABLED(prAdapter->rWifiVar.ucQoS) || (!prStaRec->fgIsWmmSupported)
	    || (!prStaRec->fgIsQoS)) {
        return FALSE;
    }

    prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prStaRec->ucBssIndex);

    /*                                  */
    IE_FOR_EACH(pucIE, u2IELength, u2Offset) {
        switch (IE_ID(pucIE)) {
        case ELEM_ID_WMM:
            if (!((WMM_IE_OUI_TYPE(pucIE) == VENDOR_OUI_TYPE_WMM) &&
                (!kalMemCmp(WMM_IE_OUI(pucIE), aucWfaOui, 3)))) {
                                break;
                            }                    
                        
			switch (WMM_IE_OUI_SUBTYPE(pucIE)) {
			case VENDOR_OUI_SUBTYPE_WMM_PARAM:
				fgNewParameter = mqmUpdateEdcaParameters(prBssInfo, pucIE, fgForceOverride);
                    break;

                default:
                    /*                           */
                    break;
                }

            /*                                                                 */
            break;
        default:
            break;
        }
    }

    return fgNewParameter;
}

BOOLEAN mqmCompareEdcaParameters(IN P_IE_WMM_PARAM_T prIeWmmParam, IN P_BSS_INFO_T prBssInfo)
{
    P_AC_QUE_PARMS_T prAcQueParams;
    P_WMM_AC_PARAM_T prWmmAcParams;
    ENUM_WMM_ACI_T eAci;

	/*               */

    /*                 */
	if (prBssInfo->ucWmmParamSetCount != (prIeWmmParam->ucQosInfo & WMM_QOS_INFO_PARAM_SET_CNT)) {
        return FALSE;
    }

	for (eAci = 0; eAci < WMM_AC_INDEX_NUM; eAci++) {
        prAcQueParams = &prBssInfo->arACQueParms[eAci];
        prWmmAcParams = &prIeWmmParam->arAcParam[eAci];

        /*     */
		if (prAcQueParams->ucIsACMSet !=
		    ((prWmmAcParams->ucAciAifsn & WMM_ACIAIFSN_ACM) ? TRUE : FALSE)) {
            return FALSE;
        }

        /*       */
		if (prAcQueParams->u2Aifsn != (prWmmAcParams->ucAciAifsn & WMM_ACIAIFSN_AIFSN)) {
            return FALSE;
        }

        /*        */
		if (prAcQueParams->u2CWmax !=
		    (BIT((prWmmAcParams->ucEcw & WMM_ECW_WMAX_MASK) >> WMM_ECW_WMAX_OFFSET) - 1)) {
            return FALSE;
        }

        /*        */
		if (prAcQueParams->u2CWmin != (BIT(prWmmAcParams->ucEcw & WMM_ECW_WMIN_MASK) - 1)) {
            return FALSE;
        }

		if (prAcQueParams->u2TxopLimit != prWmmAcParams->u2TxopLimit) {
            return FALSE;
        }
    }

    return TRUE;
}


/*                                                                            */
/* 
                                                                                            
 
                                                
                                                                    
                                                                               
                                                                                     
 
              
*/
/*                                                                            */
VOID
mqmFillAcQueParam(IN P_IE_WMM_PARAM_T prIeWmmParam,
		  IN UINT_32 u4AcOffset, OUT P_AC_QUE_PARMS_T prAcQueParams)
{
    P_WMM_AC_PARAM_T prAcParam = &prIeWmmParam->arAcParam[u4AcOffset];

    prAcQueParams->ucIsACMSet = (prAcParam->ucAciAifsn & WMM_ACIAIFSN_ACM) ? TRUE : FALSE;

    prAcQueParams->u2Aifsn = (prAcParam->ucAciAifsn & WMM_ACIAIFSN_AIFSN);

    prAcQueParams->u2CWmax =
        BIT((prAcParam->ucEcw & WMM_ECW_WMAX_MASK) >> WMM_ECW_WMAX_OFFSET) - 1;

	prAcQueParams->u2CWmin = BIT(prAcParam->ucEcw & WMM_ECW_WMIN_MASK) - 1;

    WLAN_GET_FIELD_16(&prAcParam->u2TxopLimit, &prAcQueParams->u2TxopLimit);

    prAcQueParams->ucGuradTime = TXM_DEFAULT_FLUSH_QUEUE_GUARD_TIME;

}


/*                                                                            */
/* 
                                                                         
 
                                            
                                                                                        
                                                                       
 
              
*/
/*                                                                            */
VOID
mqmProcessScanResult(IN P_ADAPTER_T prAdapter,
		     IN P_BSS_DESC_T prScanResult, OUT P_STA_RECORD_T prStaRec)
{
    PUINT_8     pucIE;
    UINT_16     u2IELength;
    UINT_16     u2Offset;
    UINT_8      aucWfaOui[] = VENDOR_OUI_WFA;
    BOOLEAN     fgIsHtVht;

    DEBUGFUNC("mqmProcessScanResult");

    ASSERT(prScanResult);
    ASSERT(prStaRec);

    /*                               */
    prStaRec->fgIsWmmSupported = FALSE;
    prStaRec->fgIsUapsdSupported = FALSE;
    prStaRec->fgIsQoS = FALSE;

    fgIsHtVht = FALSE;

	if (IS_FEATURE_DISABLED(prAdapter->rWifiVar.ucQoS)) {
        return;
    }

    u2IELength = prScanResult->u2IELength;
    pucIE = prScanResult->aucIEBuf;

    /*                                                            */
    IE_FOR_EACH(pucIE, u2IELength, u2Offset) {
        switch (IE_ID(pucIE)) {

        case ELEM_ID_EXTENDED_CAP:
#if CFG_SUPPORT_TDLS
            TdlsBssExtCapParse(prStaRec, pucIE);
#endif /*                  */
            break;

        case ELEM_ID_WMM:
			if ((WMM_IE_OUI_TYPE(pucIE) == VENDOR_OUI_TYPE_WMM) &&
			    (!kalMemCmp(WMM_IE_OUI(pucIE), aucWfaOui, 3))) {

				switch (WMM_IE_OUI_SUBTYPE(pucIE)) {
                case VENDOR_OUI_SUBTYPE_WMM_PARAM:
					if (IE_LEN(pucIE) != 24) {
                        break; /*                                  */
					} else {
                        prStaRec->fgIsWmmSupported = TRUE;
						prStaRec->fgIsUapsdSupported =
						    (((((P_IE_WMM_PARAM_T) pucIE)->
						       ucQosInfo) & WMM_QOS_INFO_UAPSD) ? TRUE :
						     FALSE);
                    }
                    break;

                case VENDOR_OUI_SUBTYPE_WMM_INFO:
					if (IE_LEN(pucIE) != 7) {
                        break; /*                                 */
					} else {
                        prStaRec->fgIsWmmSupported = TRUE;
						prStaRec->fgIsUapsdSupported =
						    (((((P_IE_WMM_INFO_T) pucIE)->
						       ucQosInfo) & WMM_QOS_INFO_UAPSD) ? TRUE :
						     FALSE);
                    }
                    break;

                default:
                    /*                                              */
                    break;
                }
            }
            /*                                                                 */

            break;

        default:
            /*                                          */
            break;
        }
    }

    /*                   */
	if (prStaRec->ucDesiredPhyTypeSet & (PHY_TYPE_SET_802_11N | PHY_TYPE_SET_802_11AC)) {
        fgIsHtVht = TRUE;
    }

	if (fgIsHtVht || prStaRec->fgIsWmmSupported) {
        prStaRec->fgIsQoS = TRUE;
    }
}


/*                                                                            */
/* 
                                          
 
                                       
                                
 
                
*/
/*                                                                            */
UINT_32
mqmFillWmmInfoIE(P_UINT_8 pucOutBuf,
    BOOLEAN                 fgSupportUAPSD,
		 UINT_8 ucBmpDeliveryAC, UINT_8 ucBmpTriggerAC, UINT_8 ucUapsdSp)
{
    P_IE_WMM_INFO_T prIeWmmInfo;
    UINT_32 ucUapsd[] = {
        WMM_QOS_INFO_BE_UAPSD,
        WMM_QOS_INFO_BK_UAPSD,
        WMM_QOS_INFO_VI_UAPSD,
        WMM_QOS_INFO_VO_UAPSD
    };
    UINT_8 aucWfaOui[] = VENDOR_OUI_WFA;

    ASSERT(pucOutBuf);

	prIeWmmInfo = (P_IE_WMM_INFO_T) pucOutBuf;

    prIeWmmInfo->ucId = ELEM_ID_WMM;
    prIeWmmInfo->ucLength = ELEM_MAX_LEN_WMM_INFO;

    /*                                                */
    prIeWmmInfo->aucOui[0] = aucWfaOui[0];
    prIeWmmInfo->aucOui[1] = aucWfaOui[1];
    prIeWmmInfo->aucOui[2] = aucWfaOui[2];
    prIeWmmInfo->ucOuiType = VENDOR_OUI_TYPE_WMM;
    prIeWmmInfo->ucOuiSubtype = VENDOR_OUI_SUBTYPE_WMM_INFO;

    prIeWmmInfo->ucVersion = VERSION_WMM;
    prIeWmmInfo->ucQosInfo = 0;

	/*                                                                  */
	if (fgSupportUAPSD) {
        UINT_8 ucQosInfo = 0;
        UINT_8 i;

        /*                       */
		for (i = ACI_BE; i <= ACI_VO; i++) {
			if (ucBmpDeliveryAC & ucBmpTriggerAC & BIT(i)) {
				ucQosInfo |= (UINT_8) ucUapsd[i];
            }
        }

        if (ucBmpDeliveryAC & ucBmpTriggerAC) {
            switch (ucUapsdSp) {
            case WMM_MAX_SP_LENGTH_ALL:
                ucQosInfo |= WMM_QOS_INFO_MAX_SP_ALL;
                break;

            case WMM_MAX_SP_LENGTH_2:
                ucQosInfo |= WMM_QOS_INFO_MAX_SP_2;
                break;

            case WMM_MAX_SP_LENGTH_4:
                ucQosInfo |= WMM_QOS_INFO_MAX_SP_4;
                break;

            case WMM_MAX_SP_LENGTH_6:
                ucQosInfo |= WMM_QOS_INFO_MAX_SP_6;
                break;

            default:
				DBGLOG(QM, INFO, ("MQM: Incorrect SP length\n"));
                ucQosInfo |= WMM_QOS_INFO_MAX_SP_2;
                break;
            }
        }
        prIeWmmInfo->ucQosInfo = ucQosInfo;

    }

    /*                                                                     */
    return IE_SIZE(prIeWmmInfo);
}


/*                                                                            */
/* 
                                 
 
                                       
                                
 
                
*/
/*                                                                            */
UINT_32
mqmGenerateWmmInfoIEByStaRec(P_ADAPTER_T prAdapter,
			     P_BSS_INFO_T prBssInfo, P_STA_RECORD_T prStaRec, P_UINT_8 pucOutBuf)
{
    P_PM_PROFILE_SETUP_INFO_T prPmProfSetupInfo;
    BOOLEAN fgSupportUapsd;

    ASSERT(pucOutBuf);

    /*                                              */
	if (IS_FEATURE_DISABLED(prAdapter->rWifiVar.ucQoS)) {
        return 0;
    }
    
	if (prStaRec == NULL) {
        return 0;
    }
    
	if (!prStaRec->fgIsWmmSupported) {
        return 0;
    }

    prPmProfSetupInfo = &prBssInfo->rPmProfSetupInfo;

	fgSupportUapsd = (IS_FEATURE_ENABLED(prAdapter->rWifiVar.ucUapsd)
			  && prStaRec->fgIsUapsdSupported);

	return mqmFillWmmInfoIE(pucOutBuf,
                fgSupportUapsd, 
                prPmProfSetupInfo->ucBmpDeliveryAC, 
				prPmProfSetupInfo->ucBmpTriggerAC, prPmProfSetupInfo->ucUapsdSp);
}

/*                                                                            */
/* 
                                 
 
                                       
                                
 
                
*/
/*                                                                            */
VOID mqmGenerateWmmInfoIE(IN P_ADAPTER_T prAdapter, IN P_MSDU_INFO_T prMsduInfo)
{
    P_BSS_INFO_T prBssInfo;
    P_STA_RECORD_T prStaRec;
    UINT_32 u4Length;

    DEBUGFUNC("mqmGenerateWmmInfoIE");

    ASSERT(prMsduInfo);

    /*                                              */
	if (IS_FEATURE_DISABLED(prAdapter->rWifiVar.ucQoS)) {
        return;
    }

    prStaRec = cnmGetStaRecByIndex(prAdapter, prMsduInfo->ucStaRecIndex);
    ASSERT(prStaRec);

	if (prStaRec == NULL) {
        return;
    }

	if (!prStaRec->fgIsWmmSupported) {
        return;
    }

    prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prStaRec->ucBssIndex);

	u4Length = mqmGenerateWmmInfoIEByStaRec(prAdapter,
                    prBssInfo, 
                    prStaRec, 
						((PUINT_8) prMsduInfo->prPacket +
						 prMsduInfo->u2FrameLength));

    prMsduInfo->u2FrameLength += u4Length;
}

/*                                                                            */
/* 
                                  
 
                                       
                                
 
                
*/
/*                                                                            */
VOID mqmGenerateWmmParamIE(IN P_ADAPTER_T prAdapter, IN P_MSDU_INFO_T prMsduInfo)
{
    P_IE_WMM_PARAM_T prIeWmmParam;

    UINT_8 aucWfaOui[] = VENDOR_OUI_WFA;

    UINT_8 aucACI[] = {
        WMM_ACI_AC_BE,
        WMM_ACI_AC_BK,
        WMM_ACI_AC_VI,
        WMM_ACI_AC_VO
    };

    P_BSS_INFO_T prBssInfo;
    P_STA_RECORD_T prStaRec;
    ENUM_WMM_ACI_T eAci;
    P_WMM_AC_PARAM_T prAcParam;

    DEBUGFUNC("mqmGenerateWmmParamIE");
	DBGLOG(QM, LOUD, ("\n"));

    ASSERT(prMsduInfo);

    /*                                              */
	if (IS_FEATURE_DISABLED(prAdapter->rWifiVar.ucQoS)) {
        return;
    }

    prStaRec = cnmGetStaRecByIndex(prAdapter, prMsduInfo->ucStaRecIndex);

	if (prStaRec) {
		if (!prStaRec->fgIsQoS) {
            return;
        }
    }

    prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prMsduInfo->ucBssIndex);

	if (!prBssInfo->fgIsQBSS) {
        return; 
    }

    prIeWmmParam = (P_IE_WMM_PARAM_T)
            ((PUINT_8) prMsduInfo->prPacket + prMsduInfo->u2FrameLength);

    prIeWmmParam->ucId = ELEM_ID_WMM;
    prIeWmmParam->ucLength = ELEM_MAX_LEN_WMM_PARAM;

    /*                                                */
    prIeWmmParam->aucOui[0] = aucWfaOui[0];
    prIeWmmParam->aucOui[1] = aucWfaOui[1];
    prIeWmmParam->aucOui[2] = aucWfaOui[2];
    prIeWmmParam->ucOuiType = VENDOR_OUI_TYPE_WMM;
    prIeWmmParam->ucOuiSubtype = VENDOR_OUI_SUBTYPE_WMM_PARAM;

    prIeWmmParam->ucVersion = VERSION_WMM;
    prIeWmmParam->ucQosInfo = (prBssInfo->ucWmmParamSetCount & WMM_QOS_INFO_PARAM_SET_CNT);

	/*                                                                  */
	if (IS_FEATURE_ENABLED(prAdapter->rWifiVar.ucUapsd)) {
        prIeWmmParam->ucQosInfo |=  WMM_QOS_INFO_UAPSD;
    }

    /*                */

	for (eAci = 0; eAci < WMM_AC_INDEX_NUM; eAci++) {
        prAcParam = &prIeWmmParam->arAcParam[eAci];

		/*                                                                                                     */
		/*                                                         */
		/*                                                */
		/*                                                */
		/*                                                */
		/*                                                      */

        /*     */
        prAcParam->ucAciAifsn = aucACI[eAci];
        /*     */
		if (prBssInfo->arACQueParmsForBcast[eAci].ucIsACMSet) {
            prAcParam->ucAciAifsn |= WMM_ACIAIFSN_ACM;
        }
        /*       */
		prAcParam->ucAciAifsn |=
		    (prBssInfo->arACQueParmsForBcast[eAci].u2Aifsn & WMM_ACIAIFSN_AIFSN);

        /*         */
        prAcParam->ucEcw = (prBssInfo->aucCWminLog2ForBcast[eAci] & WMM_ECW_WMIN_MASK);
        /*         */
		prAcParam->ucEcw |=
		    ((prBssInfo->
		      aucCWmaxLog2ForBcast[eAci] << WMM_ECW_WMAX_OFFSET) & WMM_ECW_WMAX_MASK);
        
        /*            */
		WLAN_SET_FIELD_16(&prAcParam->u2TxopLimit,
				  prBssInfo->arACQueParmsForBcast[eAci].u2TxopLimit);

    }

    /*                                                                     */
    prMsduInfo->u2FrameLength += IE_SIZE(prIeWmmParam);

}


#if CFG_SUPPORT_TDLS
/*                                                                            */
/* 
                                  
 
                                       
                                
 
                
*/
/*                                                                            */
UINT_32 mqmGenerateWmmParamIEByParam(P_ADAPTER_T prAdapter, P_BSS_INFO_T prBssInfo, PUINT_8 pOutBuf)
{
    P_IE_WMM_PARAM_T prIeWmmParam;

    UINT_8 aucWfaOui[] = VENDOR_OUI_WFA;

    UINT_8 aucACI[] = {
        WMM_ACI_AC_BE,
        WMM_ACI_AC_BK,
        WMM_ACI_AC_VI,
        WMM_ACI_AC_VO
    };

    ENUM_WMM_ACI_T eAci;
    P_WMM_AC_PARAM_T prAcParam;

    DEBUGFUNC("mqmGenerateWmmParamIE");
	DBGLOG(QM, LOUD, ("\n"));

    ASSERT(pOutBuf);


    /*                                              */
	if (IS_FEATURE_DISABLED(prAdapter->rWifiVar.ucQoS)) {
        return WLAN_STATUS_SUCCESS;
    }


	if (!prBssInfo->fgIsQBSS) {
        return WLAN_STATUS_SUCCESS; 
    }



	prIeWmmParam = (P_IE_WMM_PARAM_T) pOutBuf;


    prIeWmmParam->ucId = ELEM_ID_WMM;
    prIeWmmParam->ucLength = ELEM_MAX_LEN_WMM_PARAM;

    /*                                                */
    prIeWmmParam->aucOui[0] = aucWfaOui[0];
    prIeWmmParam->aucOui[1] = aucWfaOui[1];
    prIeWmmParam->aucOui[2] = aucWfaOui[2];
    prIeWmmParam->ucOuiType = VENDOR_OUI_TYPE_WMM;
    prIeWmmParam->ucOuiSubtype = VENDOR_OUI_SUBTYPE_WMM_PARAM;

    prIeWmmParam->ucVersion = VERSION_WMM;
    prIeWmmParam->ucQosInfo = (prBssInfo->ucWmmParamSetCount & WMM_QOS_INFO_PARAM_SET_CNT);

	/*                                                                  */
	if (IS_FEATURE_ENABLED(prAdapter->rWifiVar.ucUapsd)) {
        prIeWmmParam->ucQosInfo |=  WMM_QOS_INFO_UAPSD;
    }

    /*                */

	for (eAci = 0; eAci < WMM_AC_INDEX_NUM; eAci++) {
        prAcParam = &prIeWmmParam->arAcParam[eAci];

		/*                                                                                                     */
		/*                                                         */
		/*                                                */
		/*                                                */
		/*                                                */
		/*                                                      */

        /*     */
        prAcParam->ucAciAifsn = aucACI[eAci];
        /*     */
		if (prBssInfo->arACQueParmsForBcast[eAci].ucIsACMSet) {
            prAcParam->ucAciAifsn |= WMM_ACIAIFSN_ACM;
        }
        /*       */
		prAcParam->ucAciAifsn |=
		    (prBssInfo->arACQueParmsForBcast[eAci].u2Aifsn & WMM_ACIAIFSN_AIFSN);

        /*         */
        prAcParam->ucEcw = (prBssInfo->aucCWminLog2ForBcast[eAci] & WMM_ECW_WMIN_MASK);
        /*         */
		prAcParam->ucEcw |=
		    ((prBssInfo->
		      aucCWmaxLog2ForBcast[eAci] << WMM_ECW_WMAX_OFFSET) & WMM_ECW_WMAX_MASK);
        
        /*            */
		WLAN_SET_FIELD_16(&prAcParam->u2TxopLimit,
				  prBssInfo->arACQueParmsForBcast[eAci].u2TxopLimit);

    }

    /*                                                                     */
	return IE_SIZE(prIeWmmParam);


}


#endif

ENUM_FRAME_ACTION_T
qmGetFrameAction(IN P_ADAPTER_T prAdapter,
    IN UINT_8                       ucBssIndex,
    IN UINT_8                       ucStaRecIdx,
		 IN P_MSDU_INFO_T prMsduInfo, IN ENUM_FRAME_TYPE_IN_CMD_Q_T eFrameType)
{
    ENUM_FRAME_ACTION_T eFrameAction = FRAME_ACTION_TX_PKT;
    P_BSS_INFO_T   prBssInfo;
    P_STA_RECORD_T prStaRec;
	/*                                  */
	/*                               */

    DEBUGFUNC("qmGetFrameAction");

    prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, ucBssIndex);
    prStaRec = QM_GET_STA_REC_PTR_FROM_INDEX(prAdapter, ucStaRecIdx);

    do {
		/*                              */
		if (prMsduInfo) {
			if (prMsduInfo->ucControlFlag & MSDU_CONTROL_FLAG_FORCE_TX) {
                eFrameAction = FRAME_ACTION_TX_PKT;
                break;
            }
        }
		/*                                */
		if (!IS_BSS_ACTIVE(prBssInfo)) {
			DBGLOG(QM, TRACE,
			       ("Drop packets (BSS[%u] is INACTIVE)\n", prBssInfo->ucBssIndex));
            eFrameAction = FRAME_ACTION_DROP_PKT;
            break;
        }
		/*                             */
		if (prStaRec) {
			/*                                       */
			if (!prStaRec->fgIsInUse) {
				DBGLOG(QM, TRACE,
				       ("Drop packets (Sta[%u] not in USE)\n", prStaRec->ucIndex));
                eFrameAction = FRAME_ACTION_DROP_PKT;
                break;                
            }
			/*                   */
			if (prStaRec->fgIsInPS) {
				/*                                     */
				if (nicTxGetResource
				    (prAdapter,
				     nicTxGetFrameResourceType(eFrameType,
							       prMsduInfo)) >=
				    QM_MGMT_QUEUED_THRESHOLD) {
                    eFrameAction = FRAME_ACTION_TX_PKT;
                    break;
                }
				/*                                            */
                else {
					DBGLOG(QM, TRACE,
					       ("Queue packets (Sta[%u] in PS)\n",
						prStaRec->ucIndex));
                    eFrameAction = FRAME_ACTION_QUEUE_PKT;
                    break;
                }
            }
        }
		/*                               */
		if (prBssInfo->fgIsNetAbsent) {
			DBGLOG(QM, TRACE,
			       ("Queue packets (BSS[%u] Absent)\n", prBssInfo->ucBssIndex));
            eFrameAction = FRAME_ACTION_QUEUE_PKT;
            break;
        }
        
	} while (FALSE);

    return eFrameAction;
}


/*                                                                            */
/* 
                                                      
 
                                      
                                                 
 
                
*/
/*                                                                            */
VOID qmHandleEventBssAbsencePresence(IN P_ADAPTER_T prAdapter, IN P_WIFI_EVENT_T prEvent)
{
    P_EVENT_BSS_ABSENCE_PRESENCE_T prEventBssStatus;
    P_BSS_INFO_T prBssInfo;
    BOOLEAN fgIsNetAbsentOld;

	prEventBssStatus = (P_EVENT_BSS_ABSENCE_PRESENCE_T) prEvent;
    prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prEventBssStatus->ucBssIndex);
    fgIsNetAbsentOld = prBssInfo->fgIsNetAbsent;
    prBssInfo->fgIsNetAbsent = prEventBssStatus->ucIsAbsent;
    prBssInfo->ucBssFreeQuota = prEventBssStatus->ucBssFreeQuota;

	/*                                                                                                        */
	/*                                                                                        */

    DBGLOG(QM, INFO, ("NAF=%d,%d,%d\n",
			  prEventBssStatus->ucBssIndex, prBssInfo->fgIsNetAbsent,
			  prBssInfo->ucBssFreeQuota));

	if (!prBssInfo->fgIsNetAbsent) {
		QM_DBG_CNT_INC(&(prAdapter->rQM), QM_DBG_CNT_27);
	} else {
		QM_DBG_CNT_INC(&(prAdapter->rQM), QM_DBG_CNT_28);
    }
    /*                        */
	if ((fgIsNetAbsentOld) && (!prBssInfo->fgIsNetAbsent)) {
        kalSetEvent(prAdapter->prGlueInfo);
    }
}


/*                                                                            */
/* 
                                                    
 
                                      
                                                 
 
                
*/
/*                                                                            */
VOID qmHandleEventStaChangePsMode(IN P_ADAPTER_T prAdapter, IN P_WIFI_EVENT_T prEvent)
{
    P_EVENT_STA_CHANGE_PS_MODE_T prEventStaChangePsMode;
    P_STA_RECORD_T prStaRec;
    BOOLEAN fgIsInPSOld;

	/*                               */

	prEventStaChangePsMode = (P_EVENT_STA_CHANGE_PS_MODE_T) prEvent;
    prStaRec = QM_GET_STA_REC_PTR_FROM_INDEX(prAdapter, prEventStaChangePsMode->ucStaRecIdx);
	/*                   */

	if (prStaRec) {

        fgIsInPSOld = prStaRec->fgIsInPS;
        prStaRec->fgIsInPS = prEventStaChangePsMode->ucIsInPs;

		qmUpdateFreeQuota(prAdapter,
                    prStaRec,
                    prEventStaChangePsMode->ucUpdateMode,
                    prEventStaChangePsMode->ucFreeQuota);

		/*                                                                                    */
		/*                                                            */


        DBGLOG(QM, INFO, ("PS=%d,%d\n",
            prEventStaChangePsMode->ucStaRecIdx, prStaRec->fgIsInPS));

        /*                  */
		if ((fgIsInPSOld) && (!prStaRec->fgIsInPS)) {
            kalSetEvent(prAdapter->prGlueInfo);
        }
    }
}

/*                                                                            */
/* 
                                            
 
                                      
                                                 
 
                
*/
/*                                                                            */
VOID qmHandleEventStaUpdateFreeQuota(IN P_ADAPTER_T prAdapter, IN P_WIFI_EVENT_T prEvent)
{
    P_EVENT_STA_UPDATE_FREE_QUOTA_T prEventStaUpdateFreeQuota;
    P_STA_RECORD_T prStaRec;


	prEventStaUpdateFreeQuota = (P_EVENT_STA_UPDATE_FREE_QUOTA_T) prEvent;
    prStaRec = QM_GET_STA_REC_PTR_FROM_INDEX(prAdapter, prEventStaUpdateFreeQuota->ucStaRecIdx);
    /*           
                                              
         */
	/*                   */

	if (prStaRec) {
		if (prStaRec->fgIsInPS) {
			qmUpdateFreeQuota(prAdapter,
                    prStaRec,
                    prEventStaUpdateFreeQuota->ucUpdateMode,
                    prEventStaUpdateFreeQuota->ucFreeQuota);

            kalSetEvent(prAdapter->prGlueInfo);
        }
#if 0
		DBGLOG(QM, TRACE,
		       ("qmHandleEventStaUpdateFreeQuota (ucStaRecIdx=%d, ucUpdateMode=%d, ucFreeQuota=%d)\n",
            prEventStaUpdateFreeQuota->ucStaRecIdx,
            prEventStaUpdateFreeQuota->ucUpdateMode,
            prEventStaUpdateFreeQuota->ucFreeQuota));
#endif

        DBGLOG(QM, TRACE, ("UFQ=%d,%d,%d\n",
            prEventStaUpdateFreeQuota->ucStaRecIdx,
            prEventStaUpdateFreeQuota->ucUpdateMode,
            prEventStaUpdateFreeQuota->ucFreeQuota));


    }

}


/*                                                                            */
/* 
                              
 
                             
                                                         
                                              
 
                
*/
/*                                                                            */
VOID
qmUpdateFreeQuota(IN P_ADAPTER_T prAdapter,
		  IN P_STA_RECORD_T prStaRec, IN UINT_8 ucUpdateMode, IN UINT_8 ucFreeQuota)
{

    UINT_8 ucFreeQuotaForNonDelivery;
    UINT_8 ucFreeQuotaForDelivery;

    ASSERT(prStaRec);
    DBGLOG(QM, LOUD, ("qmUpdateFreeQuota orig ucFreeQuota=%d Mode %u New %u\n",
			  prStaRec->ucFreeQuota, ucUpdateMode, ucFreeQuota));

	if (!prStaRec->fgIsInPS)
		return;

    switch (ucUpdateMode) {
        case FREE_QUOTA_UPDATE_MODE_INIT:
        case FREE_QUOTA_UPDATE_MODE_OVERWRITE:
                prStaRec->ucFreeQuota = ucFreeQuota;
                break;
        case FREE_QUOTA_UPDATE_MODE_INCREASE:
                prStaRec->ucFreeQuota += ucFreeQuota;
                break;
        case FREE_QUOTA_UPDATE_MODE_DECREASE:
                prStaRec->ucFreeQuota -= ucFreeQuota;
                break;
        default:
            ASSERT(0);
    }

	DBGLOG(QM, LOUD, ("qmUpdateFreeQuota new ucFreeQuota=%d)\n", prStaRec->ucFreeQuota));

    ucFreeQuota = prStaRec->ucFreeQuota;

    ucFreeQuotaForNonDelivery = 0;
    ucFreeQuotaForDelivery = 0;

	if (ucFreeQuota > 0) {
		if (prStaRec->fgIsQoS && prStaRec->fgIsUapsdSupported
               /*                                    
                                               */) {
        /*                                                                               */

			if (prStaRec->ucFreeQuotaForNonDelivery > 0
			    && prStaRec->ucFreeQuotaForDelivery > 0) {
				ucFreeQuotaForNonDelivery = ucFreeQuota >> 1;
                ucFreeQuotaForDelivery =  ucFreeQuota - ucFreeQuotaForNonDelivery;
			} else if (prStaRec->ucFreeQuotaForNonDelivery == 0
				   && prStaRec->ucFreeQuotaForDelivery == 0) {
				ucFreeQuotaForNonDelivery = ucFreeQuota >> 1;
                  ucFreeQuotaForDelivery =  ucFreeQuota - ucFreeQuotaForNonDelivery;
			} else if (prStaRec->ucFreeQuotaForNonDelivery > 0) {
                /*                         */
				if (ucFreeQuota >= 3) {
                    ucFreeQuotaForNonDelivery = 2;
					ucFreeQuotaForDelivery =
					    ucFreeQuota - ucFreeQuotaForNonDelivery;
				} else {
                    ucFreeQuotaForDelivery = ucFreeQuota;
                    ucFreeQuotaForNonDelivery = 0;
                }
			} else if (prStaRec->ucFreeQuotaForDelivery > 0) {
                /*                      */
				if (ucFreeQuota >= 3) {
                    ucFreeQuotaForDelivery = 2;
					ucFreeQuotaForNonDelivery =
					    ucFreeQuota - ucFreeQuotaForDelivery;
				} else {
                    ucFreeQuotaForNonDelivery = ucFreeQuota;
                    ucFreeQuotaForDelivery = 0;
                }
            }

		} else {
            /*                               */
            ucFreeQuotaForNonDelivery = ucFreeQuota;
            ucFreeQuotaForDelivery = 0;
        }
	}
	/*                 */
    prStaRec->ucFreeQuotaForDelivery =  ucFreeQuotaForDelivery;
    prStaRec->ucFreeQuotaForNonDelivery =  ucFreeQuotaForNonDelivery;

    DBGLOG(QM, LOUD, ("new QuotaForDelivery = %d  QuotaForNonDelivery = %d\n",
			  prStaRec->ucFreeQuotaForDelivery, prStaRec->ucFreeQuotaForNonDelivery));

}

/*                                                                            */
/* 
                                             
 
                   
 
                                         
*/
/*                                                                            */
UINT_32 qmGetRxReorderQueuedBufferCount(IN P_ADAPTER_T prAdapter)
{
    UINT_32 i, u4Total;
    P_QUE_MGT_T prQM = &prAdapter->rQM;
    u4Total = 0;
    /*                                              */
	for (i = 0; i < CFG_NUM_OF_RX_BA_AGREEMENTS; i++) {
        u4Total += prQM->arRxBaTable[i].rReOrderQue.u4NumElem;
#if DBG && 0
		if (QUEUE_IS_EMPTY(&(prQM->arRxBaTable[i].rReOrderQue))) {
            ASSERT(prQM->arRxBaTable[i].rReOrderQue == 0);
        }
#endif
    }
	ASSERT(u4Total <= (CFG_NUM_OF_QM_RX_PKT_NUM * 2));
   return u4Total;
}

/*                                                                            */
/* 
                                  
 
                   
 
                
*/
/*                                                                            */
VOID qmDumpQueueStatus(IN P_ADAPTER_T prAdapter)
{
    P_TX_CTRL_T         prTxCtrl;
    P_QUE_MGT_T         prQM;
    P_GLUE_INFO_T       prGlueInfo;
    UINT_32             i;
    UINT_32             u4TotalBufferCount, u4TotalPageCount, u4CurBufferCount, u4CurPageCount;

	DEBUGFUNC(("%s", __func__));

    prTxCtrl = &prAdapter->rTxCtrl;
    prQM = &prAdapter->rQM;
    prGlueInfo = prAdapter->prGlueInfo;
    u4TotalBufferCount = 0;
    u4TotalPageCount = 0;
    u4CurBufferCount = 0;
    u4CurPageCount = 0;

    DBGLOG(SW4, INFO, ("\n------<Dump QUEUE Status>------\n"));    

    for(i = TC0_INDEX; i < TC_NUM; i++) {
        DBGLOG(SW4, INFO, ("TC%u ResCount: Max[%02u/%03u] Free[%02u/%03u]\n",
                i,
                prTxCtrl->rTc.au2MaxNumOfBuffer[i],
                prTxCtrl->rTc.au2MaxNumOfPage[i],
                prTxCtrl->rTc.au2FreeBufferCount[i],
                prTxCtrl->rTc.au2FreePageCount[i]));

        u4TotalBufferCount += prTxCtrl->rTc.au2MaxNumOfBuffer[i];
        u4TotalPageCount += prTxCtrl->rTc.au2MaxNumOfPage[i];
        u4CurBufferCount += prTxCtrl->rTc.au2FreeBufferCount[i];
        u4CurPageCount += prTxCtrl->rTc.au2FreePageCount[i];
    }

    DBGLOG(SW4, INFO, ("ToT ResCount: Max[%02u/%03u] Free[%02u/%03u]\n",
			   u4TotalBufferCount, u4TotalPageCount, u4CurBufferCount, u4CurPageCount));

    DBGLOG(SW4, INFO, ("---------------------------------\n"));

#if QM_ADAPTIVE_TC_RESOURCE_CTRL
    for(i = TC0_INDEX; i < TC_NUM; i++) {

        DBGLOG(SW4, INFO,("TC%u AvgQLen[%04u] minRsv[%02u] CurTcRes[%02u] GrtdTcRes[%02u]\n",
            i,
            QM_GET_TX_QUEUE_LEN(prAdapter, i),
            prQM->au4MinReservedTcResource[i],
            prQM->au4CurrentTcResource[i],
            prQM->au4GuaranteedTcResource[i]));
    }    

    DBGLOG(SW4, INFO,("Resource Residual[%u] ExtraRsv[%u]\n",
        prQM->u4ResidualTcResource,
        prQM->u4ExtraReservedTcResource));    
    DBGLOG(SW4, INFO,("QueLenMovingAvg[%u] Time2AdjResource[%u] Time2UpdateQLen[%u]\n",
        prQM->u4QueLenMovingAverage,
        prQM->u4TimeToAdjustTcResource,
        prQM->u4TimeToUpdateQueLen));     
#endif

    DBGLOG(SW4, INFO, ("---------------------------------\n"));

#if QM_FORWARDING_FAIRNESS
	for (i = 0; i < NUM_OF_PER_STA_TX_QUEUES; i++) {
		DBGLOG(SW4, INFO,
		       ("TC%u HeadSta[%u] ResourceUsedCount[%u]\n", i, prQM->au4HeadStaRecIndex[i],
			prQM->au4ResourceUsedCount[i]));
    }
#endif

    DBGLOG(SW4, INFO, ("BMC or unknown TxQueue Len[%u]\n", prQM->arTxQueue[0].u4NumElem));
	DBGLOG(SW4, INFO,
	       ("Pending QLen Normal[%u] Sec[%u]\n", prGlueInfo->i4TxPendingFrameNum,
		prGlueInfo->i4TxPendingSecurityFrameNum));
    
#if defined(LINUX)
	for (i = 0; i < HW_BSSID_NUM; i++) {
        DBGLOG(SW4, INFO, ("Pending BSS[%u] QLen[%u:%u:%u:%u]\n", 
            i, 
            prGlueInfo->ai4TxPendingFrameNumPerQueue[i][0],
            prGlueInfo->ai4TxPendingFrameNumPerQueue[i][1],
            prGlueInfo->ai4TxPendingFrameNumPerQueue[i][2],
            prGlueInfo->ai4TxPendingFrameNumPerQueue[i][3]));
    }
#endif
    DBGLOG(SW4, INFO, ("Pending FWD CNT[%d]\n", prTxCtrl->i4PendingFwdFrameCount));
    DBGLOG(SW4, INFO, ("Pending MGMT CNT[%d]\n", prTxCtrl->i4TxMgmtPendingNum));

    DBGLOG(SW4, INFO, ("---------------------------------\n"));

    DBGLOG(SW4, INFO, ("Total RFB[%u]\n", CFG_RX_MAX_PKT_NUM));
    DBGLOG(SW4, INFO, ("rFreeSwRfbList[%u]\n", prAdapter->rRxCtrl.rFreeSwRfbList.u4NumElem));
	DBGLOG(SW4, INFO,
	       ("rReceivedRfbList[%u]\n", prAdapter->rRxCtrl.rReceivedRfbList.u4NumElem));
	DBGLOG(SW4, INFO,
	       ("rIndicatedRfbList[%u]\n", prAdapter->rRxCtrl.rIndicatedRfbList.u4NumElem));
    DBGLOG(SW4, INFO, ("ucNumIndPacket[%u]\n", prAdapter->rRxCtrl.ucNumIndPacket));
    DBGLOG(SW4, INFO, ("ucNumRetainedPacket[%u]\n", prAdapter->rRxCtrl.ucNumRetainedPacket));

    DBGLOG(SW4, INFO, ("---------------------------------\n"));
    DBGLOG(SW4, INFO, ("CMD: FreeCmd[%u/%u] PendingCmd[%u] Cmd2Tx[%u]\n", 
        prAdapter->rFreeCmdList.u4NumElem,
        CFG_TX_MAX_CMD_PKT_NUM,
			   prAdapter->rPendingCmdQueue.u4NumElem, prGlueInfo->rCmdQueue.u4NumElem));
    DBGLOG(SW4, INFO, ("MGMT: FreeMgmt[%u/%u] PendingMgmt[%u]\n",
        prAdapter->rTxCtrl.rFreeMsduInfoList.u4NumElem,
			   CFG_TX_MAX_PKT_NUM, prAdapter->rTxCtrl.rTxMgmtTxingQueue.u4NumElem));
    
    
    DBGLOG(SW4, INFO, ("---------------------------------\n\n"));
}





#if CFG_M0VE_BA_TO_DRIVER
/*                                                                            */
/* 
                                
 
                                                                   
                                                              
                                  
                                                                 
 
                
*/
/*                                                                            */
VOID
mqmSendDelBaFrame(IN P_ADAPTER_T prAdapter,
    IN BOOLEAN                  fgIsInitiator,
		  IN P_STA_RECORD_T prStaRec, IN UINT_32 u4Tid, IN UINT_32 u4ReasonCode)
{

    P_MSDU_INFO_T prTxMsduInfo;
    P_ACTION_DELBA_FRAME_T prDelBaFrame;
    P_BSS_INFO_T prBssInfo;

    DBGLOG(QM, WARN, ("[Puff]: Enter mqmSendDelBaFrame()\n"));

    ASSERT(prStaRec);

	/*                                                */
	if (!prStaRec->fgIsInUse) {
        DBGLOG(QM, WARN, ("[Puff][%s]: (Warning) sta_rec is not inuse\n", __func__));
        return;
    }
    /*                       */
	if (!(prStaRec->ucDesiredPhyTypeSet & PHY_TYPE_BIT_HT)) {
		DBGLOG(QM, WARN,
		       ("[Puff][%s]: (Warning) sta is NOT HT-capable(0x%08X)\n", __func__,
			prStaRec->ucDesiredPhyTypeSet));
        return; 
    }
	/*                                 */
	prTxMsduInfo = (P_MSDU_INFO_T) cnmMgtPktAlloc(prAdapter, ACTION_DELBA_FRAME_LEN);

	if (!prTxMsduInfo) {
		DBGLOG(QM, WARN,
		       ("[Puff][%s]: (Warning) DELBA for TID=%ld was not sent (MSDU_INFO alloc failure)\n",
			__func__, u4Tid));
        return;
    }

    prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prStaRec->ucBssIndex);

    /*                       */
	prDelBaFrame =
	    (P_ACTION_DELBA_FRAME_T) ((UINT_32) (prTxMsduInfo->prPacket) + MAC_TX_RESERVED_FIELD);
    prDelBaFrame->u2FrameCtrl   = MAC_FRAME_ACTION;
#if CFG_SUPPORT_802_11W
    if (rsnCheckBipKeyInstalled(prAdapter, prStaRec)) {
		DBGLOG(QM, WARN, ("[Puff][%s]: (Warning) DELBA is 80211w enabled\n", __func__));
        prDelBaFrame->u2FrameCtrl |= MASK_FC_PROTECTED_FRAME;
    }
#endif

    prDelBaFrame->u2DurationID  = 0;
    prDelBaFrame->ucCategory    = CATEGORY_BLOCK_ACK_ACTION;
    prDelBaFrame->ucAction      = ACTION_DELBA;

    prDelBaFrame->u2DelBaParameterSet = 0;
	prDelBaFrame->u2DelBaParameterSet |= ((fgIsInitiator ? ACTION_DELBA_INITIATOR_MASK : 0));
	prDelBaFrame->u2DelBaParameterSet |=
	    ((u4Tid << ACTION_DELBA_TID_OFFSET) & ACTION_DELBA_TID_MASK);
    prDelBaFrame->u2ReasonCode = u4ReasonCode;

	COPY_MAC_ADDR(prDelBaFrame->aucDestAddr, prStaRec->aucMacAddr);
	COPY_MAC_ADDR(prDelBaFrame->aucSrcAddr, prBssInfo->aucOwnMacAddr);
	COPY_MAC_ADDR(prDelBaFrame->aucBSSID, prBssInfo->aucBSSID);

	/*                                                     */
	TX_SET_MMPDU(prAdapter,
        prTxMsduInfo,
        prStaRec->ucBssIndex,
		     (prStaRec != NULL) ? (prStaRec->ucIndex) : (STA_REC_INDEX_NOT_FOUND),
		     WLAN_MAC_HEADER_LEN, ACTION_DELBA_FRAME_LEN, NULL, MSDU_RATE_MODE_AUTO);

#if CFG_SUPPORT_802_11W
    if (rsnCheckBipKeyInstalled(prAdapter, prStaRec)) {
		DBGLOG(RSN, INFO, ("Set MSDU_OPT_PROTECTED_FRAME\n"));
        nicTxConfigPktOption(prTxMsduInfo, MSDU_OPT_PROTECTED_FRAME, TRUE);
    }
#endif
    
    /*                                                                             */
	prTxMsduInfo->ucTID = (UINT_8) u4Tid;
	prTxMsduInfo->ucControlFlag = (fgIsInitiator ? 1 : 0);

    nicTxEnqueueMsdu(prAdapter, prTxMsduInfo);

	DBGLOG(QM, WARN,
	       ("[Puff][%s]: Send DELBA for TID=%ld Initiator=%d\n", __func__, u4Tid,
		fgIsInitiator));
}


/*                                                                            */
/* 
                                                                 
 
                                 
                                                            
 
                                                                                         
*/
/*                                                                            */
WLAN_STATUS
mqmCallbackAddBaRspSent(IN P_ADAPTER_T prAdapter,
			IN P_MSDU_INFO_T prMsduInfo, IN ENUM_TX_RESULT_CODE_T rTxDoneStatus)
{
    P_RX_BA_ENTRY_T                 prRxBaEntry;
    P_STA_RECORD_T                  prStaRec;
    P_QUE_MGT_T                     prQM;
    
    UINT_32 u4Tid = 0;

	/*                     */
    prStaRec = cnmGetStaRecByIndex(prAdapter, prMsduInfo->ucStaRecIndex);
    ASSERT(prStaRec);
    
    prQM = &prAdapter->rQM;

    DBGLOG(QM, WARN, ("[Puff]: Enter mqmCallbackAddBaRspSent()\n"));

	/*                            */
    /*                        */
	if (!prStaRec->fgIsInUse) {
        DBGLOG(QM, WARN, ("[Puff][%s]: (Warning) sta_rec is not inuse\n", __func__));
        return WLAN_STATUS_SUCCESS;
    }
    /*                       */
	if (!(prStaRec->ucDesiredPhyTypeSet & PHY_TYPE_BIT_HT)) {
		DBGLOG(QM, WARN,
		       ("[Puff][%s]: (Warning) sta is NOT HT-capable(0x%08X)\n", __func__,
			prStaRec->ucDesiredPhyTypeSet));
        return WLAN_STATUS_SUCCESS; /*                                         */
    }
	/*                                       */
    u4Tid = prMsduInfo->ucTID; /*                                                               */
    prRxBaEntry = &prQM->arRxBaTable[u4Tid];

    /*                                                                                                 */
	/*                     */
	if (!prRxBaEntry) {
		DBGLOG(QM, WARN,
		       ("[Puff][%s]: (RX_BA) ADDBA_RSP ---> peer (STA=%d TID=%d)(TX successful)(invalid BA)\n",
            __func__, prStaRec->ucIndex, u4Tid));
    }
	/*                                       */
	else {
		switch (rTxDoneStatus) {
			/*                       */
        case TX_RESULT_SUCCESS:

			DBGLOG(QM, WARN,
			       ("[Puff][%s]: (RX_BA) ADDBA_RSP ---> peer (STA=%d TID=%d)(TX successful)\n",
                __func__, prStaRec->ucIndex, u4Tid));


			/*                                   */
			if (prRxBaEntry->ucStatus != BA_ENTRY_STATUS_DELETING) {
				mqmRxModifyBaEntryStatus(prAdapter, prRxBaEntry,
							 BA_ENTRY_STATUS_ACTIVE);
            }
			/*                             */
			/*      */
            /*                                                                             */

            break;

			/*                       */
        default:

			DBGLOG(QM, WARN,
			       ("[Puff][%s]: (RX_BA) ADDBA_RSP ---> peer (STA=%d TID=%ld Entry_Status=%d)(TX failed)\n",
                __func__, prStaRec->ucIndex, u4Tid, prRxBaEntry->ucStatus));

			/*                                   */
            /*                                         */
			if (prRxBaEntry->ucStatus != BA_ENTRY_STATUS_DELETING) {
				mqmRxModifyBaEntryStatus(prAdapter, prRxBaEntry,
							 BA_ENTRY_STATUS_DELETING);

                /*                                                               */
				mqmSendDelBaFrame(prAdapter, DELBA_ROLE_RECIPIENT, prStaRec, u4Tid,
						  STATUS_CODE_UNSPECIFIED_FAILURE);
            }
			/*                             */
			/*      */
            /*                                                                                 */

            break;
        }


    }


    return WLAN_STATUS_SUCCESS; /*                              */

}


/*                                                                            */
/* 
                                         
 
                           
 
                
*/
/*                                                                            */
VOID mqmTimeoutCheckIdleRxBa(IN P_ADAPTER_T prAdapter, IN ULONG ulParamPtr)
{
    INT_8 i;
    P_RX_BA_ENTRY_T prRxBa;
    UINT_32 u4IdleCountThreshold = 0;
    P_STA_RECORD_T  prStaRec;
    P_QUE_MGT_T     prQM;

    DBGLOG(QM, WARN, ("[Puff]: Enter mqmTimeoutIdleRxBaDetection()\n"));

    prQM = &prAdapter->rQM;
    
	/*                         */
    cnmTimerStopTimer(prAdapter, &prAdapter->rMqmIdleRxBaDetectionTimer);
	cnmTimerStartTimer(prAdapter, &prAdapter->rMqmIdleRxBaDetectionTimer,
			   MQM_IDLE_RX_BA_CHECK_INTERVAL);

	/*                                                 */
	for (i = 0; i < CFG_NUM_OF_RX_BA_AGREEMENTS; i++) {

        prRxBa = &prQM->arRxBaTable[i];

		if (prRxBa->ucStatus == BA_ENTRY_STATUS_ACTIVE) {

            prStaRec = cnmGetStaRecByIndex(prAdapter, prRxBa->ucStaRecIdx);
            
			if (!prStaRec->fgIsInUse) {
				DBGLOG(QM, WARN,
				       ("[Puff][%s]: (Warning) sta_rec is not inuse\n", __func__));
                ASSERT(0);
            }
            /*                       */
			if (!(prStaRec->ucDesiredPhyTypeSet & PHY_TYPE_BIT_HT)) {
				DBGLOG(QM, WARN,
				       ("[Puff][%s]: (Warning) sta is NOT HT-capable(0x%08X)\n",
					__func__, prStaRec->ucDesiredPhyTypeSet));
                ASSERT(0);
            }
			/*                                                                                */
			if (prRxBa->u2SnapShotSN == prStaRec->au2CachedSeqCtrl[prRxBa->ucTid]) {

                prRxBa->ucIdleCount++;

                ASSERT(prRxBa->ucTid < 8);
				switch (aucTid2ACI[prRxBa->ucTid]) {
				case 0:	/*    */
                    u4IdleCountThreshold = MQM_DEL_IDLE_RXBA_THRESHOLD_BK;
                    break;
				case 1:	/*    */
                    u4IdleCountThreshold = MQM_DEL_IDLE_RXBA_THRESHOLD_BE;
                    break;
				case 2:	/*    */
                    u4IdleCountThreshold = MQM_DEL_IDLE_RXBA_THRESHOLD_VI;
                    break;
				case 3:	/*    */
                    u4IdleCountThreshold = MQM_DEL_IDLE_RXBA_THRESHOLD_VO;
                    break;
                }

				if (prRxBa->ucIdleCount >= u4IdleCountThreshold) {
					mqmRxModifyBaEntryStatus(prAdapter, prRxBa,
								 BA_ENTRY_STATUS_INVALID);
					mqmSendDelBaFrame(prAdapter, DELBA_ROLE_RECIPIENT, prStaRec,
							  (UINT_32) prRxBa->ucTid,
                        REASON_CODE_PEER_TIME_OUT);
					qmDelRxBaEntry(prAdapter, prStaRec->ucIndex, prRxBa->ucTid,
						       TRUE);
                }
            }
			/*                           */
			else {
                prRxBa->u2SnapShotSN = prStaRec->au2CachedSeqCtrl[prRxBa->ucTid];
                prRxBa->ucIdleCount = 0;
				continue;	/*                         */
            }
        }
    }

}


/*                                                                            */
/* 
                                        
 
                                         
                                           
 
                
*/
/*                                                                            */
VOID
mqmRxModifyBaEntryStatus(IN P_ADAPTER_T prAdapter,
			 IN P_RX_BA_ENTRY_T prRxBaEntry, IN ENUM_BA_ENTRY_STATUS_T eStatus)
{
    P_STA_RECORD_T              prStaRec;
    P_QUE_MGT_T                 prQM;
    
    BOOLEAN fgResetScoreBoard = FALSE;

    ASSERT(prRxBaEntry);

    prStaRec = cnmGetStaRecByIndex(prAdapter, prRxBaEntry->ucStaRecIdx);
    ASSERT(prStaRec);
    prQM = &prAdapter->rQM;

	if (prRxBaEntry->ucStatus == (UINT_8) eStatus) {
		DBGLOG(QM, WARN,
		       ("[Puff][%s]: eStatus are identical...\n", __func__, prRxBaEntry->ucStatus));
        return;
    }
	/*                                     */
	switch (prRxBaEntry->ucStatus) {

		/*                                                            */
    case BA_ENTRY_STATUS_INVALID:

        /*                                                                    */
		kalMemCopy(&prQM->arRxBaTable[prRxBaEntry->ucTid], prRxBaEntry,
			   sizeof(RX_BA_ENTRY_T));

        /*                             */
        prQM->ucRxBaCount++;
        ASSERT(prQM->ucRxBaCount <= CFG_NUM_OF_RX_BA_AGREEMENTS);

        /*                                                  */
        fgResetScoreBoard = TRUE;

        /*                                                             
                                                                                           
        */
        prRxBaEntry->ucIdleCount = 0;
        break;

		/*                     */
    default:
        break;
    }

	/*                                  */
	switch (eStatus) {

		/*                                                       */
    case BA_ENTRY_STATUS_INVALID:

        /*                                            */
		kalMemZero(&prQM->arRxBaTable[prRxBaEntry->ucTid], sizeof(RX_BA_ENTRY_T));

        /*                             */
        prQM->ucRxBaCount--;
        ASSERT(prQM->ucRxBaCount < CFG_NUM_OF_RX_BA_AGREEMENTS);

        /*       */
        fgResetScoreBoard = TRUE;

        /*                                                              */
		if (prQM->ucRxBaCount == 0) {
			if (MQM_CHECK_FLAG
			    (prAdapter->u4FlagBitmap, MQM_FLAG_IDLE_RX_BA_TIMER_STARTED)) {
				cnmTimerStopTimer(prAdapter,
						  &prAdapter->rMqmIdleRxBaDetectionTimer);
				MQM_CLEAR_FLAG(prAdapter->u4FlagBitmap,
					       MQM_FLAG_IDLE_RX_BA_TIMER_STARTED);
            }
        }

        break;

		/*                                   */
    case BA_ENTRY_STATUS_ACTIVE:

        /*                                                                     */
		if (!MQM_CHECK_FLAG(prAdapter->u4FlagBitmap, MQM_FLAG_IDLE_RX_BA_TIMER_STARTED)) {
			cnmTimerInitTimer(prAdapter, &prAdapter->rMqmIdleRxBaDetectionTimer, (PFN_MGMT_TIMEOUT_FUNC) mqmTimeoutCheckIdleRxBa, (ULONG) NULL);	/*              */

            cnmTimerStopTimer(prAdapter, &prAdapter->rMqmIdleRxBaDetectionTimer);

#if MQM_IDLE_RX_BA_DETECTION
			cnmTimerStartTimer(prAdapter, &prAdapter->rMqmIdleRxBaDetectionTimer,
					   MQM_IDLE_RX_BA_CHECK_INTERVAL);
            MQM_SET_FLAG(prAdapter->u4FlagBitmap, MQM_FLAG_IDLE_RX_BA_TIMER_STARTED);
#endif
        }

        break;

    case BA_ENTRY_STATUS_NEGO:
    default:
        break;
    }

	if (fgResetScoreBoard) {
        P_CMD_RESET_BA_SCOREBOARD_T     prCmdBody;
        
        prCmdBody = (P_CMD_RESET_BA_SCOREBOARD_T)
            cnmMemAlloc(prAdapter, RAM_TYPE_BUF, sizeof(CMD_RESET_BA_SCOREBOARD_T));
        ASSERT(prCmdBody);

        prCmdBody->ucflag   = MAC_ADDR_TID_MATCH;
        prCmdBody->ucTID    = prRxBaEntry->ucTid;
        kalMemCopy(prCmdBody->aucMacAddr, prStaRec->aucMacAddr, PARAM_MAC_ADDR_LEN);
            
		wlanoidResetBAScoreboard(prAdapter, prCmdBody, sizeof(CMD_RESET_BA_SCOREBOARD_T));

    }

	DBGLOG(QM, WARN, ("[Puff]QM: (RX_BA) [STA=%d TID=%d] status from %d to %d\n",
			  prRxBaEntry->ucStaRecIdx, prRxBaEntry->ucTid,
        prRxBaEntry->ucStatus, eStatus));

	prRxBaEntry->ucStatus = (UINT_8) eStatus;

}


/*                                                                            */
/* 
        
 
            
 
              
*/
/*                                                                            */
VOID mqmHandleAddBaReq(IN P_ADAPTER_T prAdapter, IN P_SW_RFB_T prSwRfb)
{
    P_STA_RECORD_T                  prStaRec;
    P_BSS_INFO_T                    prBssInfo;
    P_ACTION_ADDBA_REQ_FRAME_T      prAddBaReq;
    ACTION_ADDBA_REQ_BODY_T         rAddBaReqBody;
    P_ACTION_ADDBA_RSP_FRAME_T      prAddBaRsp;
    ACTION_ADDBA_RSP_BODY_T         rAddBaRspBody;
    P_RX_BA_ENTRY_T                 prRxBaEntry;
    P_MSDU_INFO_T                   prTxMsduInfo;
    P_QUE_MGT_T                     prQM;

    BOOLEAN fgIsReqAccepted         = TRUE;         /*                                */
    BOOLEAN fgIsNewEntryAdded       = FALSE;        /*                                                    */    

    UINT_32 u4Tid;
    UINT_32 u4StaRecIdx;
    UINT_16 u2WinStart;
    UINT_16 u2WinSize;
    UINT_32 u4BuffSize;

#if CFG_SUPPORT_BCM
    UINT_32 u4BuffSizeBT;
#endif  

    ASSERT(prSwRfb);

    prStaRec = prSwRfb->prStaRec;
    prQM = &prAdapter->rQM;

    do {

        
		/*                                                 */
        /*                        */
		if (!prStaRec->fgIsInUse) {
			DBGLOG(QM, WARN,
			       ("[Puff][%s]: (Warning) sta_rec is not inuse\n", __func__));
            break;
        }
        /*                       */
		if (!(prStaRec->ucDesiredPhyTypeSet & PHY_TYPE_BIT_HT)) {
			DBGLOG(QM, WARN,
			       ("[Puff][%s]: (Warning) sta is NOT HT-capable(0x%08X)\n", __func__,
				prStaRec->ucDesiredPhyTypeSet));
            break; /*                                         */
        }
		/*                                                     */
        /*                                                      */
		if ((!prAdapter->rWifiVar.fgSupportQoS) ||
		    (!prAdapter->rWifiVar.fgSupportAmpduRx) || (!prStaRec->fgRxAmpduEn)) {
			DBGLOG(QM, WARN,
			       ("[Puff][%s]: (Warning) BA ACK Policy not supported fgSupportQoS(%d), fgSupportAmpduRx(%d), fgRxAmpduEn(%d)\n",
				__func__, prAdapter->rWifiVar.fgSupportQoS,
				prAdapter->rWifiVar.fgSupportAmpduRx, prStaRec->fgRxAmpduEn));
            fgIsReqAccepted = FALSE; /*                                      */
        }
        /*                  */
		prAddBaReq = ((P_ACTION_ADDBA_REQ_FRAME_T) (prSwRfb->pvHeader));
		kalMemCopy((PUINT_8) (&rAddBaReqBody),
			   (PUINT_8) (&(prAddBaReq->aucBAParameterSet[0])), 6);
		if ((((rAddBaReqBody.
		       u2BAParameterSet) & BA_PARAM_SET_ACK_POLICY_MASK) >>
		     BA_PARAM_SET_ACK_POLICY_MASK_OFFSET)
		    != BA_PARAM_SET_ACK_POLICY_IMMEDIATE_BA) {	/*                                */
			DBGLOG(QM, WARN,
			       ("[Puff][%s]: (Warning) BA ACK Policy not supported (0x%08X)\n",
				__func__, rAddBaReqBody.u2BAParameterSet));
            fgIsReqAccepted = FALSE; /*                                      */
        }

		/*                                                           */
		/*                                             */
		u4Tid =
		    (((rAddBaReqBody.
		       u2BAParameterSet) & BA_PARAM_SET_TID_MASK) >> BA_PARAM_SET_TID_MASK_OFFSET);
        u4StaRecIdx = prStaRec->ucIndex;
		DBGLOG(QM, WARN,
		       ("[Puff][%s]: BA entry index = [TID(%d), STA_REC index(%d)]\n", __func__,
			u4Tid, u4StaRecIdx));

        u2WinStart = ((rAddBaReqBody.u2BAStartSeqCtrl) >> OFFSET_BAR_SSC_SN);
        u2WinSize  = (((rAddBaReqBody.u2BAParameterSet) & BA_PARAM_SET_BUFFER_SIZE_MASK)
                >> BA_PARAM_SET_BUFFER_SIZE_MASK_OFFSET);
		DBGLOG(QM, WARN,
		       ("[Puff][%s]: BA entry info = [WinStart(%d), WinSize(%d)]\n", __func__,
			u2WinStart, u2WinSize));

        
		if (fgIsReqAccepted) {
        
            prRxBaEntry = &prQM->arRxBaTable[u4Tid];
        
			if (!prRxBaEntry) {
        
				/*                                                                                 */
				if (prQM->ucRxBaCount < CFG_NUM_OF_RX_BA_AGREEMENTS) {

					fgIsNewEntryAdded = qmAddRxBaEntry(prAdapter,
									   (UINT_8) u4StaRecIdx,
									   (UINT_8) u4Tid,
									   u2WinStart, u2WinSize);

					if (!fgIsNewEntryAdded) {
						DBGLOG(QM, ERROR,
						       ("[Puff][%s]: (Error) Free RX BA entry alloc failure\n"));
                        fgIsReqAccepted = FALSE;
                    } else {
						DBGLOG(QM, WARN,
						       ("[Puff][%s]: Create a new BA Entry\n"));
                    }
                }
				/*                                                                             */
				else {
					DBGLOG(QM, WARN,
					       ("[Puff][%s]: (Warning) Free RX BA entry unavailable(req: %d)\n",
						__func__, prQM->ucRxBaCount));
                    fgIsReqAccepted = FALSE; /*                                      */
                }
			} else {
        
				/*                                                               */
                /*                                                     */
                /*                                                     */
				if (prRxBaEntry->ucStatus != BA_ENTRY_STATUS_ACTIVE) {
					DBGLOG(QM, WARN,
					       ("[Puff][%s]: (Warning) ADDBA_REQ for TID=%ld is received during status:%d (Ignore)\n",
						__func__, u4Tid, prRxBaEntry->ucStatus));
                    break; /*                                                      */
                }
				/*                                      */
                /*                                               */
				/*      */
            }
        }
		/*                                     */
		prTxMsduInfo =
		    (P_MSDU_INFO_T) cnmMgtPktAlloc(prAdapter, ACTION_ADDBA_RSP_FRAME_LEN);
        prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prStaRec->ucBssIndex);

		if (!prTxMsduInfo) {

            /*                                              
                                                                                                           
                                                                                                       
            */
			DBGLOG(QM, WARN,
			       ("[Puff][%s]: (Warning) ADDBA_RSP alloc failure\n", __func__));

			if (fgIsNewEntryAdded) {	/*                                                                  */
                ASSERT(prRxBaEntry);
				mqmRxModifyBaEntryStatus(prAdapter, prRxBaEntry,
							 BA_ENTRY_STATUS_INVALID);
            }

            break; /*                                     */
        }

        /*                            */
		prAddBaRsp =
		    (P_ACTION_ADDBA_RSP_FRAME_T) ((UINT_32) (prTxMsduInfo->prPacket) +
						  MAC_TX_RESERVED_FIELD);
        prAddBaRsp->u2FrameCtrl = MAC_FRAME_ACTION;
        
#if CFG_SUPPORT_802_11W
        if (rsnCheckBipKeyInstalled(prAdapter, prStaRec)) {
			DBGLOG(QM, WARN,
			       ("[Puff][%s]: (Warning) ADDBA_RSP is 80211w enabled\n", __func__));
            prAddBaReq->u2FrameCtrl |= MASK_FC_PROTECTED_FRAME;
        }
#endif
        prAddBaRsp->u2DurationID = 0;
        prAddBaRsp->ucCategory = CATEGORY_BLOCK_ACK_ACTION;
        prAddBaRsp->ucAction = ACTION_ADDBA_RSP;
        prAddBaRsp->ucDialogToken = prAddBaReq->ucDialogToken;

		DBGLOG(QM, WARN,
		       ("[Puff][%s]: (Warning) ADDBA_RSP DurationID(%d) Category(%d) Action(%d) DialogToken(%d)\n",
			__func__, prAddBaRsp->u2DurationID, prAddBaRsp->ucCategory,
			prAddBaRsp->ucAction, prAddBaRsp->ucDialogToken));

		if (fgIsReqAccepted) {
            rAddBaRspBody.u2StatusCode = STATUS_CODE_SUCCESSFUL;
		} else {
            rAddBaRspBody.u2StatusCode = STATUS_CODE_REQ_DECLINED;
        }

        /*                                                            */
		u4BuffSize = (((rAddBaReqBody.u2BAParameterSet) & BA_PARAM_SET_BUFFER_SIZE_MASK)
            >> BA_PARAM_SET_BUFFER_SIZE_MASK_OFFSET);

        /*                                                   */
		if ((u4BuffSize > CFG_RX_BA_MAX_WINSIZE) || (u4BuffSize <= 0)) {
            u4BuffSize = CFG_RX_BA_MAX_WINSIZE;
        }
#if CFG_SUPPORT_BCM
        /*                                                         */
        u4BuffSizeBT = bcmRequestBaWinSize();
        DBGLOG(QM, WARN, ("[Puff][%s]: (Warning) bcmRequestBaWinSize(%d)\n", 
				  __func__, u4BuffSizeBT));

		if (u4BuffSize > u4BuffSizeBT) {
            u4BuffSize =  u4BuffSizeBT;
        }
#endif /*                 */

		rAddBaRspBody.u2BAParameterSet = (BA_POLICY_IMMEDIATE |
            (u4Tid << BA_PARAM_SET_TID_MASK_OFFSET) |
						  (u4BuffSize <<
						   BA_PARAM_SET_BUFFER_SIZE_MASK_OFFSET));

        /*                                                                          */
        rAddBaRspBody.u2BATimeoutValue = rAddBaReqBody.u2BATimeoutValue;

		DBGLOG(QM, WARN,
		       ("[Puff][%s]: (Warning) ADDBA_RSP u4BuffSize(%d) StatusCode(%d) BAParameterSet(0x%08X) BATimeoutValue(%d)\n",
			__func__, u4BuffSize, rAddBaRspBody.u2StatusCode,
			rAddBaRspBody.u2BAParameterSet, rAddBaRspBody.u2BATimeoutValue));

		kalMemCopy((PUINT_8) (&(prAddBaRsp->aucStatusCode[0])), (PUINT_8) (&rAddBaRspBody),
			   6);

		COPY_MAC_ADDR(prAddBaRsp->aucDestAddr, prStaRec->aucMacAddr);
		COPY_MAC_ADDR(prAddBaRsp->aucSrcAddr, prBssInfo->aucOwnMacAddr);
		/*                                                                                       */
        COPY_MAC_ADDR(prAddBaRsp->aucBSSID, prAddBaReq->aucBSSID);


		/*                                    */
		TX_SET_MMPDU(prAdapter,
            prTxMsduInfo,
            prStaRec->ucBssIndex,
			     (prStaRec != NULL) ? (prStaRec->ucIndex) : (STA_REC_INDEX_NOT_FOUND),
            WLAN_MAC_HEADER_LEN,
            ACTION_ADDBA_RSP_FRAME_LEN,
			     mqmCallbackAddBaRspSent, MSDU_RATE_MODE_AUTO);

#if CFG_SUPPORT_802_11W
        if (rsnCheckBipKeyInstalled(prAdapter, prStaRec)) {
			DBGLOG(RSN, INFO, ("Set MSDU_OPT_PROTECTED_FRAME\n"));
            nicTxConfigPktOption(prTxMsduInfo, MSDU_OPT_PROTECTED_FRAME, TRUE);
        }
#endif

        /*                                                                      
                                                                                          
                                                                                
        */
		prTxMsduInfo->ucTID = (UINT_8) u4Tid;
        
        nicTxEnqueueMsdu(prAdapter, prTxMsduInfo);

		DBGLOG(QM, WARN,
		       ("[Puff][%s]: (RX_BA) ADDBA_RSP ---> peer (STA=%d TID=%ld)\n", __func__,
			prStaRec->ucIndex, u4Tid));


#if 0
		/*                                                  */
		if (fgIsNewEntryAdded) {	/*                                                                    */
            ASSERT(fgIsReqAccepted);

            prSwRfbEventToHost = (P_SW_RFB_T) cnmMgtPktAlloc(EVENT_RX_ADDBA_PACKET_LEN);

			if (!prSwRfbEventToHost) {

                /*                                                                                         
                                                                                                              
                */

				DBGLOG(MQM, WARN, ("MQM: (Warning) EVENT packet alloc failed\n"));

                /*                                          */
				mqmRxModifyBaEntryStatus(prRxBaEntry, BA_ENTRY_STATUS_INVALID);

                break; /*                             */
			} else {

				prEventRxAddBa = (P_EVENT_RX_ADDBA_T) prSwRfbEventToHost->pucBuffer;
				prEventRxAddBa->ucStaRecIdx = (UINT_8) u4StaRecIdx;
                prEventRxAddBa->u2Length = EVENT_RX_ADDBA_PACKET_LEN;
                prEventRxAddBa->ucEID = EVENT_ID_RX_ADDBA;
                prEventRxAddBa->ucSeqNum = 0; /*                          */
                prEventRxAddBa->u2BAParameterSet = rAddBaRspBody.u2BAParameterSet;
                prEventRxAddBa->u2BAStartSeqCtrl = rAddBaReqBody.u2BAStartSeqCtrl;
                prEventRxAddBa->u2BATimeoutValue = rAddBaReqBody.u2BATimeoutValue;
                prEventRxAddBa->ucDialogToken = prAddBaReq->ucDialogToken;

				DBGLOG(MQM, INFO,
				       ("MQM: (RX_BA) Event ADDBA ---> driver (STA=%ld TID=%ld WinStart=%d)\n",
					u4StaRecIdx, u4Tid,
					(prEventRxAddBa->u2BAStartSeqCtrl >> 4)));

                /*                                           */
				RXM_SET_EVENT_PACKET(
							    /*            */ (P_SW_RFB_T)
							    prSwRfbEventToHost,
							    /*                       */
							    (PUINT_8) prEventRxAddBa,
							    /*                    */ HIF_RX0_INDEX
                );

                rxmSendEventToHost(prSwRfbEventToHost);
            }

        }
#endif
        

	} while (FALSE);

}

/*                                                                            */
/* 
        
 
            
 
              
*/
/*                                                                            */
VOID mqmHandleAddBaRsp(IN P_SW_RFB_T prSwRfb)
{

}

/*                                                                            */
/* 
        
 
            
 
              
*/
/*                                                                            */
VOID mqmHandleDelBa(IN P_SW_RFB_T prSwRfb)
{

}

/*                                                                            */
/* 
        
 
            
 
              
*/
/*                                                                            */
VOID mqmHandleBaActionFrame(IN P_ADAPTER_T prAdapter, IN P_SW_RFB_T prSwRfb)
{
    P_WLAN_ACTION_FRAME                 prRxFrame;

    ASSERT(prAdapter);
    ASSERT(prSwRfb);

    prRxFrame = (P_WLAN_ACTION_FRAME) prSwRfb->pvHeader;
	DBGLOG(RLM, WARN, ("[Puff][%s] Action(%d)\n", __func__, prRxFrame->ucAction));

	switch (prRxFrame->ucAction) {

        case ACTION_ADDBA_REQ:
		DBGLOG(RLM, WARN, ("[Puff][%s] (RX_BA) ADDBA_REQ <--- peer\n", __func__));
            mqmHandleAddBaReq(prAdapter, prSwRfb);
            break;

        case ACTION_ADDBA_RSP:
		DBGLOG(RLM, WARN, ("[Puff][%s] (RX_BA) ADDBA_RSP <--- peer\n", __func__));
            mqmHandleAddBaRsp(prSwRfb);
            break;

        case ACTION_DELBA:
		DBGLOG(RLM, WARN, ("[Puff][%s] (RX_BA) DELBA <--- peer\n", __func__));
            mqmHandleDelBa(prSwRfb);
            break;

        default:
		DBGLOG(RLM, WARN, ("[Puff][%s] Unknown BA Action Frame\n", __func__));
            break;
    }



}

#endif
