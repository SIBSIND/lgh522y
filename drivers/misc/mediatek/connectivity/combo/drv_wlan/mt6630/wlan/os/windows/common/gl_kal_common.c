/*
                                                                                                   
*/

/*                         
                                          

*/



/*
                          
  
                        
                                                                                  
          
  
                                                                                                
  
                                                                                    
  
                        
                                                                                  
                               
  
                        
                                                
                      
  
                   
                                                                                              
                                            
                                                                   
                                                   
  
                      
                                                         
                                                                       
  
                   
                                                                       
                                                    
  
                   
                                                                                     
                                  
                                                                  
  
                   
                                                                                     
                                   
                                   
  
                      
                                                         
    
  
                      
                                                         
                                                  
  
                      
                                                         
                                                        
  
                      
                                                             
                                                  
                                                                      
  
                   
                                                                                
                                                              
  
                      
       
                                                               
  
                   
                                                                                               
                                                                                        
  
                        
                                                                                                                                                                                                     
                          
  
                   
                                                                                                                                                    
                                                                
  
                   
                                                                    
                                                
                                                                             
  
                   
                                                                                                                                                    
                                                                                               
                                                       
  
                   
                                                                                                                                    
                                                                                                      
  
                   
                                                                                                                                                         
                                                                          
                                                                         
  
                                                                                                
  
                   
                                                                                                                                    
                                                                                                                       
  
                   
                                                                                                                                                                    
                                                
  
                   
                                                                                                                                                                    
                                                                                                                       
  
                   
                                                                                                             
                                                               
                                                                          
                                                                                   
  
                   
                                                                                                                                                   
                                                                                                             
  
                   
                                                                                                                                  
                                                                                                                          
  
                        
       
                                               
  
                   
                                                                                                                            
                                                                                                                                                  
                                                                                                                    
  
                   
                                                                         
                                                     
  
                   
                                                                                                                                                                                                      
                                                                                                   
                                          
                                                                          
  
                   
                                                                                                                                                              
                                                  
  
                   
                                                                                 
                             
  
                   
                                                                         
                                                                         
  
                   
                                                                                 
                          
                                                                                                     
                                                         
  
                   
                                                                                     
                                     
  
                   
                                                                                     
                                          
  
                   
                                                                                                                                 
                                         
  
                   
       
                                                                            
  
                   
                                                                                                                            
                                                                      
  
                   
       
                                                          
  
                   
       
                                      
  
                   
       
                                       
  
                   
       
                                                                 
  
                   
       
                                                                                                
  
                         
       
                                                                     
  
                   
       
                                                                  
  
                   
       
                                                                                                              
  
                        
       
                                                             
  
                   
       
                                                                                                              
  
                   
       
                                                                     
  
                   
       
                                                                                          
  
                   
       
                                                
  
                   
       
                                                                
  
                   
       
                                                                          
  
                   
       
                                                             
  
                   
  
                                                
                           
  
                   
  
                                                  
  
                   
  
                                                                                                 
                                                                                                   
                                                                                                                         
  
                   
  
                                                                               
  
                   
                                                    
                                                                  
  
                   
                                                    
                                                                                                                        
  
                        
                                        
                                              
  
                   
                                                    
                                     
  
                   
                                                    
                        
  
                   
                                                    
                      
  
                   
                                                    
                      
                                                                      
                                                           
                                         
                                          
  
                   
                                                    
                                         
  
                   
                                                    
                               
  
                         
                                                
                                   
  
                   
                                                          
                                     
  
                   
                                                          
                                            
  
                   
                                                          
                                             
  
                   
                                                          
                                               
                                                                            
  
                   
                                                                     
                                                              
  
                   
                                                                     
                                                               
                             
  
                   
                                                                     
                                                            
  
                   
                                                                     
                                         
  
                   
                                                               
                                                                       
                                                    
  
                   
                                                               
                                                                    
  
                   
                                                               
                                     
  
                   
                                                          
                                                                                                
  
                   
                                                          
                                                                      
                                                                                                  
  
                   
                                                               
                                           
                                                                                                                                       
                                                                                                                     
                                                                                                                            
  
                   
                                                          
                                            
                                                                          
  
                   
                                                          
                                                 
  
                   
                                                          
                                                                                   
                                            
  
                   
                                                          
                                                                                
                                                              
  
                   
                                                          
                                                                                       
  
                   
                                                          
                                                                   
  
                   
                                                          
                                                                                                    
  
                   
                                                          
                                                                                                      
  
                   
                                                          
                                               
                                                        
  
                   
                                                               
                                             
  
                        
                                   
                                                                                                                                                                                                                                       
  
                   
                                                          
                                            
                                                                                                                               
  
                   
                                                          
                                                                                                    
                                                                                        
  
                   
                                                          
                                                                                                                   
  
                   
                                                          
                                                                                   
                                                                               
  
                   
                                                          
                                                                  
  
                   
                                                          
                                              
  
                   
                                                          
                                                                              
                                                                                              
  
                   
                                                          
    
  
                   
                                                          
                                             
                                                                                      
                                                                                                                         
                                                                   
  
                   
                                                          
                                                                                                                 
                                                                            
              
                                                                            
                     
                                                                            
                                                                          
                                                                            
                                               
                                                                            
                                                    
                                                                            
                                                                       
                                                                            
                                                        
                                                                            
                       
                                                                            
                                                                                                                   
                                                                            
                                                                
                                                                            
                                              
                                                                            
                                        
                                                                            
                                               
                                                                            
                                                                            
                                                                     
                                                                            
                                                                                   
                                   
                                                                            
                                                                                                            
                                                                            
                                                                           
                                                                            
                            
                                                                            
                                  
                                                                            
                                                                            
                                                                            
                                    
                                                                            
                                                                                  
                                                                            
                                                                        
                                                                           
                                                            
                                                                           
                                       
                                                                           
                                                  
                                                                           
                                                          
                                                                           
                                     
                                                                           
                                
                                                                           
                                                                        
                                                                           
                    
  
*/

/*                                                                              
                                                     
                                                                                
*/

/*                                                                              
                                                          
                                                                                
*/
#include "config.h"
#include "gl_os.h"
#include "mac.h"
#include "link.h"
#include "wlan_def.h"
#include "cmd_buf.h"
#include "mt6630_reg.h"

#include <ntddk.h>
#include "Ntstrsafe.h"
/*                                                                              
                                                
                                                                                
*/

/*                                                                              
                                                 
                                                                                
*/

/*                                                                              
                                                  
                                                                                
*/
ULONG RtlRandomEx(__inout PULONG Seed);

/*                                                                              
                                                   
                                                                                
*/

/*                                                                              
                                             
                                                                                
*/

/*                                                                              
                                                             
                                                                                
*/

/*                                                                              
                                                
                                                                                
*/


/*                                                                            */
/* 
                               
 
                                              
                                        
                                                    
 
              
*/
/*                                                                            */
VOID kalMemFree(IN PVOID pvAddr, IN ENUM_KAL_MEM_ALLOCATION_TYPE eMemType, IN UINT_32 u4Size)
{
	NdisFreeMemory(pvAddr, u4Size, 0);
}				/*            */


/*                                                                            */
/* 
                                          
 
                                                  
 
              
*/
/*                                                                            */
VOID kalUdelay(IN UINT_32 u4MicroSec)
{
	/*                                                              
                                                  */
	while (u4MicroSec > 50) {
		NdisStallExecution(50);
		u4MicroSec -= 50;
	}

	if (u4MicroSec > 0) {
		NdisStallExecution(u4MicroSec);
	}
}				/*           */


/*                                                                            */
/* 
                                          
 
                                                  
 
                
*/
/*                                                                            */
VOID kalMdelay(IN UINT_32 u4MilliSec)
{
	kalUdelay(u4MilliSec * 1000);
}				/*           */


/*                                                                            */
/* 
                                          
 
                                                  
 
                
*/
/*                                                                            */
VOID kalMsleep(IN UINT_32 u4MilliSec)
{
	UINT_32 u4Timestamp[2], u4RemainTime;

	u4RemainTime = u4MilliSec;

	/*                                                                         */
	while (u4RemainTime > 0) {
		u4Timestamp[0] = SYSTIME_TO_MSEC(kalGetTimeTick());

		NdisMSleep(u4MilliSec);

		u4Timestamp[1] = SYSTIME_TO_MSEC(kalGetTimeTick());

		/*                                   */
		if (u4Timestamp[1] >= u4Timestamp[0]) {
			if ((u4Timestamp[1] - u4Timestamp[0]) >= u4RemainTime) {
				break;
			} else {
				u4RemainTime -= (u4Timestamp[1] - u4Timestamp[0]);
			}
		} else {
			if ((u4Timestamp[1] + (UINT_MAX - u4Timestamp[0])) >= u4RemainTime) {
				break;
			} else {
				u4RemainTime -= (u4Timestamp[1] + (UINT_MAX - u4Timestamp[0]));
			}
		}
	}
}				/*           */

/*                                                                            */
/* 
                                                                                               
 
                                                      
 
                
*/
/*                                                                            */
VOID kalSetEvent(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	/*           */
	NdisSetEvent(&prGlueInfo->rTxReqEvent);

}				/*                      */


/*                                                                            */
/* 
                                                                                          
                             
 
                                                      
 
              
*/
/*                                                                            */
VOID kalInterruptDone(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

#if SC32442_SPI && 0
	InterruptDone(prGlueInfo->rHifInfo.u4sysIntr);
#endif
}


/*                                                                            */
/* 
                                                     
 
                                                         
 
                              
                              
*/
/*                                                                            */
WLAN_STATUS kalTxServiceThread(IN PVOID pvGlueContext)
{
	NDIS_STATUS ndisStatus = NDIS_STATUS_SUCCESS;
	P_GLUE_INFO_T prGlueInfo;
	P_QUE_ENTRY_T prQueueEntry;
	P_QUE_T prTxQue;
	P_QUE_T prCmdQue;
	P_QUE_T prReturnQueue;
	PNDIS_PACKET prNdisPacket;
	P_GL_HIF_INFO_T prHifInfo = NULL;
	BOOLEAN fgNeedHwAccess;
	GLUE_SPIN_LOCK_DECLARATION();


	ASSERT(pvGlueContext);

	prGlueInfo = (P_GLUE_INFO_T) pvGlueContext;
	prTxQue = &prGlueInfo->rTxQueue;
	prCmdQue = &prGlueInfo->rCmdQueue;
	prReturnQueue = &prGlueInfo->rReturnQueue;
	prHifInfo = &prGlueInfo->rHifInfo;

	/*                                              */

	DEBUGFUNC("kalTxServiceThread");
/*                              */

	KeSetEvent(&prHifInfo->rOidReqEvent, EVENT_INCREMENT, FALSE);

	while (TRUE) {
		if (GLUE_TEST_FLAG(prGlueInfo, GLUE_FLAG_HALT)) {
			DBGLOG(INIT, TRACE, ("kalTxServiceThread - GLUE_FLAG_HALT!!\n"));
			break;
		}

		GLUE_WAIT_EVENT(prGlueInfo);
		GLUE_RESET_EVENT(prGlueInfo);

		/*                                     */
		if (GLUE_TEST_FLAG(prGlueInfo, GLUE_FLAG_RESET)) {
			if (prGlueInfo->i4OidPendingCount) {
				/*                                                     */
				wlanReleasePendingOid(prGlueInfo->prAdapter, 0);
			}

			/*                   */
			if (prGlueInfo->i4TxPendingFrameNum) {
				kalFlushPendingTxPackets(prGlueInfo);

				wlanFlushTxPendingPackets(prGlueInfo->prAdapter);
			}
			/*                                */
			if (prGlueInfo->i4TxPendingSecurityFrameNum) {
				kalClearSecurityFrames(prGlueInfo);
			}

			if ((!prGlueInfo->i4OidPendingCount) &&
			    (!prGlueInfo->i4TxPendingFrameNum) &&
			    (!prGlueInfo->i4TxPendingSecurityFrameNum)) {

				GLUE_CLEAR_FLAG(prGlueInfo, GLUE_FLAG_RESET);

				DBGLOG(INIT, WARN, ("NdisMResetComplete()\n"));
				NdisMResetComplete(prGlueInfo->rMiniportAdapterHandle,
						   NDIS_STATUS_SUCCESS, FALSE);
			}
		}

		fgNeedHwAccess = FALSE;

#if CFG_SUPPORT_SDIO_READ_WRITE_PATTERN
		if (prGlueInfo->fgEnSdioTestPattern == TRUE) {
			if (fgNeedHwAccess == FALSE) {
				fgNeedHwAccess = TRUE;

				wlanAcquirePowerControl(prGlueInfo->prAdapter);
			}

			if (prGlueInfo->fgIsSdioTestInitialized == FALSE) {
				/*                  */
				kalDevRegWrite(prGlueInfo, MCR_WTMCR, 0x00080002);
				prGlueInfo->fgIsSdioTestInitialized = TRUE;
			}

			if (prGlueInfo->fgSdioReadWriteMode == TRUE) {
				/*           */
				kalDevPortRead(prGlueInfo,
					       MCR_WTMDR,
					       256,
					       prGlueInfo->aucSdioTestBuffer,
					       sizeof(prGlueInfo->aucSdioTestBuffer));
			} else {
				/*            */
				kalDevPortWrite(prGlueInfo,
						MCR_WTMDR,
						172,
						prGlueInfo->aucSdioTestBuffer,
						sizeof(prGlueInfo->aucSdioTestBuffer));
			}
		}
#endif

		/*                          */
		wlanProcessMboxMessage(prGlueInfo->prAdapter);

		/*                     */
		if (wlanGetAcpiState(prGlueInfo->prAdapter) == ACPI_STATE_D0
		    && prCmdQue->u4NumElem > 0) {
			/*                */
			if (fgNeedHwAccess == FALSE) {
				fgNeedHwAccess = TRUE;

				wlanAcquirePowerControl(prGlueInfo->prAdapter);
			}

			wlanProcessCommandQueue(prGlueInfo->prAdapter, prCmdQue);
		}

		/*                    */
		{
			/*                              */
			while (TRUE) {
				GLUE_ACQUIRE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_TX_QUE);
				QUEUE_REMOVE_HEAD(prTxQue, prQueueEntry, P_QUE_ENTRY_T);
				GLUE_RELEASE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_TX_QUE);

				if (prQueueEntry == NULL) {
					break;
				}

				prNdisPacket = GLUE_GET_PKT_DESCRIPTOR(prQueueEntry);

				if (wlanEnqueueTxPacket(prGlueInfo->prAdapter,
							(P_NATIVE_PACKET) prNdisPacket) ==
				    WLAN_STATUS_RESOURCES) {
					GLUE_ACQUIRE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_TX_QUE);
					QUEUE_INSERT_HEAD(prTxQue, prQueueEntry);
					GLUE_RELEASE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_TX_QUE);

					break;
				}
			}

			if (wlanGetTxPendingFrameCount(prGlueInfo->prAdapter) > 0) {
				wlanTxPendingPackets(prGlueInfo->prAdapter, &fgNeedHwAccess);
			}
		}

		/*                    */
		{
			UINT_32 u4RegValue;
			UINT_32 u4CurrAvailFreeRfbCnt;

			while (TRUE) {

				GLUE_ACQUIRE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_RX_RETURN_QUE);
				QUEUE_REMOVE_HEAD(prReturnQueue, prQueueEntry, P_QUE_ENTRY_T);
				GLUE_RELEASE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_RX_RETURN_QUE);

				if (prQueueEntry == NULL) {
					break;
				}

				prNdisPacket = MP_GET_MR_PKT(prQueueEntry);

				wlanReturnPacket(prGlueInfo->prAdapter, (PVOID) prNdisPacket);
			}
		}

		/*                     */
		{
			P_WLAN_REQ_ENTRY prEntry;
			UINT_32 u4QueryInfoLen;
			UINT_32 u4SetInfoLen;
			KIRQL rOldIrql;
			WLAN_STATUS rStatus;

			if (_InterlockedAnd(&prGlueInfo->rHifInfo.u4ReqFlag, ~REQ_FLAG_OID) &
			    REQ_FLAG_OID) {

				prEntry = (P_WLAN_REQ_ENTRY) prGlueInfo->pvOidEntry;

				if (prGlueInfo->fgSetOid) {
					if (prGlueInfo->fgIsGlueExtension) {
						rStatus = prEntry->pfOidSetHandler(prGlueInfo,
										   prGlueInfo->
										   pvInformationBuffer,
										   prGlueInfo->
										   u4InformationBufferLength,
										   &u4SetInfoLen);
					} else {
						rStatus = wlanSetInformation(prGlueInfo->prAdapter,
									     prEntry->
									     pfOidSetHandler,
									     prGlueInfo->
									     pvInformationBuffer,
									     prGlueInfo->
									     u4InformationBufferLength,
									     &u4SetInfoLen);
					}

					/*                 */
					/*                                                         
                                                                         
                                                                                        
       
      */
					if (prGlueInfo->pu4BytesReadOrWritten)
						*prGlueInfo->pu4BytesReadOrWritten = u4SetInfoLen;

					if (prGlueInfo->pu4BytesNeeded)
						*prGlueInfo->pu4BytesNeeded = u4SetInfoLen;

					if (rStatus != WLAN_STATUS_PENDING) {
						KeRaiseIrql(DISPATCH_LEVEL, &rOldIrql);


						GLUE_DEC_REF_CNT(prGlueInfo->i4OidPendingCount);
						ASSERT(prGlueInfo->i4OidPendingCount == 0);

						NdisMSetInformationComplete(prGlueInfo->
									    rMiniportAdapterHandle,
									    rStatus);
						KeLowerIrql(rOldIrql);
					} else {
						wlanoidTimeoutCheck(prGlueInfo->prAdapter,
								    prEntry->pfOidSetHandler);
					}
				} else {
					if (prGlueInfo->fgIsGlueExtension) {
						rStatus = prEntry->pfOidQueryHandler(prGlueInfo,
										     prGlueInfo->
										     pvInformationBuffer,
										     prGlueInfo->
										     u4InformationBufferLength,
										     &u4QueryInfoLen);
					} else {
						rStatus =
						    wlanQueryInformation(prGlueInfo->prAdapter,
									 prEntry->pfOidQueryHandler,
									 prGlueInfo->
									 pvInformationBuffer,
									 prGlueInfo->
									 u4InformationBufferLength,
									 &u4QueryInfoLen);
					}

					if (prGlueInfo->pu4BytesReadOrWritten) {
						/*                                                       
                                                      
                          */
						if (u4QueryInfoLen >
						    prGlueInfo->u4InformationBufferLength) {
							*prGlueInfo->pu4BytesReadOrWritten =
							    prGlueInfo->u4InformationBufferLength;
						} else {
							*prGlueInfo->pu4BytesReadOrWritten =
							    u4QueryInfoLen;
						}
					}

					if (prGlueInfo->pu4BytesNeeded)
						*prGlueInfo->pu4BytesNeeded = u4QueryInfoLen;

					if (rStatus != WLAN_STATUS_PENDING) {
						KeRaiseIrql(DISPATCH_LEVEL, &rOldIrql);


						GLUE_DEC_REF_CNT(prGlueInfo->i4OidPendingCount);
						ASSERT(prGlueInfo->i4OidPendingCount == 0);

						NdisMQueryInformationComplete(prGlueInfo->
									      rMiniportAdapterHandle,
									      rStatus);
						KeLowerIrql(rOldIrql);
					} else {
						wlanoidTimeoutCheck(prGlueInfo->prAdapter,
								    prEntry->pfOidSetHandler);
					}
				}
			}
		}

		/*                                            */
		if (_InterlockedAnd(&prGlueInfo->rHifInfo.u4ReqFlag, ~REQ_FLAG_INT) & REQ_FLAG_INT) {
			if (wlanGetAcpiState(prGlueInfo->prAdapter) == ACPI_STATE_D0) {
				/*                */
				if (fgNeedHwAccess == FALSE) {
					fgNeedHwAccess = TRUE;

					wlanAcquirePowerControl(prGlueInfo->prAdapter);
				}

				wlanIST(prGlueInfo->prAdapter);
			}
		}

		if (wlanGetAcpiState(prGlueInfo->prAdapter) == ACPI_STATE_D0
		    && fgNeedHwAccess == TRUE) {
			wlanReleasePowerControl(prGlueInfo->prAdapter);
		}

		/*                                   */
		if (GLUE_TEST_FLAG(prGlueInfo, GLUE_FLAG_RESET) &&
		    (!prGlueInfo->i4OidPendingCount) &&
		    (!prGlueInfo->i4TxPendingFrameNum) &&
		    (!prGlueInfo->i4TxPendingSecurityFrameNum)) {

			GLUE_CLEAR_FLAG(prGlueInfo, GLUE_FLAG_RESET);

			DBGLOG(INIT, WARN, ("NdisMResetComplete()\n"));
			NdisMResetComplete(prGlueInfo->rMiniportAdapterHandle,
					   NDIS_STATUS_SUCCESS, FALSE);
		}

		if (GLUE_TEST_FLAG(prGlueInfo, GLUE_FLAG_TIMEOUT)) {
			GLUE_CLEAR_FLAG(prGlueInfo, GLUE_FLAG_TIMEOUT);

			wlanTimerTimeoutCheck(prGlueInfo->prAdapter);
		}
#if CFG_SUPPORT_SDIO_READ_WRITE_PATTERN
		if (prGlueInfo->fgEnSdioTestPattern == TRUE) {
			GLUE_SET_EVENT(prGlueInfo);
		}
#endif
	}

	while (TRUE) {
		GLUE_ACQUIRE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_RX_RETURN_QUE);
		QUEUE_REMOVE_HEAD(prReturnQueue, prQueueEntry, P_QUE_ENTRY_T);
		GLUE_RELEASE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_RX_RETURN_QUE);

		if (prQueueEntry == NULL) {

			if (prGlueInfo->i4RxPendingFrameNum) {
				/*                                                                               */
				NdisMSleep(100000);	/*                                      */
			} else {
				/*                      */
				break;
			}
		} else {
			prNdisPacket = MP_GET_MR_PKT(prQueueEntry);

			wlanReturnPacket(prGlueInfo->prAdapter, (PVOID) prNdisPacket);
		}
	}

	return ndisStatus;
}


/*                                                                            */
/* 
                                
 
        
 
                                      
                                      
*/
/*                                                                            */
WLAN_STATUS kalDownloadPatch(IN PNDIS_STRING FileName)
{
	NDIS_STATUS rStatus;
	NDIS_HANDLE FileHandle;
	UINT_32 u4FileLength;
	NDIS_PHYSICAL_ADDRESS HighestAcceptableAddress = NDIS_PHYSICAL_ADDRESS_CONST(-1, -1);
	PUINT_8 pucMappedBuffer;

	/*                      */
	NdisOpenFile(&rStatus, &FileHandle, &u4FileLength, FileName, HighestAcceptableAddress);

	if (rStatus == NDIS_STATUS_SUCCESS) {
		/*                                  */
		NdisMapFile(&rStatus, &pucMappedBuffer, FileHandle);

		if (rStatus == NDIS_STATUS_SUCCESS) {
			/*                        */
		}

		NdisCloseFile(FileHandle);
	}

	return (rStatus);
}


/*                                                                            */
/* 
                                                     
 
                                                         
 
                
*/
/*                                                                            */
VOID
kalOidComplete(IN P_GLUE_INFO_T prGlueInfo,
	       IN BOOLEAN fgSetQuery, IN UINT_32 u4SetQueryInfoLen, IN WLAN_STATUS rOidStatus)
{
	/*                 */

	ASSERT(prGlueInfo);
	ASSERT((((fgSetQuery) && (prGlueInfo->fgSetOid)) ||
		((!fgSetQuery) && (!prGlueInfo->fgSetOid))));

	/*                            */
	wlanoidClearTimeoutCheck(prGlueInfo->prAdapter);

	/*                                                                                 
                                                                               
  */
	GLUE_DEC_REF_CNT(prGlueInfo->i4OidPendingCount);
	ASSERT(prGlueInfo->i4OidPendingCount == 0);

	/*                                         */
	if (prGlueInfo->fgSetOid) {
		if (prGlueInfo->pu4BytesReadOrWritten) {
			*prGlueInfo->pu4BytesReadOrWritten = u4SetQueryInfoLen;
		}

		if (prGlueInfo->pu4BytesNeeded) {
			*prGlueInfo->pu4BytesNeeded = u4SetQueryInfoLen;
		}

		NdisMSetInformationComplete(prGlueInfo->rMiniportAdapterHandle, rOidStatus);
	} else {
		/*                                                       
                                                  
                      */
		if (u4SetQueryInfoLen > prGlueInfo->u4InformationBufferLength) {
			u4SetQueryInfoLen = prGlueInfo->u4InformationBufferLength;
		}

		if (prGlueInfo->pu4BytesReadOrWritten) {
			*prGlueInfo->pu4BytesReadOrWritten = u4SetQueryInfoLen;
		}

		if (prGlueInfo->pu4BytesNeeded) {
			*prGlueInfo->pu4BytesNeeded = u4SetQueryInfoLen;
		}

		NdisMQueryInformationComplete(prGlueInfo->rMiniportAdapterHandle, rOidStatus);
	}
	/*                        */

	return;
}

/*                                                                            */
/* 
                                                                              
                                                                                    
                
 
                                                         
                                             
                                         
                                         
                                               
                                                
                                                       
                                                      
                                                     
 
                                                  
                                                       
*/
/*                                                                            */
BOOL
kalQoSFrameClassifierAndPacketInfo(IN P_GLUE_INFO_T prGlueInfo,
				   IN P_NATIVE_PACKET prPacket,
				   OUT PUINT_8 pucPriorityParam,
				   OUT PUINT_32 pu4PacketLen,
				   OUT PUINT_8 pucEthDestAddr,
				   OUT PBOOLEAN pfgIs1X,
				   OUT PBOOLEAN pfgIsPAL,
				   OUT PBOOLEAN pfgIs802_3, OUT PBOOLEAN pfgIsVlanExists)
{
	PNDIS_BUFFER prNdisBuffer;
	UINT_32 u4PacketLen;

	UINT_8 aucLookAheadBuf[LOOK_AHEAD_LEN];
	UINT_32 u4ByteCount = 0;
	UINT_8 ucUserPriority = 0;	/*                                                                                              */
	UINT_8 ucLookAheadLen;
	UINT_16 u2EtherTypeLen;
	PNDIS_PACKET prNdisPacket = (PNDIS_PACKET) prPacket;

	DEBUGFUNC("kalQoSFrameClassifierAndPacketInfo");

	/*                                       */
	NdisQueryPacket(prNdisPacket, NULL, NULL, &prNdisBuffer, &u4PacketLen);

	if (u4PacketLen < ETHER_HEADER_LEN) {
		DBGLOG(INIT, WARN, ("Invalid Ether packet length: %d\n", u4PacketLen));
		return FALSE;
	}

	if (u4PacketLen < LOOK_AHEAD_LEN) {
		ucLookAheadLen = (UINT_8) u4PacketLen;
	} else {
		ucLookAheadLen = LOOK_AHEAD_LEN;
	}

	/*                                                     */
	while (prNdisBuffer && u4ByteCount < ucLookAheadLen) {
		PVOID pvAddr;
		UINT_32 u4Len;
		PNDIS_BUFFER prNextNdisBuffer;

#ifdef NDIS51_MINIPORT
		NdisQueryBufferSafe(prNdisBuffer, &pvAddr, &u4Len, HighPagePriority);
#else
		NdisQueryBuffer(prNdisBuffer, &pvAddr, &u4Len);
#endif

		if (pvAddr == (PVOID) NULL) {
			ASSERT(0);
			return FALSE;
		}

		if ((u4ByteCount + u4Len) >= ucLookAheadLen) {
			kalMemCopy(&aucLookAheadBuf[u4ByteCount],
				   pvAddr, (ucLookAheadLen - u4ByteCount));
			break;
		} else {
			kalMemCopy(&aucLookAheadBuf[u4ByteCount], pvAddr, u4Len);
		}
		u4ByteCount += u4Len;

		NdisGetNextBuffer(prNdisBuffer, &prNextNdisBuffer);

		prNdisBuffer = prNextNdisBuffer;
	}

	*pfgIs1X = FALSE;
	*pfgIsPAL = FALSE;
	*pfgIsVlanExists = FALSE;
	*pfgIs802_3 = FALSE;

	/*                            */

	/*                                        */
	u2EtherTypeLen = NTOHS(*(PUINT_16) & aucLookAheadBuf[ETHER_TYPE_LEN_OFFSET]);

	if ((u2EtherTypeLen == ETH_P_IPV4) && (u4PacketLen >= LOOK_AHEAD_LEN)) {
		PUINT_8 pucIpHdr = &aucLookAheadBuf[ETHER_HEADER_LEN];
		UINT_8 ucIpVersion;


		ucIpVersion = (pucIpHdr[0] & IP_VERSION_MASK) >> IP_VERSION_OFFSET;

		if (ucIpVersion == IP_VERSION_4) {
			UINT_8 ucIpTos;


			/*                                                  */
			ucIpTos = pucIpHdr[1];
			ucUserPriority =
			    ((ucIpTos & IPV4_HDR_TOS_PREC_MASK) >> IPV4_HDR_TOS_PREC_OFFSET);
		}

		/*                                        */
	} else if (u2EtherTypeLen == ETH_P_1X) {	/*                  */
		/*                                  */
		*pfgIs1X = TRUE;
	} else if (u2EtherTypeLen == ETH_P_PRE_1X) {	/*                  */
		/*                                  */
		*pfgIs1X = TRUE;
	}
#if CFG_SUPPORT_WAPI
	else if (u2EtherTypeLen == ETH_WPI_1X) {
		*pfgIs1X = TRUE;
	}
#endif
	else if (u2EtherTypeLen <= 1500) {	/*             */
		UINT_8 ucDSAP, ucSSAP, ucControl;
		UINT_8 aucOUI[3];

		*pfgIs802_3 = TRUE;

		ucDSAP = *(PUINT_8) &aucLookAheadBuf[ETH_LLC_OFFSET];
		ucSSAP = *(PUINT_8) &aucLookAheadBuf[ETH_LLC_OFFSET + 1];
		ucControl = *(PUINT_8) &aucLookAheadBuf[ETH_LLC_OFFSET + 2];

		aucOUI[0] = *(PUINT_8) &aucLookAheadBuf[ETH_SNAP_OFFSET];
		aucOUI[1] = *(PUINT_8) &aucLookAheadBuf[ETH_SNAP_OFFSET + 1];
		aucOUI[2] = *(PUINT_8) &aucLookAheadBuf[ETH_SNAP_OFFSET + 2];

		if (ucDSAP == ETH_LLC_DSAP_SNAP &&
		    ucSSAP == ETH_LLC_SSAP_SNAP &&
		    ucControl == ETH_LLC_CONTROL_UNNUMBERED_INFORMATION &&
		    aucOUI[0] == ETH_SNAP_BT_SIG_OUI_0 &&
		    aucOUI[1] == ETH_SNAP_BT_SIG_OUI_1 && aucOUI[2] == ETH_SNAP_BT_SIG_OUI_2) {
			*pfgIsPAL = TRUE;

			/*                         */
			if ((*(PUINT_8) &aucLookAheadBuf[ETH_SNAP_OFFSET + 3]) ==
			    ((BOW_PROTOCOL_ID_SECURITY_FRAME & 0xFF00) >> 8)
			    && (*(PUINT_8) &aucLookAheadBuf[ETH_SNAP_OFFSET + 4]) ==
			    (BOW_PROTOCOL_ID_SECURITY_FRAME & 0xFF)) {
				*pfgIs1X = TRUE;
			}
		}
	}
	/*                                               */
	*pucPriorityParam = ucUserPriority;

	/*                                        */
	/*                                    */
	*pu4PacketLen = u4PacketLen;
	kalMemCopy(pucEthDestAddr, aucLookAheadBuf, PARAM_MAC_ADDR_LEN);

	return TRUE;

}				/*                                */


/*                                                                            */
/* 
                                                              
 
                            
                                                                  
                            
                            
 
              
*/
/*                                                                            */
VOID
kalTimerEvent(IN PVOID systemSpecific1,
	      IN PVOID miniportAdapterContext, IN PVOID systemSpecific2, IN PVOID systemSpecific3)
{
	P_GLUE_INFO_T prGlueInfo = (P_GLUE_INFO_T) miniportAdapterContext;
	PFN_TIMER_CALLBACK pfTimerFunc = (PFN_TIMER_CALLBACK) prGlueInfo->pvTimerFunc;

	GLUE_SPIN_LOCK_DECLARATION();

	pfTimerFunc(prGlueInfo);
}

/*                                                                            */
/* 
                                       
 
                                                          
                                                                          
                                                   
 
              
 
*/
/*                                                                            */
VOID kalOsTimerInitialize(IN P_GLUE_INFO_T prGlueInfo, IN PVOID prTimerHandler)
{
	prGlueInfo->pvTimerFunc = prTimerHandler;

	/*                                                                      
                      
                                                           
                           */
	NdisMInitializeTimer(&prGlueInfo->rMasterTimer,
			     prGlueInfo->rMiniportAdapterHandle,
			     (PNDIS_TIMER_FUNCTION) kalTimerEvent, (PVOID) prGlueInfo);
}


/*                                                                            */
/* 
                                                                         
 
                                                      
                                                            
 
                       
*/
/*                                                                            */
BOOLEAN kalSetTimer(IN P_GLUE_INFO_T prGlueInfo, IN UINT_32 u4Interval)
{
	ASSERT(prGlueInfo);

	NdisMSetTimer(&prGlueInfo->rMasterTimer, u4Interval);
	return TRUE;		/*         */
}


/*                                                                            */
/* 
                                         
 
                                                      
 
                                           
                                       
*/
/*                                                                            */
BOOLEAN kalCancelTimer(IN P_GLUE_INFO_T prGlueInfo)
{
	BOOLEAN fgTimerCancelled;

	ASSERT(prGlueInfo);

	GLUE_CLEAR_FLAG(prGlueInfo, GLUE_FLAG_TIMEOUT);

	NdisMCancelTimer(&prGlueInfo->rMasterTimer, &fgTimerCancelled);

	return fgTimerCancelled;
}

/*                                                                            */
/* 
                                            
  
                                                            
  
                 
 */
/*                                                                            */
VOID kalTimeoutHandler(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	GLUE_SET_FLAG(prGlueInfo, GLUE_FLAG_TIMEOUT);

	/*                                          */
	GLUE_SET_EVENT(prGlueInfo);

	return;
}


/*                                                                            */
/* 
                                                                       
                                                                              
 
                                                  

              
*/
/*                                                                            */
VOID kalOidClearance(IN P_GLUE_INFO_T prGlueInfo)
{
	P_WLAN_REQ_ENTRY pvEntry;

	ASSERT(prGlueInfo);

	if (_InterlockedAnd(&prGlueInfo->rHifInfo.u4ReqFlag, ~REQ_FLAG_OID) & REQ_FLAG_OID) {
		pvEntry = (P_WLAN_REQ_ENTRY) prGlueInfo->pvOidEntry;

		ASSERT(pvEntry);

		GLUE_DEC_REF_CNT(prGlueInfo->i4OidPendingCount);
		ASSERT(prGlueInfo->i4OidPendingCount == 0);

		if (prGlueInfo->fgSetOid) {
			NdisMSetInformationComplete(prGlueInfo->rMiniportAdapterHandle,
						    NDIS_STATUS_FAILURE);
		} else {
			NdisMQueryInformationComplete(prGlueInfo->rMiniportAdapterHandle,
						      NDIS_STATUS_FAILURE);
		}
	}
}


/*                                                                            */
/* 
                                                                    
 
                                                  

              
               
*/
/*                                                                            */
BOOLEAN kalRetrieveNetworkAddress(IN P_GLUE_INFO_T prGlueInfo, IN OUT PARAM_MAC_ADDRESS * prMacAddr)
{
	ASSERT(prGlueInfo);

	if (prGlueInfo->rRegInfo.aucMacAddr[0] & BIT(0)) {	/*                     */
		return FALSE;
	} else {
		COPY_MAC_ADDR(prMacAddr, prGlueInfo->rRegInfo.aucMacAddr);

		return TRUE;
	}
}


/*                                                                            */
/* 
                                                                      
 
                                                  
                                                  
 
              
               
*/
/*                                                                            */
VOID kalUpdateMACAddress(IN P_GLUE_INFO_T prGlueInfo, IN PUINT_8 pucMacAddr)
{
	ASSERT(prGlueInfo);
	ASSERT(pucMacAddr);

	/*                                              */
	return;
}


/*                                                                            */
/* 
                                                                     
 
                                                  
                                            
 
              
               
*/
/*                                                                            */
VOID kalUpdateNetworkAddress(IN P_GLUE_INFO_T prGlueInfo, IN PARAM_MAC_ADDRESS rMacAddr)
{
	ASSERT(prGlueInfo);

	/*                                   */
	return;
}


/*                                                                            */
/* 
                                                    
 
                                                      
                                                                          
                                                                    

                                             
*/
/*                                                                            */
PVOID
kalFirmwareImageMapping(IN P_GLUE_INFO_T prGlueInfo,
			OUT PPVOID ppvMapFileBuf, OUT PUINT_32 pu4FileLength)
{
	NDIS_HANDLE *prFileHandleFwImg;
	NDIS_STRING rFileWifiRam;

	DEBUGFUNC("kalFirmwareImageMapping");

	ASSERT(prGlueInfo);
	ASSERT(ppvMapFileBuf);
	ASSERT(pu4FileLength);

	if ((prFileHandleFwImg = kalMemAlloc(sizeof(NDIS_HANDLE), VIR_MEM_TYPE)) == NULL) {
		DBGLOG(INIT, ERROR, ("Fail to allocate memory for NDIS_HANDLE!\n"));
		return NULL;
	}

	/*                            */
#if defined(MT6620) && CFG_MULTI_ECOVER_SUPPORT
	if (wlanGetEcoVersion(prGlueInfo->prAdapter) >= 6) {
		NdisInitUnicodeString(&rFileWifiRam, prGlueInfo->rRegInfo.aucFwImgFilenameE6);
	} else {
		NdisInitUnicodeString(&rFileWifiRam, prGlueInfo->rRegInfo.aucFwImgFilename);
	}
#else
	NdisInitUnicodeString(&rFileWifiRam, prGlueInfo->rRegInfo.aucFwImgFilename);
#endif
	if (!imageFileMapping(rFileWifiRam, prFileHandleFwImg, ppvMapFileBuf, pu4FileLength)) {
		DBGLOG(INIT, ERROR, ("Fail to load FW image from file!\n"));
		kalMemFree(prFileHandleFwImg, VIR_MEM_TYPE, sizeof(NDIS_HANDLE));
		return NULL;
	}

	return (PVOID) prFileHandleFwImg;
}


/*                                                                            */
/* 
                                                                    
 
                                                      
                                                 
                                                               
 
              
*/
/*                                                                            */
VOID
kalFirmwareImageUnmapping(IN P_GLUE_INFO_T prGlueInfo, IN PVOID prFwHandle, IN PVOID pvMapFileBuf)
{
	NDIS_HANDLE rFileHandleFwImg;

	DEBUGFUNC("kalFirmwareImageUnmapping");

	ASSERT(prGlueInfo);
	ASSERT(prFwHandle);
	ASSERT(pvMapFileBuf);

	rFileHandleFwImg = *(NDIS_HANDLE *) prFwHandle;

	/*       */
	imageFileUnMapping(rFileHandleFwImg, pvMapFileBuf);

	/*             */
	kalMemFree(prFwHandle, VIR_MEM_TYPE, sizeof(NDIS_HANDLE));

	return;

}


/*                                                                            */
/* 
                                                         
 
                                                      
 
                                   
                                          
*/
/*                                                                            */
BOOLEAN kalIsCardRemoved(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	return prGlueInfo->fgIsCardRemoved;
}


/*                                                                            */
/* 
                                                                       
 
                                                      
 
         
*/
/*                                                                            */
VOID kalFlushPendingTxPackets(IN P_GLUE_INFO_T prGlueInfo)
{
	P_QUE_T prTxQue;
	P_QUE_ENTRY_T prQueueEntry;
	PVOID prPacket;

	ASSERT(prGlueInfo);

	prTxQue = &(prGlueInfo->rTxQueue);

	if (prGlueInfo->i4TxPendingFrameNum) {
		while (TRUE) {
			GLUE_ACQUIRE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_TX_QUE);
			QUEUE_REMOVE_HEAD(prTxQue, prQueueEntry, P_QUE_ENTRY_T);
			GLUE_RELEASE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_TX_QUE);

			if (prQueueEntry == NULL) {
				break;
			}

			prPacket = GLUE_GET_PKT_DESCRIPTOR(prQueueEntry);

			kalSendComplete(prGlueInfo, prPacket, WLAN_STATUS_SUCCESS);
		}
	}
}


/*                                                                            */
/* 
                                                                          
 
                                                      
 
         
*/
/*                                                                            */
UINT_32 kalGetTxPendingFrameCount(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	return (UINT_32) (prGlueInfo->i4TxPendingFrameNum);
}


/*                                                                            */
/* 
                                                                        
                                                      
 
                                                      
 
         
*/
/*                                                                            */
UINT_32 kalGetTxPendingCmdCount(IN P_GLUE_INFO_T prGlueInfo)
{
	P_QUE_T prCmdQue;

	ASSERT(prGlueInfo);
	prCmdQue = &prGlueInfo->rCmdQueue;

	return prCmdQue->u4NumElem;
}


/*                                                                            */
/* 
                                                  
 
                                                      
 
              
*/
/*                                                                            */
ENUM_PARAM_MEDIA_STATE_T kalGetMediaStateIndicated(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	return prGlueInfo->eParamMediaStateIndicated;
}


/*                                                                            */
/* 
                                                          
 
                                                      
 
              
*/
/*                                                                            */
VOID
kalSetMediaStateIndicated(IN P_GLUE_INFO_T prGlueInfo,
			  IN ENUM_PARAM_MEDIA_STATE_T eParamMediaStateIndicate)
{
	ASSERT(prGlueInfo);

	prGlueInfo->eParamMediaStateIndicated = eParamMediaStateIndicate;
}


/*                                                                            */
/* 
                                                                        
 
                                                      
 
         
*/
/*                                                                            */
UINT_32 kalGetFwLoadAddress(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	return prGlueInfo->rRegInfo.u4LoadAddress;
}


/*                                                                            */
/* 
                                                                         
 
                                                      
 
         
*/
/*                                                                            */
UINT_32 kalGetFwStartAddress(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	return prGlueInfo->rRegInfo.u4StartAddress;
}


/*                                                                            */
/* 
                                                                           
 
                                                      
 
              
*/
/*                                                                            */
VOID kalOidCmdClearance(IN P_GLUE_INFO_T prGlueInfo)
{
	P_QUE_T prCmdQue;
	QUE_T rTempCmdQue;
	P_QUE_T prTempCmdQue = &rTempCmdQue;
	P_QUE_ENTRY_T prQueueEntry = (P_QUE_ENTRY_T) NULL;
	P_CMD_INFO_T prCmdInfo = (P_CMD_INFO_T) NULL;

	ASSERT(prGlueInfo);

	/*                                            */
	prCmdQue = &prGlueInfo->rCmdQueue;

	GLUE_ACQUIRE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_CMD_QUE);
	QUEUE_MOVE_ALL(prTempCmdQue, prCmdQue);

	QUEUE_REMOVE_HEAD(prTempCmdQue, prQueueEntry, P_QUE_ENTRY_T);
	while (prQueueEntry) {

		if (((P_CMD_INFO_T) prQueueEntry)->fgIsOid) {
			prCmdInfo = (P_CMD_INFO_T) prQueueEntry;
			break;
		} else {
			QUEUE_INSERT_TAIL(prCmdQue, prQueueEntry);
		}

		QUEUE_REMOVE_HEAD(prTempCmdQue, prQueueEntry, P_QUE_ENTRY_T);
	}

	QUEUE_CONCATENATE_QUEUES(prCmdQue, prTempCmdQue);
	GLUE_RELEASE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_CMD_QUE);

	if (prCmdInfo) {
		if (prCmdInfo->pfCmdTimeoutHandler) {
			prCmdInfo->pfCmdTimeoutHandler(prGlueInfo->prAdapter, prCmdInfo);
		} else {
			kalOidComplete(prGlueInfo, prCmdInfo->fgSetQuery, 0, WLAN_STATUS_FAILURE);
		}

		cmdBufFreeCmdInfo(prGlueInfo->prAdapter, prCmdInfo);
	}
}


/*                                                                            */
/* 
                                                               
 
                                                      
                                                             
 
              
*/
/*                                                                            */
VOID kalEnqueueCommand(IN P_GLUE_INFO_T prGlueInfo, IN P_QUE_ENTRY_T prQueueEntry)
{
	P_QUE_T prCmdQue;

	ASSERT(prGlueInfo);
	ASSERT(prQueueEntry);

	prCmdQue = &prGlueInfo->rCmdQueue;

	GLUE_ACQUIRE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_CMD_QUE);
	QUEUE_INSERT_TAIL(prCmdQue, prQueueEntry);
	GLUE_RELEASE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_CMD_QUE);
}


/*                                                                            */
/* 
                                                                  
 
                                                      
 
              
*/
/*                                                                            */
VOID kalClearSecurityFrames(IN P_GLUE_INFO_T prGlueInfo)
{
	P_QUE_T prCmdQue;
	QUE_T rTempCmdQue, rReturnCmdQue;
	P_QUE_T prTempCmdQue = &rTempCmdQue, prReturnCmdQue = &rReturnCmdQue;
	P_QUE_ENTRY_T prQueueEntry = (P_QUE_ENTRY_T) NULL;

	P_CMD_INFO_T prCmdInfo = (P_CMD_INFO_T) NULL;

	ASSERT(prGlueInfo);

	QUEUE_INITIALIZE(prReturnCmdQue);
	/*                                                        */
	prCmdQue = &prGlueInfo->rCmdQueue;

	GLUE_ACQUIRE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_CMD_QUE);
	QUEUE_MOVE_ALL(prTempCmdQue, prCmdQue);
	GLUE_RELEASE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_CMD_QUE);

	QUEUE_REMOVE_HEAD(prTempCmdQue, prQueueEntry, P_QUE_ENTRY_T);
	while (prQueueEntry) {
		prCmdInfo = (P_CMD_INFO_T) prQueueEntry;

		if (prCmdInfo->eCmdType == COMMAND_TYPE_SECURITY_FRAME) {
			if (prCmdInfo->pfCmdTimeoutHandler) {
				prCmdInfo->pfCmdTimeoutHandler(prGlueInfo->prAdapter, prCmdInfo);
			} else {
				wlanReleaseCommand(prGlueInfo->prAdapter, prCmdInfo,
						   TX_RESULT_QUEUE_CLEARANCE);
			}
			cmdBufFreeCmdInfo(prGlueInfo->prAdapter, prCmdInfo);
		} else {
			QUEUE_INSERT_TAIL(prReturnCmdQue, prQueueEntry);
		}

		QUEUE_REMOVE_HEAD(prTempCmdQue, prQueueEntry, P_QUE_ENTRY_T);
	}

	/*                                       */
	GLUE_ACQUIRE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_CMD_QUE);
	QUEUE_CONCATENATE_QUEUES_HEAD(prCmdQue, prReturnCmdQue);
	GLUE_RELEASE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_CMD_QUE);
}


/*                                                                            */
/* 
                                                              
                                          
 
                                                          
                                              
 
              
*/
/*                                                                            */
VOID kalClearSecurityFramesByBssIdx(IN P_GLUE_INFO_T prGlueInfo, IN UINT_8 ucBssIndex)
{
	P_QUE_T prCmdQue;
	QUE_T rTempCmdQue, rReturnCmdQue;
	P_QUE_T prTempCmdQue = &rTempCmdQue, prReturnCmdQue = &rReturnCmdQue;
	P_QUE_ENTRY_T prQueueEntry = (P_QUE_ENTRY_T) NULL;

	P_CMD_INFO_T prCmdInfo = (P_CMD_INFO_T) NULL;

	ASSERT(prGlueInfo);

	QUEUE_INITIALIZE(prReturnCmdQue);
	/*                                                        */
	prCmdQue = &prGlueInfo->rCmdQueue;

	GLUE_ACQUIRE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_CMD_QUE);
	QUEUE_MOVE_ALL(prTempCmdQue, prCmdQue);
	GLUE_RELEASE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_CMD_QUE);

	QUEUE_REMOVE_HEAD(prTempCmdQue, prQueueEntry, P_QUE_ENTRY_T);
	while (prQueueEntry) {
		prCmdInfo = (P_CMD_INFO_T) prQueueEntry;

		if (prCmdInfo->eCmdType == COMMAND_TYPE_SECURITY_FRAME &&
		    prCmdInfo->ucBssIndex == ucBssIndex) {
			if (prCmdInfo->pfCmdTimeoutHandler) {
				prCmdInfo->pfCmdTimeoutHandler(prGlueInfo->prAdapter, prCmdInfo);
			} else {
				wlanReleaseCommand(prGlueInfo->prAdapter, prCmdInfo,
						   TX_RESULT_QUEUE_CLEARANCE);
			}
			cmdBufFreeCmdInfo(prGlueInfo->prAdapter, prCmdInfo);
		} else {
			QUEUE_INSERT_TAIL(prReturnCmdQue, prQueueEntry);
		}

		QUEUE_REMOVE_HEAD(prTempCmdQue, prQueueEntry, P_QUE_ENTRY_T);
	}

	/*                                       */
	GLUE_ACQUIRE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_CMD_QUE);
	QUEUE_CONCATENATE_QUEUES_HEAD(prCmdQue, prReturnCmdQue);
	GLUE_RELEASE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_CMD_QUE);
}


/*                                                                            */
/* 
                                                                    
 
                                                      
 
              
*/
/*                                                                            */
VOID kalClearMgmtFrames(IN P_GLUE_INFO_T prGlueInfo)
{
	P_QUE_T prCmdQue;
	QUE_T rTempCmdQue, rReturnCmdQue;
	P_QUE_T prTempCmdQue = &rTempCmdQue, prReturnCmdQue = &rReturnCmdQue;
	P_QUE_ENTRY_T prQueueEntry = (P_QUE_ENTRY_T) NULL;

	P_CMD_INFO_T prCmdInfo = (P_CMD_INFO_T) NULL;

	ASSERT(prGlueInfo);

	QUEUE_INITIALIZE(prReturnCmdQue);
	/*                                                          */
	prCmdQue = &prGlueInfo->rCmdQueue;

	GLUE_ACQUIRE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_CMD_QUE);
	QUEUE_MOVE_ALL(prTempCmdQue, prCmdQue);
	GLUE_RELEASE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_CMD_QUE);

	QUEUE_REMOVE_HEAD(prTempCmdQue, prQueueEntry, P_QUE_ENTRY_T);
	while (prQueueEntry) {
		prCmdInfo = (P_CMD_INFO_T) prQueueEntry;

		if (prCmdInfo->eCmdType == COMMAND_TYPE_MANAGEMENT_FRAME) {
			wlanReleaseCommand(prGlueInfo->prAdapter, prCmdInfo,
					   TX_RESULT_QUEUE_CLEARANCE);
			cmdBufFreeCmdInfo(prGlueInfo->prAdapter, prCmdInfo);
		} else {
			QUEUE_INSERT_TAIL(prReturnCmdQue, prQueueEntry);
		}

		QUEUE_REMOVE_HEAD(prTempCmdQue, prQueueEntry, P_QUE_ENTRY_T);
	}

	/*                                       */
	GLUE_ACQUIRE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_CMD_QUE);
	QUEUE_CONCATENATE_QUEUES_HEAD(prCmdQue, prReturnCmdQue);
	GLUE_RELEASE_SPIN_LOCK(prGlueInfo, SPIN_LOCK_CMD_QUE);
}


/*                                                                            */
/* 
                                                         
 
             
 
                 
*/
/*                                                                            */
UINT_32 kalRandomNumber(VOID)
{
	UINT_32 u4Seed;

	u4Seed = kalGetTimeTick();

	return RtlRandomEx(&u4Seed);
}


/*                                                                            */
/* 
                                         
 
                                              
                                             
                              
 
              
*/
/*                                                                            */
VOID
kalScanDone(IN P_GLUE_INFO_T prGlueInfo,
	    IN ENUM_KAL_NETWORK_TYPE_INDEX_T eNetTypeIdx, IN WLAN_STATUS rStatus)
{
	ASSERT(prGlueInfo);

	/*                                                                          */
	wlanCheckSystemConfiguration(prGlueInfo->prAdapter);

	return;
}


#if CFG_ENABLE_BT_OVER_WIFI
/*                                                                            */
/* 
                                                   
 
            
                      
                   
         
                
*/
/*                                                                            */
VOID kalIndicateBOWEvent(IN P_GLUE_INFO_T prGlueInfo, IN P_AMPC_EVENT prEvent)
{
	ASSERT(prGlueInfo);

	/*                             */

	return;
}

/*                                                                            */
/* 
                                                               
 
            
                      
         
                                 
*/
/*                                                                            */
ENUM_BOW_DEVICE_STATE kalGetBowState(IN P_GLUE_INFO_T prGlueInfo, IN PARAM_MAC_ADDRESS rPeerAddr)
{
	ASSERT(prGlueInfo);

	/*                             */

	return BOW_DEVICE_STATE_DISCONNECTED;
}


/*                                                                            */
/* 
                                                        
 
            
                      
                     
 
         
                
*/
/*                                                                            */
VOID
kalSetBowState(IN P_GLUE_INFO_T prGlueInfo,
	       IN ENUM_BOW_DEVICE_STATE eBowState, IN PARAM_MAC_ADDRESS rPeerAddr)
{
	ASSERT(prGlueInfo);

	/*                             */

	return;
}


/*                                                                            */
/* 
                                                      
 
            
                      
 
         
                                         
                                                     
                                                   
 
                                     
                                                      
                                                        
 
                                      
                                                             
*/
/*                                                                            */
ENUM_BOW_DEVICE_STATE kalGetBowGlobalState(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	/*                             */

	return BOW_DEVICE_STATE_DISCONNECTED;
}


/*                                                                            */
/* 
                                                             
 
            
                      
 
         
                          
*/
/*                                                                            */
UINT_32 kalGetBowFreqInKHz(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	/*                             */

	return 0;
}


/*                                                                            */
/* 
                                              
 
            
                      
 
         
                        
                        
*/
/*                                                                            */
UINT_8 kalGetBowRole(IN P_GLUE_INFO_T prGlueInfo, IN PARAM_MAC_ADDRESS rPeerAddr)
{
	ASSERT(prGlueInfo);

	/*                             */

	return 0;
}


/*                                                                            */
/* 
                                         
 
            
                      
                  
                                
                                
         
                
*/
/*                                                                            */
VOID kalSetBowRole(IN P_GLUE_INFO_T prGlueInfo, IN UINT_8 ucRole, IN PARAM_MAC_ADDRESS rPeerAddr)
{
	ASSERT(prGlueInfo);

	/*                             */

	return;
}


/*                                                                            */
/* 
                                                                   
 
            
                      
         
                   
                                                      
*/
/*                                                                            */
UINT_32 kalGetBowAvailablePhysicalLinkCount(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	/*                             */

	return 0;
}
#endif

#if CFG_ENABLE_WIFI_DIRECT
/*                                                                            */
/* 
                                                       
 
            
                      
                     
         
                                 
*/
/*                                                                            */
ENUM_PARAM_MEDIA_STATE_T kalP2PGetState(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	/*                                  */

	return PARAM_MEDIA_STATE_DISCONNECTED;
}


/*                                                                            */
/* 
                                                
 
            
                      
                     
                     
         
                
*/
/*                                                                            */
VOID
kalP2PSetState(IN P_GLUE_INFO_T prGlueInfo,
	       IN ENUM_PARAM_MEDIA_STATE_T eState, IN PARAM_MAC_ADDRESS rPeerAddr, IN UINT_8 ucRole)
{
	ASSERT(prGlueInfo);

	switch (eState) {
	case PARAM_MEDIA_STATE_CONNECTED:
		/*                              */
		break;

	case PARAM_MEDIA_STATE_DISCONNECTED:
		/*                                 */
		break;

	default:
		ASSERT(0);
		break;
	}
	/*                                  */

	return;
}


/*                                                                            */
/* 
                                                     
 
            
                      
 
         
                          
*/
/*                                                                            */
UINT_32 kalP2PGetFreqInKHz(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	/*                                  */

	return 0;
}


/*                                                                            */
/* 
                                              
 
            
                      
 
         
                         
                           
                          
*/
/*                                                                            */
UINT_8 kalP2PGetRole(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	/*                                  */

	return 0;
}


/*                                                                            */
/* 
                                 
 
            
                      
                    
                                 
                            
                  
                                 
                                   
                                  
 
         
                
*/
/*                                                                            */
VOID
kalP2PSetRole(IN P_GLUE_INFO_T prGlueInfo,
	      IN UINT_8 ucResult, IN PUINT_8 pucSSID, IN UINT_8 ucSSIDLen, IN UINT_8 ucRole)
{
	ASSERT(prGlueInfo);
	ASSERT(ucRole <= 2);

	/*                                  */

	return;
}


/*                                                                            */
/* 
                                                         
 
                                              
 
                        
                       
*/
/*                                                                            */
BOOLEAN kalP2PIndicateFound(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	/*                                  */
	/*                                    */

	return FALSE;
}


/*                                                                            */
/* 
                                                                      
 
                                              
 
              
*/
/*                                                                            */
VOID kalP2PIndicateConnReq(IN P_GLUE_INFO_T prGlueInfo, IN PUINT_8 pucDevName, IN INT_32 u4NameLength, IN PARAM_MAC_ADDRESS rPeerAddr, IN UINT_8 ucDevType,	/*                               */
			   IN INT_32 i4ConfigMethod, IN INT_32 i4ActiveConfigMethod)
{
	ASSERT(prGlueInfo);

	/*                                  */
	/*                                   */

	return;
}

/*                                                                            */
/* 
                                                                      
 
                                              
 
              
*/
/*                                                                            */
VOID
kalP2PInvitationIndication(IN P_GLUE_INFO_T prGlueInfo,
			   IN P_P2P_DEVICE_DESC_T prP2pDevDesc,
			   IN PUINT_8 pucSsid,
			   IN UINT_8 ucSsidLen,
			   IN UINT_8 ucOperatingChnl, IN UINT_8 ucInvitationType)
{
	ASSERT(prGlueInfo);

	/*                                  */
	/*                                   */

	return;
}



/*                                                                            */
/* 
                                  
 
            
                      
                    
 
         
                
*/
/*                                                                            */
VOID kalP2PSetCipher(IN P_GLUE_INFO_T prGlueInfo, IN UINT_32 u4Cipher)
{
	ASSERT(prGlueInfo);

	/*                                  */
	return;
}


/*                                                                            */
/* 
                                                     
 
            
                      
 
         
                                
                                 
*/
/*                                                                            */
BOOLEAN kalP2PGetCipher(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	/*                                  */
	return FALSE;
}


/*                                                                            */
/* 
                                                     
 
            
                      
 
         
                                
                                 
*/
/*                                                                            */
BOOLEAN kalP2PGetTkipCipher(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	/*                                  */
	return FALSE;
}


/*                                                                            */
/* 
                                                     
 
            
                      
 
         
                                
                                 
*/
/*                                                                            */
BOOLEAN kalP2PGetCcmpCipher(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	/*                                  */
	return FALSE;
}


/*                                                                            */
/* 
                                 
 
            
                      
 
         
                             
*/
/*                                                                            */
UINT_16 kalP2PCalWSC_IELen(IN P_GLUE_INFO_T prGlueInfo, IN UINT_8 ucType)
{
	ASSERT(prGlueInfo);

	/*                                  */

	return 0;
}


/*                                                                            */
/* 
                                                       
 
            
                      
 
         
                             
*/
/*                                                                            */
VOID kalP2PGenWSC_IE(IN P_GLUE_INFO_T prGlueInfo, IN UINT_8 ucType, IN PUINT_8 pucBuffer)
{
	ASSERT(prGlueInfo);

	/*                                  */
}


/*                                                                            */
/* 
                                       
 
            
                      
                     
                     
         
                
*/
/*                                                                            */
VOID
kalP2PUpdateAssocInfo(IN P_GLUE_INFO_T prGlueInfo,
		      IN PUINT_8 pucFrameBody,
		      IN UINT_32 u4FrameBodyLen, IN BOOLEAN fgReassocRequest)
{
	ASSERT(prGlueInfo);

	/*                                  */
}
#endif


/*                                                                            */
/* 
                                                               
 
            
                      
 
         
                
                 
*/
/*                                                                            */
BOOLEAN kalIsConfigurationExist(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	/*                                          */
	return TRUE;
}


/*                                                                            */
/* 
                                         
 
            
                      
 
         
                                 
*/
/*                                                                            */
P_REG_INFO_T kalGetConfiguration(IN P_GLUE_INFO_T prGlueInfo)
{
	ASSERT(prGlueInfo);

	return &(prGlueInfo->rRegInfo);
}


/*                                                                            */
/* 
                                                                            
 
            
                      
 
             
                                 
                                  
                                 
                                  
 
         
                
*/
/*                                                                            */
VOID
kalGetConfigurationVersion(IN P_GLUE_INFO_T prGlueInfo,
			   OUT PUINT_16 pu2Part1CfgOwnVersion,
			   OUT PUINT_16 pu2Part1CfgPeerVersion,
			   OUT PUINT_16 pu2Part2CfgOwnVersion, OUT PUINT_16 pu2Part2CfgPeerVersion)
{
	ASSERT(prGlueInfo);

	ASSERT(pu2Part1CfgOwnVersion);
	ASSERT(pu2Part1CfgPeerVersion);
	ASSERT(pu2Part2CfgOwnVersion);
	ASSERT(pu2Part2CfgPeerVersion);

	/*                                */
	/*                                                 */
	/*                                                                 */
	/*                                                      */

	*pu2Part1CfgOwnVersion = UINT16_MAX;
	*pu2Part1CfgPeerVersion = 0;

	*pu2Part2CfgOwnVersion = UINT16_MAX;
	*pu2Part2CfgPeerVersion = 0;

	return;
}

/*                                                                            */
/* 
                                      
 
            
                      
                    
             
                   
         
                
                 
*/
/*                                                                            */
BOOLEAN kalCfgDataRead16(IN P_GLUE_INFO_T prGlueInfo, IN UINT_32 u4Offset, OUT PUINT_16 pu2Data)
{
	ASSERT(prGlueInfo);

	/*                                             */
	return FALSE;
}


/*                                                                            */
/* 
                                      
 
            
                      
                    
                  
         
                
                 
*/
/*                                                                            */
BOOLEAN kalCfgDataWrite16(IN P_GLUE_INFO_T prGlueInfo, IN UINT_32 u4Offset, IN UINT_16 u2Data)
{
	ASSERT(prGlueInfo);

	/*                                             */
	return FALSE;
}

/*                                                                            */
/* 
                                             
 
            
                      
 
         
                
                 
*/
/*                                                                            */
BOOLEAN kalWSCGetActiveState(IN P_GLUE_INFO_T prGlueInfo)
{
	/*                                      */
	return (FALSE);
}


/*                                                                            */
/* 
                                                  
 
            
                      
                       
                 
                        
 
         
                
*/
/*                                                                            */
VOID
kalUpdateRSSI(IN P_GLUE_INFO_T prGlueInfo,
	      IN ENUM_KAL_NETWORK_TYPE_INDEX_T eNetTypeIdx, IN INT_8 cRssi, IN INT_8 cLinkQuality)
{
	ASSERT(prGlueInfo);

	switch (eNetTypeIdx) {
	case KAL_NETWORK_TYPE_AIS_INDEX:
		break;

	default:
		break;

	}

	return;
}


/*                                                                            */
/* 
                                          
 
            
                       
 
         
                                                         
*/
/*                                                                            */
PVOID kalAllocateIOBuffer(IN UINT_32 u4AllocSize)
{
	return kalMemAlloc(u4AllocSize, PHY_MEM_TYPE);
}


/*                                                                            */
/* 
                                          
 
            
                  
                  
 
         
                
*/
/*                                                                            */
VOID kalReleaseIOBuffer(IN PVOID pvAddr, IN UINT_32 u4Size)
{
	kalMemFree(pvAddr, PHY_MEM_TYPE, u4Size);
}


#if CFG_CHIP_RESET_SUPPORT
/*                                                                            */
/* 
                                 
 
            
                
 
         
                
*/
/*                                                                            */
VOID glSendResetRequest(VOID)
{
	/*                                      */
	return;
}


/*                                                                            */
/* 
                                                                    
  
                
  
                
                 
 */
/*                                                                            */
BOOLEAN kalIsResetting(VOID)
{
	return FALSE;
}
#endif


/*                                                                            */
/* 
                                                         
  
              
                       
                          
                       
                      
  
                  
  
 */
/*                                                                            */
UINT_32 kalWriteToFile(const PUINT_8 pucPath, BOOLEAN fgDoAppend, PUINT_8 pucData, UINT_32 u4Size)
{
	/*                                      */
	HANDLE hFile;
	IO_STATUS_BLOCK ioStatusBlock;
	HANDLE handle;
	NTSTATUS ntstatus;
	LARGE_INTEGER byteOffset;
	UNICODE_STRING uniName;
	OBJECT_ATTRIBUTES objAttr;
	/*                    */
	RtlInitUnicodeString(&uniName, pucPath);

	InitializeObjectAttributes(&objAttr, &uniName,
				   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
	/*  */

	if (KeGetCurrentIrql() != PASSIVE_LEVEL)
		return STATUS_INVALID_DEVICE_STATE;
	if (!fgDoAppend) {
		ntstatus = ZwCreateFile(&handle,
					GENERIC_WRITE,
					&objAttr, &ioStatusBlock, NULL,
					FILE_ATTRIBUTE_NORMAL,
					0,
					FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);

	} else {
		ntstatus = ZwOpenFile(&handle,
				      FILE_APPEND_DATA,
				      &objAttr, &ioStatusBlock,
				      FILE_SHARE_READ | FILE_SHARE_WRITE,
				      FILE_SYNCHRONOUS_IO_NONALERT);


	}

	ntstatus = ZwWriteFile(handle, NULL, NULL, NULL, &ioStatusBlock,
			       pucData, u4Size, NULL, NULL);
	ZwClose(handle);
	return 0;
}


/*                                                                            */
/* 
                            
  
              
  
                  
  
 */
/*                                                                            */
UINT_32
kal_sprintf_ddk(const PUINT_8 pucPath,
		UINT_32 u4size, const char *fmt1, const char *fmt2, const char *fmt3)
{
#if 0
	RtlStringCbPrintfW(pucPath, u4size,
			   L"\\SystemRoot\\dump_%ld_0x%08lX_%ld.hex", fmt1, fmt2, fmt3);
#else
	RtlStringCbPrintfW(pucPath, u4size, L"\\SystemRoot\\dump.hex");

#endif
	return 0;
}

UINT_32 kal_sprintf_done_ddk(const PUINT_8 pucPath, UINT_32 u4size)
{
	RtlStringCbPrintfW(pucPath, u4size, L"\\SystemRoot\\dump_done.txt");

	return 0;
}

#if CFG_SUPPORT_SDIO_READ_WRITE_PATTERN
/*                                                                            */
/* 
                                               
 
            
                      
                
                  
 
         
                
                 
*/
/*                                                                            */
BOOLEAN kalSetSdioTestPattern(IN P_GLUE_INFO_T prGlueInfo, IN BOOLEAN fgEn, IN BOOLEAN fgRead)
{
	const UINT_8 aucPattern[] = {
		0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55,
		0xaa, 0x55, 0x80, 0x80, 0x80, 0x7f, 0x80, 0x80,
		0x80, 0x7f, 0x7f, 0x7f, 0x80, 0x7f, 0x7f, 0x7f,
		0x40, 0x40, 0x40, 0xbf, 0x40, 0x40, 0x40, 0xbf,
		0xbf, 0xbf, 0x40, 0xbf, 0xbf, 0xbf, 0x20, 0x20,
		0x20, 0xdf, 0x20, 0x20, 0x20, 0xdf, 0xdf, 0xdf,
		0x20, 0xdf, 0xdf, 0xdf, 0x10, 0x10, 0x10, 0xef,
		0x10, 0x10, 0x10, 0xef, 0xef, 0xef, 0x10, 0xef,
		0xef, 0xef, 0x08, 0x08, 0x08, 0xf7, 0x08, 0x08,
		0x08, 0xf7, 0xf7, 0xf7, 0x08, 0xf7, 0xf7, 0xf7,
		0x04, 0x04, 0x04, 0xfb, 0x04, 0x04, 0x04, 0xfb,
		0xfb, 0xfb, 0x04, 0xfb, 0xfb, 0xfb, 0x02, 0x02,
		0x02, 0xfd, 0x02, 0x02, 0x02, 0xfd, 0xfd, 0xfd,
		0x02, 0xfd, 0xfd, 0xfd, 0x01, 0x01, 0x01, 0xfe,
		0x01, 0x01, 0x01, 0xfe, 0xfe, 0xfe, 0x01, 0xfe,
		0xfe, 0xfe, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
		0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
		0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
		0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
		0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
		0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff,
		0x00, 0x00, 0x00, 0xff
	};
	UINT_32 i;

	ASSERT(prGlueInfo);

	/*                                         */
	prGlueInfo->fgEnSdioTestPattern = fgEn;
	prGlueInfo->fgSdioReadWriteMode = fgRead;

	if (fgRead == FALSE) {
		/*                                    */
		for (i = 0; i < sizeof(aucPattern); i++) {
			prGlueInfo->aucSdioTestBuffer[i] = aucPattern[i];
		}
	}

	return TRUE;
}
#endif


VOID
kalReadyOnChannel(IN P_GLUE_INFO_T prGlueInfo,
		  IN UINT_64 u8Cookie,
		  IN ENUM_BAND_T eBand,
		  IN ENUM_CHNL_EXT_T eSco, IN UINT_8 ucChannelNum, IN UINT_32 u4DurationMs)
{
	/*                       */
	return;
}


VOID
kalRemainOnChannelExpired(IN P_GLUE_INFO_T prGlueInfo,
			  IN UINT_64 u8Cookie,
			  IN ENUM_BAND_T eBand, IN ENUM_CHNL_EXT_T eSco, IN UINT_8 ucChannelNum)
{
	/*                       */
	return;
}


VOID
kalIndicateMgmtTxStatus(IN P_GLUE_INFO_T prGlueInfo,
			IN UINT_64 u8Cookie,
			IN BOOLEAN fgIsAck, IN PUINT_8 pucFrameBuf, IN UINT_32 u4FrameLen)
{
	/*                       */
	return;
}


VOID kalIndicateRxMgmtFrame(IN P_GLUE_INFO_T prGlueInfo, IN P_SW_RFB_T prSwRfb)
{
	/*                       */
	return;
}


VOID kalSchedScanResults(IN P_GLUE_INFO_T prGlueInfo)
{
	/*                       */
	return;
}


VOID kalSchedScanStopped(IN P_GLUE_INFO_T prGlueInfo)
{
	/*                       */
	return;
}


BOOLEAN
kalGetEthDestAddr(IN P_GLUE_INFO_T prGlueInfo,
		  IN P_NATIVE_PACKET prPacket, OUT PUINT_8 pucEthDestAddr)
{
	PNDIS_BUFFER prNdisBuffer;
	UINT_32 u4PacketLen;

	UINT_32 u4ByteCount = 0;
	PNDIS_PACKET prNdisPacket = (PNDIS_PACKET) prPacket;

	DEBUGFUNC("kalGetEthDestAddr");

	ASSERT(prGlueInfo);
	ASSERT(pucEthDestAddr);

	/*                                       */
	NdisQueryPacket(prNdisPacket, NULL, NULL, &prNdisBuffer, &u4PacketLen);

	if (u4PacketLen < 6) {
		DBGLOG(INIT, WARN, ("Invalid Ether packet length: %d\n", u4PacketLen));
		return FALSE;
	}
	/*                                                     */
	while (prNdisBuffer && u4ByteCount < 6) {
		PVOID pvAddr;
		UINT_32 u4Len;
		PNDIS_BUFFER prNextNdisBuffer;

#ifdef NDIS51_MINIPORT
		NdisQueryBufferSafe(prNdisBuffer, &pvAddr, &u4Len, HighPagePriority);
#else
		NdisQueryBuffer(prNdisBuffer, &pvAddr, &u4Len);
#endif

		if (pvAddr == (PVOID) NULL) {
			ASSERT(0);
			return FALSE;
		}

		if ((u4ByteCount + u4Len) >= 6) {
			kalMemCopy((PUINT_8) ((UINT_32) pucEthDestAddr + u4ByteCount),
				   pvAddr, (6 - u4ByteCount));
			break;
		} else {
			kalMemCopy((PUINT_8) ((UINT_32) pucEthDestAddr + u4ByteCount),
				   pvAddr, u4Len);
		}
		u4ByteCount += u4Len;

		NdisGetNextBuffer(prNdisBuffer, &prNextNdisBuffer);

		prNdisBuffer = prNextNdisBuffer;
	}

	return TRUE;
}
